

ÇhÄCHAPTER Å1Ç| mÄINTRODUCTIONÇ| 1 ls

ÇpÄ'D' is the name of a virtual computer and also names the native language of Äthis machine. The virtual D computer requires a physical host to operate, but Äcreates a private computing environment that isolates you from many, albeit not Äall, idiosyncrasies of the host.Ç|

ÇpÄD is not a new concept, it is a combination of long-known concepts that the 
Äauthor found useful in organizing his own information shop. It has been Ädistilled from experiences made over 25 years, leaving behind as superfluous Ämuch more than what was preserved as worthy.Ç|Ä 

ÇpÄThree concepts are essential. D encodes information in a form that allows Ärecognition independent of  context.  D makes no principal distinction between Äinformation that serves as 'datum' and information that serves as 'instruction'.Ä  D organizes all  composite information linearly.Ç|

ÇpÄThese  principles  are natural as they underlie also the chemistry  of  a 
Äliving  cell.  The  molecules of a cell can recognize  one another;  they 
Ätravel on their own,  yet find their targets.  Substrates and enzymes are 
Ämade of one set of atoms or molecular  sub-assemblies.  Three-dimensional 
Äproteins are built as linear chains of aminoacids.  The cell develops  in 
Äspace  and  time using genetic information encoded in  linear  arrays  of 
Änucleotides.Ç|

ÇpÄPerhaps, D is a more natural way of using a computer.Ç|

ÇcÅ1.1 A computer of objectsÇ|

ÇpÄThe  D computer works with quanta of information,  which we  shall  call 
Ä'objects'  (adding  a usage to an existing term,  rather  than  inventing 
Äsomething like 'quarks').  An object comprises a ÅvalueÄ (the essence, from 
Äyour   point  of  view)  and  a  ÅdescriptionÄ  that  carries  a   thorough 
Äspecification (transparently used by the machine,  but also accessible to 
Äyou).  Once  information has been organized in the form of  objects,  the Ämachine can work with it in an abstract way,  because it knows the  physical 
Äimplications and 'understands' the objects that it manipulates as well as 
Äyou do.  Conversely, thinking in D objects is not a tour de force for the 
Ähuman mind,  because these objects are familiar abstractions. Objects provide  aÄ common ground between person and machine.Ç|
Ä 
ÇpÄD  sets out from a few varieties ofÑ Åsimple  objectÄ.  Among  them,  ÑnameÄ, 
ÑnumeralÄ,  andÑ  operatorÄ are the workhorses.  Simple objects serve as  the 
Äbuilding  material  of Åcomposite objectsÄ.  There  are  several  composite 
Ävarieties,  such as the ÑlistÄ  and  the  ÑdictionaryÄ. 
ÄComposite objects themselves can become elements of higher composite objects, Äand so 
Äon.  There  is no logical limit to the internal complexity  of  composite 
Äobjects that you create.  With regard to quantity, anything from a single 
Ämeasured sample to accumulated experimental results of several years  can 
Äbecome an object to the D machine.Ç|

ÇpÄObjects serve as the elements of data as well as of  instructions:  they 
Äcan be used as operands or can be executed with specific effects. 'Datum' 
Äor 'instruction' are changeable attributes,  not fundamental  properties. 
ÄBecause  one  and the same form fits datum  and  instruction,  these  two 
Ävarieties of information are readily combined into composite objects that 
Ärepresent  both Åpassive and active propertiesÄ of things that you wish  to 
Ämodel in the computer.Ç|

ÇpÄD  retrieves  objects by ÅassociationÄ.  Collections of objects  that  are 
Ämutually associated in some sense can be created in the form of composite 
Äobjects.  Composite  objects that hold associations of objects are  ÅlistsÄ 
Äand  ÅdictionariesÄ.  Lists  hold  an array of objects  that  are  accessed 
Ärandomly or sequentially through a numerical index.  Dictionaries hold an 
Äarray of paired entries, of which the first is a name, and the second any 
Äobject that is associated with the name.  References within  dictionaries 
Äare made by name.  Lists and dictionaries are dynamic:  entries are  made 
Äand re-defined at any time.Ç|

ÇpÄAlbeit  a logical entity,  the value and the description of a  composite 
Äobject are physically distinct.  When you logically designate a composite 
Äobject,  you  physically  refer  to  a  description  of  the  object.  By 
Äphysically  duplicating  only  the description  of  a  composite  object, 
Ämultiple   logical  copies  of  the  composite  object  can  be   created 
Äeconomically and used in multiple associations.Ç|

ÄD  lets you create also composite objects that comprise a subset  of  the 
Ävalue of a parent composite object. These Åchildren objectsÄ do not receive 
Äa duplicate of the parent's value:  they share one and the same original. 
ÄChildren  objects are combined with other objects (including children  of 
Äother composite objects) into new composite objects in unlimited cut-and-
Äpaste operations.  Altogether,  these techniques,  transparently based on 
Äobject  descriptions  as the representatives of values,  let  you  create 
Ämultiple specific access schemes to a body of information.Ç|

ÇpÄThe  most  common method for the retrieval of a D object is  through  an 
Äassociated  name,  a time-honoured practice.  Upon every reference  to  a 
Äname,  however,  the D machine determines the Åcurrently associated objectÄ 
Äthrough  an ad hoc search of the vocabulary in use.  This  vocabulary  is 
Äsubject to change. Names can be defined or re-defined in each dictionary, 
Äand  dictionaries as a whole can be moved in and out of  use.  Thus,  the 
Ämachine  is  capable  of  'learning' new  terms  or  'switching'  between 
Äalternate  definitions of terms.  The swapping of dictionaries gives  the 
Ämachine a touch of intelligence,  in that it can dynamically relate  term 
Äand context.  Furthermore,  it enables the machine to attend a variety of 
Ätasks  randomly  without becoming confused,  and enables it  to  securely 
Äcontrol  the  access to information.  The instructions to  control  these 
Äcapabilities are very simple.Ç|Ä  

ÇpÄD  uses  the  object form to organize information  bothÅ  internallyÄ  (in 
Ämemory) and ÅexternallyÄ (e.g.,  in disk mass storage).  This has two major 
Äbenefits.  First,  information is exchanged efficiently between  internal 
Äand external sites,  because the object value is stored coherently and is 
Ämoved  as a literal,  bit-for-bit copy (a small set of special  operators 
Äsuffices  to  move object values or their  subsets).  Second,  since  the 
Ädescription and value of a composite object are physically separate, operations Äthat do not involve the value can be performed solely with the description  in 
Ähand.  Thus  you  can build lists and dictionaries  of  external  logical 
Äobjects  in internal memory and store these on arbitrary media.  You  can 
Äbuild  information schemes that involve pieces stored in  many  different 
Ämedia.  Conversely,  you  can  reference one and the same value  in  many 
Ädifferent ways and contexts. No new rules or tricks are needed here: it is Åone ÅgameÄ of objectsÇ|

ÇpÄThe  D  machine  takes  direct control  of  external  object  media  and 
Äorganizes  these private media separately and in parallel to  the  host's 
Äfile systems (which you can access as well).Ç|

ÇpÄA  D  machine at work Åfeeds on objectsÄ,  consuming them one at  a  time. 
ÄEvery received object is dealt with immediately according to the rules of 
Äthe  Ñreverse  Polish  notationÄ (RPN,  as  familiar  from  Hewlett-Packard 
Äcalculators). A consumed object either is transferred to the operand stack 
Äto serve as operand, or initiates one or several operations. An operation 
Äconsumes some or all of the objects accumulated on the operand stack, and 
Äin turn may push result objects on the stack,  ready for being  processed 
Äby  subsequent operations.  By an ironclad design  rule,  operations  are 
Äunaware  of  their  precursors  or  followers  (that  is  your  exclusive 
Äprivilege).  Information  passed  from one operation to  another  by  the 
Äimplicit  use of the stack needs not be specified.  This keeps  the  code 
Älean and the focus on the action.  Perhaps the most important windfall of 
ÄRPN is that for any single object that you feed the machine you know  the 
Äexact  consequences and the exact instant when these occur.  No high-level Äsyntax can substitute for this knowledge.Ç|

ÇpÄThe  D  machine  accepts  objects in  two  forms:  ÅtextÄ  or  ÅbinaryÄ.  It 
Ärecognizes automatically which form is being presented (by inspecting the 
Ädescription of the composite source object).  When working from  text,  D 
Äautomatically   translates  text  tokens  into  binary   objects   before 
Äsubmitting  them to its internal mill of binaries.  This front end  makes 
Äobsolete  intermediaries  such  as  command  line   interpreters,   batch 
Äprocessors,  compilers, linkers, or loaders of executable files, together 
Äwith their many idioms.  Conversely,  binary objects are easily converted 
Äinto their text form and saved in a file. The contents of such files, for 
Äexample,  may  be  made  available  to  PostScript  devices  for  printed 
Ärepresentations  (PostScript and D share compatible text  notations).  In 
Äeffect, one Ñlingua francaÄ, D, serves to concisely express and communicate 
Äall kinds of datum or instruction.Ç|

ÇpÄAs a language of action,  D thrives on verbs,  here called ÑoperatorsÄ and 
ÑproceduresÄ. ÅOperatorsÄ invoke instruction modules directly executed by the 
Ähost  machine.  Some  operators  do jobs as small as  those  of  hardware 
Äinstructions of the host machine,  but the majority provide services that 
Ärequire  many host instructions.  Polymorphic D operators accept  diverse 
Äkinds of object to work on,  and tune themselves using information in the 
Äobject  descriptions.   For  instance,   the  'add'  operator  takes  any 
Äcombination of numeral types,  performs the addition in several  possible 
Äforms of arithmetic or precision,  and combines scalar with scalar, array 
Äwith  array,  or  scalar with array.  Old and new  undefined  values  are 
Ärecognized  and  propagated into the results without  need  for  explicit 
Äexception handling.  Your plan can be formulated in D without  attracting 
Äthe usual cloud of confusing, albeit necessary, second thoughts.Ç|

ÇpÄVersatile  operators keep D programs concise and comfortable  to  write. 
ÄFurthermore,  D  lets you define new operators in the form of  Åprocedures 
Ä(lists  of  objects  to be executed).  The  overhead  of  composition  is 
Äminimal.  In the text representation, a pair of {} brackets wrap a set of 
Äobjects  that constitute the procedure;  a subsequent  operation  usually 
Ägives the new thing a name.  Procedures being executed can use the  stack 
Äfor  their operands and results as do the operators.  Thus,  there is  no 
Äformal  difference  between  references to an operator  and  those  to  a 
Äprocedure.   This  continuity  fosters  the  fine-grain  decomposition  of 
Äinformation,  and,  together with explicit and well-thought names,  produces 
Ästructured code that is intelligible to person and machine.Ç|

ÇpÄWhile executing objects,  the machineÅ controls its own operationÄ like  a 
Äphysical computer that executes its native code.  Hence,  D can implement 
Äfunctions of operating systems, shells, graphical interfaces, debuggers, menus, Ätasks, or  whatever layers of instruction are desirable. The capacity of Äself-organization flows from a capacity sheepishly excluded by conventional Äprogramming models: data  and instructions are formed from one and the same set,Ä  objects. The D  machine 
Äcan compute 'instructions' like it  computes 'data'.  This capacity is  a 
Ätrademark  of living things as well as of human-made systems designed  to 
Äexplore  'artificial intelligence'.  No matter what your  ambitions  are: 
Äcomputed  instructions  offer  solid,   elegant,   and  sometimes  unique 
Äsolutions  for problems that span the range from particularly  boring  to 
Ähair  raising.  Among all dimensions opened by D,  this is one of  the 
Ämost exciting and most rewarding to explore. If your breathing space in the Äfourth dimension is collapsing, try this one!Ç|Ä 

ÇpÄDefining  a  problem in D involves developing a specific  vocabulary  of 
Äobjects,  and  in this sense a new language.  D may be paraphrased  asÑ  Åa 
Ålanguage to make languagesÄ.  Diversified vocabularies are one strength of 
Äthe D machine; a strong stomach is another. Almost never will you have to 
Äwrite  an  ad hoc interpreter of your new idiom,  because  the  secondary 
Älanguage code can go right through the existing D  mill. D code resembles 
Äthe vectors constructed by a molecular biologist: it achieves the desired 
Äproduct not by creating a new,  but by exploiting an existing,  machinery 
Äfor expression.Ç|
Ä  
ÇpÄD likely differs from most 'programming' techniques you have met.  There 
ÄisÅ no 'high-level' syntaxÄ to learn,  you learn  a minimal syntax and then 
Ämany  ÑverbsÄ  (operators).  You  can work through  these  by  installment, 
Äignoring what you do not need,  gearing up as you go, and winding down as 
Äyour project matures.  Re-learning is eased by the extreme consistency of 
Äform.  D code flows smoothly,  because there are few computer expletives; 
Äsyntactical  errors become a rare mishap.  Underneath its  easy  manners, 
Ähowever, the D machine hides a Laconian.Ç|

ÇpÄD isÅ robustÄ, because it is simple and because it works with objects that 
Äinclude a thorough specification.  Operators,  for example,  will  choose 
Äeither  to  adapt to their operand objects or to reject such  objects  as 
Änon-suitable  for  the  attempted  use  (this  summarizes  most  of   the 
Äsafeguards necessary to let the machine steer clear of crashes). An  able 
Ädefender of its own integrity, the machine abstains from questioning your 
Ädesigns in terms of selfish syntactical rules. Instead, D simply respects 
Äyou:  it  accepts  every  word that you present and  executes  this  word 
ÅverbatimÄ.  This  may  remind you of the ways of a fool,  but it  is  also 
Äreminiscent  of the method of Socrates:  the machine dares you to  follow 
Äthrough  what  you conceive.  You are rewarded by  solutions  that  work, 
Äconvince, and are delivered with egg-laying promptness.Ç|

Ä 


ÇcÅ1.2 Talking in ObjectsÇ|

ÇpÄThe widely used languages,  Fortran,  Basic,  C, or Pascal, use a multi-
Älevel syntax: tokens form expressions, expressions statements, statements 
Äfunctions,  and  functions  programs.  D  uses a syntax  of  objects  and 
Ärequires no rules of composition beyond those of constructing objects.Ç|

ÇpÄYou may wonder how D organizes objects into instructions.  A comparative 
Älook  at  phrases  in  C and D shows that the  method  of  D  is  simple, 
Äconsistent, and very generally useful.Ç|

Ç1 lsÄ Ç/tabs [[108 1] [ textwidth 108 sub 1 ] ] def

ÇnÄThe C statement:Ç| tÖy = 9.8 * exp(-x/tau);Ç| 1 ls

ÇnÄreads in D:Ç| tÖ/y 9.8x neg tau div exp mul defÇ|

ÇpÄThe  C code assigns the result of an algebraic expression to a  variable 
Äand neatly concludes the phrase with a semicolon.  The D code is an open-
Äended  string of objects.  Like you walk by putting one foot in front  of 
Äthe other,  the D machine computes by executing one object in the  string 
Äafter another:Ç|

Ç/paragraphindent -48 defÄ Ç/paragraphspace 20 def

ÇpÖ/yÄ -- pushes a name object of value 'y' onto the operand stack
Ä         (the '/' gives the name the ÑpassiveÄ attribute, designating
Ä          it for use as a literal)Ç| Ä 
ÇpÖ9.8Ä -- pushes  a  numeral  object of value '9.8' onto  the  operand  stack 
Ä       (thereby 'executing' the numeral)Ç|
ÇpÖxÄ -- looks up the object associated with the name 'x' (a numeral in  our 
Ä      case) and pushes a copy of it onto the operand stack (a name without  the 
Ä      '/' prefix receives the ÑactiveÄ attribute, designating it for use in 
Ä      a dictionary  search)Ç|
ÇpÖnegÄ -- looks up the object associated with the name 'neg',  which is an 
Ä         operator;  invokes the operator,  which negates the value of the 
Ä         top element of the operand stack (the copy of x)Ç| 
ÇpÖtauÄ -- pushes the object associated with 'tau' onto the operand stack  (you 
Ä         got the idea)Ç|
ÇpÖdivÄ -- divides the next-to-top element of the operand stack by the  top 
Ä         element, removes the divisor and divident from the stack, pushes 
Ä         the quotientÇ| 
ÇpÖexpÄ -- replaces the top element of the stack by its exponentialÇ| 1 ls
ÇpÖmulÄ -- multiplies  the  top two elements of the operand stack  (9.8 and 
Ä         exponential) by each other, replaces the factors by the productÇ| 
ÇpÖdefÄ -- this  name resolves to an essential operator,  which  associates 
Ä         the  object at the top of the stack (the numeral result  of  the 
Ä         expression) with the name ('y',  now the next-to-top element  of 
Ä         the stack), and places the new association pair into the current 
Ä         dictionary for future reference.Ç|

Ç/paragraphspace 30 def /paragraphindent 0 def

ÇpÄD  code  thus  builds  on operands and operators  held  together  by  an 
Äinvisible  glue,  the Ñreverse Polish notationÄ.  The rule is  minimal:  an 
Äoperator  expects that the operand stack contain a sufficient  number  of 
Äsuitable operands.  Beyond that, there are very few formal constraints on 
Äthe order or choice of objects that form a D script.Ç|

ÇpÄThe C code has the appeal of high-school algebra:  sort of  familiar.  D 
Äresorts  to  the more elegant and general  concept  of  operators.  Since 
Äelegance can be measured by the frugality of means,  let's count:  the  C 
Äexample needs twelve tokens,  two more than D; C uses six kinds of token, 
ÄD three. The advantage is on D, albeit small. We will note below that the 
Ädistance grows steeply even with mild increases of difficulty.  D travels 
Äon foot where C gets only with heavy gear.Ç|

ÇpÄThe C code in this example is shorter to type than the D  code,  because 
Äit  employs  special characters as shorthands.  Good  D  style  generally 
Äabstains  from  shorthand in order to keep things  clear  and  consistent 
Ä(shorthand  systems have a knack to befuddle their inventors).  You  will 
Äsee  below that D lets you spell out in full what is needed for  clarity, 
Äand nevertheless allows you to be more concise than in shorthand C code.Ç|

ÇpÄHaving  looked  at algebra,  we may ask:  how does D express  a  control 
Ästatement?  For  instance,  C implements a 'for' loop through  a  special 
Ägrammatical  construct called a 'for-statement'.  D builds a  'for'  loop 
Äthrough an operator and does so without grammatical ado.  Thus,  to  form 
Äthe sum of the integers between 0 and 100 by brute force,  you may writeÇ|Ä 
Ç1 ls

Ç/tabs [ [36 1][ textwidth 108 sub 1 ] [72 2]] def
ÇnÄIn C:Ç| tÖfor (k=sum=0; k<=100; k++)  sum += k;Ç| 1 ls

ÇnÄIn D:Ç| tÖ/sum 0   0 1 100 { add } for   defÇ|

ÇpÄThe  'sum'  is  defined  as the effect of the  'for'  operator  and  its 
Äoperands  (i.e.  0 1 100 { add } ) onto a value seeded on the  stack,  0. 
Ä'for'  executes  the loop body (the procedure,  { add } ) once  for  each 
Ävalue from the initial 0,  by steps of 1,  to the limit 100.  The current 
Äcount is passed to the procedure by pushing it on the operand stack.  The 
Äprocedure in our example contains a single operator,  'add',  which  adds 
Äthe current count to the running sum maintained on the stack.Ç|

ÇpÄThe C 'for' statement is compact,  as it bristles of shorthands.  Yet it 
Äneeds  20 tokens,  whereas the D statement has 11.  The C code uses  nine 
Ädifferent kinds of token, the D code, four.Ç|

ÇpÄTo prime an array x of n real numbers with zeroes you may writeÇ| 1 ls

ÇnÄIn C:Ç| tÖfor (k=0; k<n; k++) x[k] = 0.0;Ç| tÄ(20 tokens)Ç| 1 ls

ÇnÄIn D:Ç| tÖ0.0 x copy Ç| tÄ(3 tokens)Ç|

ÇpÄThere is no need not look for the champion here.  D uses an  intelligent 
Äoperator that determines automatically the dimension of the object it  is 
Äworking  with  and  controls  an internal  loop  accordingly.  In  the  C 
Äconstruct,  you are responsible for the count,  and an error in the limit 
Ävariable can cause a crash;  you also have to reckon with C's expletives, 
Äwhich please a compiler but hardly a programmer.Ç|

ÇpÄThis example raises the question of how fast the intelligent D operators 
Äexecute.  Obviously,  they  have to do a lot of object checking.  On  the 
Äother hand,  D operators absorb the innermost loop when working on  whole 
Äcomposite  objects  such  as arrays,  and then execute as  fast  as  host 
Ämachine  code.  Only small-grain number crunching will  be  significantly 
Äslower.  But does this really matter?  Science is change, and the economy 
Äof   instructing  a  computer  for  a  new  twist  of  science   precedes 
Äconsiderations regarding the speed of computation (consider:  programming 
Äcosts  ÅyourÄ prime time,  whereas execution ties up a computer  and,  when 
Änumerically extensive,  often can use 24 hours a day). Furthermore, after 
Äa routine has evolved,  it always can be speeded by replacing bottlenecks 
Äby fast ad hoc operators.  This still is by far less work than developing 
Äthe entire project in a language like C.Ç|

ÇpÄMoving up in syntax, let's cast the exponential expression from before as 
Äa  function,  such that x and tau are submitted and the expression  value 
Äreturned. In C, this reads:Ç|

Ç/tabs [ [36 1] [textwidth 36 72 add sub 1][ 72 2 ]] def 1 ls
ÇnÄIn C:Ç| tÖfloat myexp(tau,x)Ç| tÄ                          (27 tokens)Ç|
ÇnÄ Ç| tÖfloat tau,x;Ç|
ÇnÄ Ç| tÖ{Ç|
ÇnÄ Ç| tÖreturn(9.8 * exp(-x/tau));Ç|
ÇnÄ Ç| tÖ}Ç| 1 ls

ÇnÄIn D:Ç| tÖ/myexp { Ç| tÄ                                 (10 tokens)Ç|
ÇnÄ Ç| t Ödiv neg exp 9.8 mulÇ|
ÇnÄ Ç| tÖ } def Ç|

ÇpÄYou associate the name 'myexp' with a procedure,  whose body is  enclosed 
Äbetween {}.  When you enter this code,  the objects in the procedure body 
Äare not executed: they are translated into their internal form and stored 
Äfor later invokation (the D analog of 'compilation').Ç|

ÇpÄInvokations of this function/procedure could read:Ç| 1 ls
Ä       
ÇnÄIn C:Ç| tÖy = myexp(x,tau);Ç| 1 ls
ÇnÄIn D:Ç| tÖ/y x tau myexp defÇ|

ÇpÄBoth  languages provide the means for partitioning code  into  ràe-uÄsable 
Ätools  (functions in C,  procedures in D).  Both use a stack to  transfer 
Äarguments.  C  functions can take many arguments and return at  most  one 
Ävalue,  whereas  D procedures can return more than one value (since  they 
Äcommunicate their results through the stack).Ç|

ÇpÄAre things in C and D really that similar? They are not:Ç|

ÇpÄ- The C function takes exactly the kind of argument it is declared  for. 
ÄIt  produces  potentially fatal nonsense if fed other  numeral  types  of 
Äarguments (like 'short' instead of 'float').  Furthermore, it needs to be 
Äinvoked explicitly for each individual array element when the exponential 
Äof  an  array  is to be calculated.  The D function  (and  the  contained 
Äoperators)  adapt  to varying types of numeral,  and  they  automatically 
Äexpand the operations to all elements of array  arguments.  Generally,  D 
Äprocedures can take, work on, and return composite objects.Ç|

ÇpÄ-  The  compiled  C function is linked  into  a  program.  The  function 
Äthenceforth stays as is,  subserves the program,  and can be invoked only 
Äfrom  the  context of the program.  The  D  procedure,  in  contrast,  is 
Äassimilated as an individual object into the machine.  Any D code already 
Äpresent, passing through, or assimilated thereafter can use it or be used 
Äby it.  The gentleness of D in assimilating (procedure or other)  objects 
Ägoes an essential notch further than even an 'incremental compiler' would 
Ägo: the name-object associations are not finalized in the form of address 
Älinks.  Associations  remain a matter of make and break  (even  intrinsic 
Äoperators do not 'own' their names;  hence, there are no 'reserved words' 
Äin  D and, conversely, you can substitute or expand system operators by Äprocedures that you associate with the former operator names).  In  effect,  Äwhereas the elements of a C program are  rigid  and 
Äwelded together, those of a D process remain ductile and able to form new 
Äconnections.Ç|

ÇpÄAlthough  D  objects  can  assemble  ad  hoc  in  the   machine,   their 
Ärelationships are tightly controllable.  The method is encapsulation. The 
Äfollowing code invokes a procedure twice,  each time providing it with  a 
Ädifferent context by executing it with different current dictionaries:Ç| 1 
Çls


ÇnÄ Ç| tÖdict_A begin that_procedure endÇ|
ÇnÄ Ç| tÖdict_B begin that_procedure endÇ|

ÇpÑThat_procedureÄ  can retrieve objects from all dictionaries currently  on 
Äthe dictionary stack.  If it defines or re-defines objects in the  course 
Äof  its execution,  these changes are made exclusively in the  dictionary 
Äplaced  on  top of the dictionary stack through the ÑbeginÄ  operator  (and 
Älater removed by Ñend)Ä;  this holds true for the entire dynamic context of 
Ñthat_procedureÄ.  The current dictionary, hence, provides a semi-permeable 
Äcapsule around the procedure.  The invoking program can put objects to be 
Äused  by the procedure into the capsule,  read results deposited  in  the 
Äcapsule,  or  may  leave  the capsule alone as a  private  space  of  the 
Äprocedure.  Since any number of capsules can be maintained, the procedure 
Äcan be used randomly in varying contexts without a risk of confusion.Ç|Ä 

ÇpÄEncapsulation is a responsibility of the caller. This greatly simplifies 
Äthe  writing of procedures,  because no attention needs be given  to  the 
Äscope  of  their object names:  you can write along as if  there  was  no 
Äpossibility  of  interference  with other code.  This  technique  is  the 
Äopposite  to C's approach to control access,  where the lexical scope  is 
Ädetermined by declarations contained in each function.  The encapsulation 
Ätechnique is used by operating systems, to isolate the system itself from 
Äuser  processes and one user process from another.  It is the  method  of 
Ächoice in all systems that do not Ña prioriÄ restrict the players.Ç|

ÇpÄD  extends encapsulation to the flow of control.  You can  execute  code 
Äwith  the  provision that control can return immediately to  the  calling 
Äcode,  cutting through a nest of pending procedures or loops. Consider as 
Äan example:Ç| 1 ls

ÇnÄ Ç| tÖ{ my_program } stopped Ç|

ÇpÄThe  ÑstoppedÄ operator invokes the procedure operand,  which  contains  a 
Äreference  to a user program.  If Ñmy_programÄ executes the  ÑstopÄ  operator 
Äupon  recognizing a severe problem anywhere within its  dynamic  context, 
Äexecution resumes with the object following ÑstoppedÄ (a boolean object  is 
Äreturned  on  the operand stack to inform the caller about  the  kind  of 
Ätermination).  D provides a hierarchy of such escape mechanisms by  which 
Äunpredicted events trigger orderly retreats to prepared  positions.  Most 
Äprocedures can be written on the assumption that things go well,  because 
Äsurprises are passed from their discoverer straight to the supervisor  of 
Äthe  context  rather than bubbling back through a chain  of  command  and 
Ärequiring attention at every intermediate level.Ç|

ÇpÄWe now turn to composite objects.  Such objects (and nests thereof)  are 
Änot  declared like a C function or structure.  D operators let you  ÑbuildÄ 
Äsuch  objects  from  constituent  objects,   or,  conversely,  ÑdissectÄ  a 
Äcomposite  object  into smaller entities for specific  uses.  D  objects, 
Ähence, are inherently dynamic.Ç|

ÇpÄThe following examples produce some composite objects:Ç| 1 ls


ÇnÄ1:Ç| tÖ100 (w) arrayÇ| 
ÇnÄ2:Ç| tÖ(This is a string)Ç|
ÇnÄ3:Ç| tÖ<s 120. 40. 28. 1e5 29.546 1 -99>Ç|
ÇnÄ4:Ç| tÖ[ a b 100 (HOHOHO) ]Ç|
ÇnÄ5:Ç| tÖ12 dict  13 listÇ|
ÇnÄ6:Ç| tÖ{ (\nHonni soit qui mal y pense) toconsole }Ç|

ÇpÄThe objects are:  (1) an array of 100 16-bit integers holding unpredictable Äinitial values;  (2)  an  initialized string  (i.e.  array  of  byte 
Äintegers);  (3)  an initialized array of single-precision  floating-point 
Änumbers;  (4)  a  list of the objects included between  brackets;  (5)  a 
Ävirgin  dictionary  for  up to 12  associations,  and  a  list  initially 
Äcontaining 13 null objects;  (6) a procedure that when executed writes  a 
Äbonmot on the console screen.  The composite objects 
Äthus created populate the top 7 positions of the operand stack.Ç|

ÇpÄComposite  D objects include arrays (a set of numeral values that  share 
Äthe  same  characteristics),  and  lists (a set  of  arbitrary  objects). 
ÄLists and arrays can be created in a fashion that defines all elements of 
Ätheir value,  or with initially undefined or null elements.  Elements  of 
Äthese objects are accessed through an index. Alternatively, a composite D 
Äobject  is  built  in the form of a dictionary,  where  each  element  is 
Äassociated with a name for reference.  Dictionaries are created empty and 
Äare filled explicitly by subsequent operations.Ç|

ÇpÄAs  an example of composite object dynamics in D,  consider a family  of 
Ärecorded current sweeps from a voltage clamp experiment.  A subsection of 
Äeach  sweep  represents a 'tail' current.  Assume that in one  sweep  the 
Äblock of 200 samples that starts at index 1750 contains the tail current. 
ÄTo make a new object from this block, useÇ| 1 ls

ÇnÄ Ç| tÖ/tail sweep 1750 200 getinterval defÇ|

ÇpÄThe  'getinterval' operator creates a new array object  that  represents 
Äthe specified subset of the values contained in the array associated with 
Ä'sweep'; we associate the subset object with 'tail'.Ç| 

ÇpÄTail  current  objects thus created are grouped together into  a  family 
Äobject by:Ç| 1 ls

ÇnÄ Ç| tÖ/tailfamily [ tail .. ] defÇ|

ÇpÄThe  family  then may be submitted as an entity to analysis  or  picture 
Ätaking.  Note  that  tail  currents need not occupy the  same  subset  of 
Äsamples  in  each  sweep:  they can start anywhere and  be  of  arbitrary 
Älengths, because the objects formed about them automatically inherit this 
Äinformation  and  carry it on to operators,  which will use it  to  focus 
Ätheir effects. These objects and their list form a new and more specific 
Äsystem of reference for your data.Ç|

ÇpÄOn another occasion, you have received, on a floppy sent by a colleague, 
Äan alphanumerical list consisting of one-column tables of floating  point 
Änumbers.  You  want to submit this material to an analysis that you  have 
Ädeveloped on your D machine.  All you need to do is use the text editor
Ä(that is built into the virtual console of the D machine) to put 'vectors'
ÄlikeÇ| 1 ls

ÇnÄ Ç| tÖ/RateConstants <s ... > defÇ|

ÇpÄaround the tables that you wish to package.  Then,  back from the editor, 
Äyou demandÇ| 1 ls

ÇnÄ Ç| tÖ(that_textfile) fromfilesÇ|

ÇpÄto transform these data into named arrays, which you can refer to as you 
Ädo with your own data.  ÑfromfilesÄ,  by the way, is not an operator, but a 
Äremarkably simple D procedure. This and other generally useful procedures 
Äare part of an environment created when a D machine is 'booted'.Ç|

ÇpÄLet's  step  back  and re-consider what happened  here.  We  invented  a 
Änotation to present data to the computer,  a language so to  speak.  That 
Älanguage happens to be D. By this trick, we assimilated the data into the 
Ämachine   without  having  written  a  single  line  of   classical   I/O 
Äinstructions.   The  technique  is  attractive  because  the  grammatical 
Äoverhead of D is so small.Ç|Ä 

ÇpÄNow,  assume  that  these  data came in non-standard  units  related  to 
Äphysical  quirks  of  the  colleague's  recording  apparatus.   For   re-
Äcalibration,  you include, after the data and in the same text file, some 
ÄD  code  that  transforms  the raw arrays  into  the  proper  units,  for 
Äexample:Ç| 1 ls

ÇnÄ Ç| tÖ[ array_name .. ] { 1.745e-6 mul pop } forallÇ|

ÇpÄThe  'forall' operator applies the calibration procedure to  all  arrays 
Äwhose  names  are included in the list (enclosed  between  []),  and  the 
Ämultiplication  operator  in the procedure scales all  elements  of  each 
Äarray (evidently, D is not verbose).Ç|

ÇpÄWhenever  you  will  go back to this data file,  you  will  get  properly 
Äcalibrated  data  without  sacrificing the original or  losing  track  of 
Äyour additional calibrations.  With minimal ado,  you have converted this 
Ädata set into something that takes care of itself:  an object  comprising 
Äboth 'data' and 'instruction', self-calibrating data, so to speak.Ç|

ÇpÄA natural form of organizing larger collections of objects is the  ÅtreeÄ. 
ÄA  tree  starts  from a dictionary or list that  holds  simple  or  other 
Äcomposite objects;  these composite objects,  again,  can hold  composite 
Äobjects, and so on to any level of nesting. Since trees are a very useful 
Äform  of organizing objects,  D provides operators to move  entire  trees 
Äamong media. For instance,Ç| 1 ls

ÇnÄ Ç| tÖSolutionBook OptDisk toboxÇ|
ÇnÄ Ç| tÖOptDiskProtocols /SolutionBookputÇ|

ÇpÄputs the tree that starts with the list ÑSolutionBookÄ into a  ÅboxÄ 
Äobject  and  stores  that  object  on  the  medium  associated  with  the 
Äidentifier OptDisk. This listcontainsa collection of all solution Ädescriptionsever used in your lab, probably in the form of one dictionary per Äsolution; each dictionary has a number of standardized entries, including lists Äof stock solution names, their indices in the book, and pipetted Ävolumes.Altogether, 
Ämoving this whole structure piecewise would be very cumbersome, and moving only Ächanged or added pieces would be error prone. The ÑtoboxÄ operator performs this Älarge job in one safe sweep and returns the new box object, which 
Äis included into the dictionary ÑOptDiskProtocolsÄ for later  reference.  In 
Äorder to load this tree into internal VM during a later session,  useÇ|  1 
Çls

ÇnÄ Ç| tÖOptDiskProtocols /SolutionBookget fromboxÇ|
ÇnÄ Ç| tÖuserdict /SolutionBook putÇ|

ÇpÄThis retrieves the box object from the dictionary ÑOptDiskProtocolsÄ, loads 
Äthe  tree  contained  in the box into internal  VM,  returning  the  root 
Älist of the solutionbook tree,  and places a reference to that  object 
Äinto the user dictionary (the root dictionary of the D machine). You now can Älook up individual solutions or add new entries to the book.Ç|

ÇpÄA  procedure (provided in a general tool  library),  ÑtofileÄs,  lets  you 
Ätranslate  a tree into its text equivalent and save that text in a  file. 
ÄThe  converse procedure,  ÑfromfilesÄ,  executes the D code contained in  a 
Ätext file and thus creates in the internal VM all objects that are defined 
Äin  a  text  file.  You can use ÑtofileÄs to prepare a  file  containing  a 
Äcollection  of D objects that you wish to submit in toto to a  PostScript 
Ämachine for printing or plotting. Thus, objects organized as trees can be 
Ämoved and converted efficiently with a few simple operators.Ç|

ÇpÄIn  the  recent  examples,  no equivalent C phrases  have  been  listed, 
Äbecause  C  lacks  the intrinsic means to hold  its  ground.  The  means, 
Äthough,  can be created in C, by composing a virtual D machine. This explains Ähow D came into existence - and to a name.Ç|

ÇpÄThis concludes our intuitive view of D. The following chapters will give 
Äa full reference of the machine model and operators.  The best way to 
Älearn D,  as always,  is by example.  The D machine comes with a stock of 
Äuseful D objects in text files. These implement basic utilities that you likely Äwill use in most work on the D machine. They include operator-like extensions ofÄ the D machine in the form of procedure libraries, a mouse-operated universal Äbrowser that lets you inspect and select any information organized by the D Ämachine (called 'the eye'), and a menu-driven toolbox for editing, file Ähandling, printing etc. (called 'the hand'). These use many of the capacities Äthat set D apart from other language models, and thus may serve you also as a Ägrab bag of useful bits and pieces.Ç| 

