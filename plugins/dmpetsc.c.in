#line 2 "./dmpetsc.c.in"
#include <petscksp.h>

#include <limits.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#include "dm.h"

enum AssState {
  ASSEMBLED,
  ASSEMBLING,
  ASSEMBLE_WRITE
};

#define ASS_STATE(frame)     (*(enum AssState*) NUM_VAL(frame))
#define VECTOR_VAL(frame)    (*(Vec*) NUM_VAL(frame))
#define MATRIX_VAL(frame)    (*(Mat*) NUM_VAL(frame))
#define KSP_VAL(frame)       (*(KSP*) NUM_VAL(frame))
#define ULONG64_VAL(frame)   (*(UL64*) &LONG64_VAL(frame))

#include "dm-dmpetsc-header.h"

static PetscErrorCode petscsig(int sig __attribute__ ((__unused__)), 
			       void* ptr __attribute__ ((__unused__)) ) {
  return PETSC_ERR_SIG;
}

static P errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_INDEFINITE_MAT) + 1];

DM_INLINE_STATIC P init_(void) {
  PetscErrorCode r;

  if (setenv("PETSC_DIR", "@PETSC_DIR@", 1))
    return -errno;
  if (setenv("PETSC_ARCH", "@PETSC_ARCH@", 1))
    return -errno;

  errmap[0] = OK;
  errmap[PETSC_ERR_MEM] = DMPETSC_ERR_MEM;
  errmap[PETSC_ERR_SUP] = DMPETSC_ERR_SUP;
  errmap[PETSC_ERR_SUP_SYS] = DMPETSC_ERR_SUP_SYS;
  errmap[PETSC_ERR_ORDER] = DMPETSC_ERR_ORDER;
  errmap[PETSC_ERR_SIG] = DMPETSC_ERR_SIG;
  errmap[PETSC_ERR_FP] = DMPETSC_ERR_FP;
  errmap[PETSC_ERR_COR] = DMPETSC_ERR_COR;
  errmap[PETSC_ERR_LIB] = DMPETSC_ERR_LIB;
  errmap[PETSC_ERR_PLIB] = DMPETSC_ERR_PLIB;
  errmap[PETSC_ERR_MEMC] = DMPETSC_ERR_MEMC;
  errmap[PETSC_ERR_CONV_FAILED] = DMPETSC_ERR_CONV_FAILED;
  errmap[PETSC_ERR_USER] = DMPETSC_ERR_USER;
  errmap[PETSC_ERR_ARG_SIZ] = DMPETSC_ERR_ARG_SIZ;
  errmap[PETSC_ERR_ARG_IDN] = DMPETSC_ERR_ARG_IDN;
  errmap[PETSC_ERR_ARG_WRONG] = DMPETSC_ERR_ARG_WRONG;
  errmap[PETSC_ERR_ARG_CORRUPT] = DMPETSC_ERR_ARG_CORRUPT;
  errmap[PETSC_ERR_ARG_OUTOFRANGE] = DMPETSC_ERR_ARG_OUTOFRANGE;
  errmap[PETSC_ERR_ARG_BADPTR] = DMPETSC_ERR_ARG_BADPTR;
  errmap[PETSC_ERR_ARG_NOTSAMETYPE] = DMPETSC_ERR_ARG_NOTSAMETYPE;
  errmap[PETSC_ERR_ARG_NOTSAMECOMM] = DMPETSC_ERR_ARG_NOTSAMECOMM;
  errmap[PETSC_ERR_ARG_WRONGSTATE] = DMPETSC_ERR_ARG_WRONGSTATE;
  errmap[PETSC_ERR_ARG_INCOMP] = DMPETSC_ERR_ARG_INCOMP;
  errmap[PETSC_ERR_ARG_NULL] = DMPETSC_ERR_ARG_NULL;
  errmap[PETSC_ERR_ARG_UNKNOWN_TYPE] = DMPETSC_ERR_ARG_UNKNOWN_TYPE;
  errmap[PETSC_ERR_ARG_DOMAIN] = DMPETSC_ERR_ARG_DOMAIN;
  errmap[PETSC_ERR_FILE_OPEN] = DMPETSC_ERR_FILE_OPEN;
  errmap[PETSC_ERR_FILE_READ] = DMPETSC_ERR_FILE_READ;
  errmap[PETSC_ERR_FILE_WRITE] = DMPETSC_ERR_FILE_WRITE;
  errmap[PETSC_ERR_FILE_UNEXPECTED] = DMPETSC_ERR_FILE_UNEXPECTED;
  errmap[PETSC_ERR_MAT_LU_ZRPVT] = DMPETSC_ERR_MAT_LU_ZRPVT;
  errmap[PETSC_ERR_MAT_CH_ZRPVT] = DMPETSC_ERR_MAT_CH_ZRPVT;

  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_NULL)] 
    = DMPETSC_DIVERGED_NULL;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_ITS)] 
    = DMPETSC_DIVERGED_ITS;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_DTOL)] 
    = DMPETSC_DIVERGED_DTOL;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_BREAKDOWN)] 
    = DMPETSC_DIVERGED_BREAKDOWN;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_BREAKDOWN_BICG)] 
    = DMPETSC_DIVERGED_BREAKDOWN_BICG;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_NONSYMMETRIC)] 
    = DMPETSC_DIVERGED_NONSYMMETRIC;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_INDEFINITE_PC)] 
    = DMPETSC_DIVERGED_INDEFINITE_PC;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_NAN)] 
    = DMPETSC_DIVERGED_NAN;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_INDEFINITE_MAT)] 
    = DMPETSC_DIVERGED_INDEFINITE_MAT;

  if ((r = PetscInitialize(PETSC_NULL, PETSC_NULL, PETSC_NULL, PETSC_NULL)))
    RETURN_ERROR(errmap[r]);

  if ((r = PetscPushSignalHandler(petscsig, NULL)))
    RETURN_ERROR(errmap[r]);

  return OK;
}

DM_INLINE_STATIC P fini_(void) {
  PetscErrorCode r;
  if ((r = PetscPopSignalHandler()))
    RETURN_ERROR(errmap[r]);
  
  return OK;
}

DM_INLINE_STATIC P INIT_VEC_(B* frame, Vec* x) {
  BOOLEAN* t;
  PetscErrorCode r;

  TEST_DMPETSC_VECTOR(frame);
  if (! (*x = DMPETSC_VECTOR_VECTOR(frame))) 
    RETURN_ERROR(DMPETSC_INVVEC);

  if (! *(t = &DMPETSC_VECTOR_ASS(frame))) {
    if ((r = VecAssemblyEnd(*x))) RETURN_ERROR(errmap[r]);
    *t = TRUE;
  }

  return OK;
}

#define INIT_VEC(frame, x) do {						\
    P retc = INIT_VEC_(frame, &x);					\
    if (retc) return retc;						\
  } while (0)

DM_INLINE_STATIC P INIT_MAT_(B* frame, Mat* A, enum AssState** t) {
  TEST_DMPETSC_MATRIX(frame);
  if (! (*A = DMPETSC_MATRIX_MATRIX(frame))) 
    RETURN_ERROR(DMPETSC_INVMAT);

  if (t) *t = &DMPETSC_MATRIX_ASS(frame);
  
  return OK;
}

DM_INLINE_STATIC P INIT_MAT_ASS_(Mat A, enum AssState* t) {
  PetscErrorCode r;

  switch (*t) {
    case ASSEMBLE_WRITE:
      if ((r = MatAssemblyBegin(A, MAT_FINAL_ASSEMBLY)))
	RETURN_ERROR(errmap[r]);
      //and fall through
    case ASSEMBLING: 
      if ((r = MatAssemblyEnd(A, MAT_FINAL_ASSEMBLY)))
	RETURN_ERROR(errmap[r]);
      *t = ASSEMBLED;
      break;
    default: break;//do nothing if assembled
  }
  
  return OK;
}

DM_INLINE_STATIC P INIT_MAT_WRITE_(Mat A, enum AssState* t) {
  PetscErrorCode r;

  switch (*t) {
    case ASSEMBLE_WRITE: break;
    case ASSEMBLING: 
      if ((r = MatAssemblyEnd(A, MAT_FINAL_ASSEMBLY)))
	RETURN_ERROR(errmap[r]);
      //fall through
    default:
      *t = ASSEMBLE_WRITE;
      break;
  }
  
  return OK;
}

DM_INLINE_STATIC P INIT_MAT_WRITEEND_(Mat A, enum AssState* t) {
  PetscErrorCode r;

  if (*t == ASSEMBLE_WRITE) { 
    if ((r = MatAssemblyBegin(A, MAT_FINAL_ASSEMBLY)))
      RETURN_ERROR(errmap[r]);
    *t = ASSEMBLING;
  }

  return OK;
}


#define INIT_MAT(frame, A) do {						\
    P retc;								\
    enum AssState* t;							\
    if ((retc = INIT_MAT_(frame, &A, &t))				\
	|| (retc = INIT_MAT_ASS_(A, t)))				\
      return retc;							\
  } while (0)


#define INIT_MAT_WRITE(frame, A) do {					\
    P retc;								\
    enum AssState* t;							\
    if ((retc = INIT_MAT_(frame, &A, &t))				\
	|| (retc = INIT_MAT_WRITE_(A, t)))				\
      return retc;							\
  } while (0)

#define INIT_MAT_WRITEEND(frame, A) do {				\
    P retc;								\
    enum AssState* t;							\
    if ((retc = INIT_MAT_(frame, &A, &t))				\
	|| (retc = INIT_MAT_WRITEEND_(A, t)))				\
      return retc;							\
  } while (0)

DM_INLINE_STATIC P INIT_KSP_(B* frame, KSP* ksp) {
  TEST_DMPETSC_KSP(frame);
  if (! (*ksp = DMPETSC_KSP_KSP(frame)))
    RETURN_ERROR(DMPETSC_INVKSP);
  return OK;
}

#define INIT_KSP(frame, ksp) do {		\
    P retc = INIT_KSP_(frame, &ksp);		\
    if (retc) return retc;			\
  } while (0)

#define DMPETSC_ERRCHECK(func) do {					\
    PetscErrorCode r;							\
    if ((r = func)) RETURN_ERROR(errmap[r]);				\
  } while (0)


//------------------------ petsc_vector_create
// n | vec-handle
// n is the size of the local portion of the vector.
// the total size is n1+n2... over all mpi processes
//
DM_INLINE_STATIC P petsc_vec_create(void) {
  PetscErrorCode r;
  P n;
  B* pframe;
  B* oldfreevm = FREEvm;
  Vec* x = NULL;
  PetscInt gn;

  if (o_1 < FLOORopds) return OPDS_UNF;
  if (CLASS(o_1) != NUM) return OPD_CLA;
  if (! PVALUE(o_1, &n)) return UNDF_VAL;

  MAKE_DMPETSC_VECTOR(pframe);
  *(x = &DMPETSC_VECTOR_VECTOR(pframe)) = NULL;
  DMPETSC_VECTOR_N(pframe) = n;
  DMPETSC_VECTOR_ASS(pframe) = FALSE;

  if ((r = VecCreateMPI(PETSC_COMM_WORLD, n, PETSC_DECIDE, x))) goto err;
  if ((r = VecGetOwnershipRange(*x, &gn, PETSC_NULL))) goto err;
  DMPETSC_VECTOR_GN(pframe) = gn;
  if ((r = VecAssemblyBegin(*x))) goto err;

  moveframe(pframe, o_1);
  return OK;

 err:
  if (x && *x) VecDestroy(*x);
  FREEvm = oldfreevm;
  RETURN_ERROR(errmap[r]);
}

// v1 v2 | v2
DM_INLINE_STATIC P petsc_vec_copy(void) {
  Vec x, y;
  
  if (o_2 > FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, y);
  INIT_VEC(o_2, x);
  if (DMPETSC_VECTOR_N(o_1) != DMPETSC_VECTOR_N(o_2)) return RNG_CHK;
  
  DMPETSC_ERRCHECK(VecCopy(x, y));
  
  moveframe(o_1, o_2);
  FREEopds = o_1;
  return OK;
}

// v | v
DM_INLINE_STATIC P petsc_vec_syncto(void) {
  Vec x;

  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, x);

  DMPETSC_ERRCHECK(VecAssemblyBegin(x));
  DMPETSC_VECTOR_ASS(o_1) = FALSE;

  return OK;
}

// <d > n v | v
DM_INLINE_STATIC P petsc_vec_copyto(void) {
  Vec x;
  P n, len_arr, len_x;
  PetscInt* ix;
  P i;
  L32 gn;
  
  if (o_3 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, x);
  if (CLASS(o_2) != NUM) return OPD_CLA;
  if (! PVALUE(o_2, &n)) return UNDF_VAL;
  if (TAG(o_3) != (ARRAY|DOUBLETYPE)) return OPD_ERR;

  len_x = DMPETSC_VECTOR_N(o_1);
  gn = DMPETSC_VECTOR_GN(o_1);
  len_arr = ARRAY_SIZE(o_3);
  if (n < 0 || n+len_arr > len_x) return RNG_CHK;
  if (FREEvm + len_arr*sizeof(PetscInt) > CEILvm) return VM_OVF;
  ix = (PetscInt*) FREEvm;
  for (i = 0; i < len_arr; ++i) ix[i] = gn + n + i;

  DMPETSC_ERRCHECK(VecSetValues(x, len_arr, ix, 
				(D*) VALUE_PTR(o_3), INSERT_VALUES));
  DMPETSC_ERRCHECK(VecAssemblyBegin(x));
  DMPETSC_VECTOR_ASS(o_1) = FALSE;
  
  moveframe(o_1, o_3);
  FREEopds = o_2;
  return OK;
}

// v | v
DM_INLINE_STATIC P petsc_vec_syncfrom(void) {
  Vec x;
  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, x);

  return OK;
}

// v n <d > | <d sub-array>
DM_INLINE_STATIC P petsc_vec_copyfrom(void) {
  Vec x;
  P n, len_arr, len_x, ncols;
  D* a = NULL;

  if (o_3 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_3, x);
  if (CLASS(o_2) != NUM) return OPD_CLA;
  if (! PVALUE(o_2, &n)) return UNDF_VAL;
  if (TAG(o_1) != (ARRAY|DOUBLETYPE)) return OPD_ERR;

  len_x = DMPETSC_VECTOR_N(o_3);
  len_arr = ARRAY_SIZE(o_1);
  if (n < 0 || n >= len_x) return RNG_CHK;
  
  ncols = (len_arr > len_x - n) ? len_x - n : len_arr;
  DMPETSC_ERRCHECK(VecGetArray(x, &a));
  moveD(a+n, (D*) VALUE_PTR(o_1), ncols);
  DMPETSC_ERRCHECK(VecRestoreArray(x, PETSC_NULL));

  moveframe(o_1, o_3);
  ARRAY_SIZE(o_3) = ncols;
  ATTR(o_3) &= ~PARENT;
  FREEopds = o_2;
  return OK;
}

// vec-handle | max(v)
DM_INLINE_STATIC P petsc_vec_max(void) {
  Vec x;
  D v;
  PetscInt p;

  if (FLOORopds > o_1) return OPDS_UNF;
  INIT_VEC(o_1, x);
  DMPETSC_ERRCHECK(VecMax(x, &p, &v));

  TAG(o_1) = (NUM|DOUBLETYPE);
  ATTR(o_1) = 0;
  *(D*)NUM_VAL(o_1) = v;
  return OK;
}

// vec-handle | min(v)
DM_INLINE_STATIC P petsc_vec_min(void) {
  Vec x;
  D v;
  PetscInt p;

  if (FLOORopds > o_1) return OPDS_UNF;
  INIT_VEC(o_1, x);
  DMPETSC_ERRCHECK(VecMin(x, &p, &v));

  TAG(o_1) = (NUM|DOUBLETYPE);
  ATTR(o_1) = 0;
  *(D*)NUM_VAL(o_1) = v;
  return OK;
}
  
// vec-handle | --
DM_INLINE_STATIC P petsc_vec_destroy(void) {
  Vec x;

  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, x);

  DMPETSC_ERRCHECK(VecDestroy(x));
  DMPETSC_VECTOR_VECTOR(o_1) = NULL;

  KILL_OPAQUE();
  return OK;
}

static UL64 dupid = 1;

typedef P (*PreassFunc)(B* pframe, void* arg);
typedef P (*MatCopytoFunc)(Mat A, P grow, D* row, L32 ncols);
typedef P (*MatGetrowFunc)(Mat A, L32* ncols, L32 growi);

DM_INLINE_STATIC P petsc_mat_dense_copyto(Mat A, P grow, 
					  D* restrict row, L32 ncols) {
  const PetscInt idxm[] = {grow};
  PetscInt* const idxn = (PetscInt*) (row + ncols);
  PetscInt* c;
  PetscInt i;

  if ((B*) idxn >= CEILvm) return VM_OVF;
  for (c = idxn, i = 0; c < idxn+ncols; c++, i++) *c = i;
    
  DMPETSC_ERRCHECK(MatSetValues(A, 1, idxm, ncols, idxn, row, 
				INSERT_VALUES));

  return OK;
}

DM_INLINE_STATIC P petsc_mat_sparse_copyto(
  Mat A, P grow, D* restrict row, 
  L32 ncols __attribute__ ((__unused__)) ) 
{
  DMPETSC_ERRCHECK(MatSetValuesRow(A, grow, row));
  return OK;
}

DM_INLINE_STATIC P petsc_mat_getrow(Mat A, L32* ncols, L32 gm) {
  const D* data;
  DMPETSC_ERRCHECK(MatGetRow(A, gm, ncols, PETSC_NULL, &data));
  if (FREEvm + sizeof(D)*(*ncols) > CEILvm) {
    MatRestoreRow(A, gm, ncols, PETSC_NULL, &data);
    return VM_OVF;
  }
  moveD((D*) data, (D*) FREEvm, *ncols);
  DMPETSC_ERRCHECK(MatRestoreRow(A, gm, ncols, PETSC_NULL, &data));

  return OK;
}

DM_INLINE_STATIC P petsc_mat_getvalues(Mat A, L32* ncols, L32 gm) {
  PetscInt* idxn;
  L32 i;
  DMPETSC_ERRCHECK(MatGetSize(A, PETSC_NULL, ncols));
  if ((idxn = (PetscInt*) (((D*)FREEvm) + *ncols)) + *ncols
      >= (PetscInt*) CEILvm)
    return VM_OVF;

  for (i = 0; i < *ncols; ++i) idxn[i] = i;
  DMPETSC_ERRCHECK(MatGetValues(A, 1, &gm, *ncols, idxn, (D*) FREEvm));

  return OK;
}

struct SparsePreass {
  L32* irows;
  L32* icols;
};
  
DM_INLINE_STATIC P petsc_mat_sparse_preass(B* restrict pframe, 
					   void* restrict arg) {
  PetscErrorCode r;
  Mat A = DMPETSC_MATRIX_MATRIX(pframe);
  struct SparsePreass *const params = (struct SparsePreass*) arg;

  if ((r = MatSetOption(A, MAT_DO_NOT_USE_INODES)))
    RETURN_ERROR(errmap[r]);

  if ((r = MatMPIAIJSetPreallocationCSR(A, params->irows, params->icols, 
					PETSC_NULL))) 
    RETURN_ERROR(errmap[r]);

  return OK;
}

struct BlockDensePreass {
  PetscInt bs;
  PetscInt nb;
  PetscInt Nb;
};

DM_INLINE_STATIC 
P petsc_mat_blockdense_preass(B* restrict pframe, void* restrict arg) {
  PetscErrorCode r;
  struct BlockDensePreass* params = (struct BlockDensePreass*) arg;
  
  Mat A = DMPETSC_MATRIX_MATRIX(pframe);
  if ((r = MatMPIBAIJSetPreallocation(A, params->bs, 
				      params->nb, PETSC_NULL,
				      params->Nb, PETSC_NULL)))
    RETURN_ERROR(errmap[r]);

  return OK;
}

// these are the types/indexes.
enum DMMatrixType {
  DENSETYPE = 0,
  SPARSETYPE = 1,
  BLOCKDENSETYPE = 2
};

static const struct {
  char* type;
  PreassFunc preass;
  MatCopytoFunc copyto;
  MatGetrowFunc getrow;
} matType[] = {
  {
    MATMPIDENSE,
    NULL,
    petsc_mat_dense_copyto,
    petsc_mat_getrow,
  },
  {
    MATMPIAIJ,
    petsc_mat_sparse_preass,
    petsc_mat_sparse_copyto,
    petsc_mat_getrow,
  },
  {
    MATMPIBAIJ,
    petsc_mat_blockdense_preass,
    petsc_mat_dense_copyto,
    petsc_mat_getvalues,
  },
};

DM_INLINE_STATIC P mat_create(P m, P n, enum DMMatrixType mtype, 
			      B* restrict rpframe, void* restrict arg) {
  B* pframe;
  PetscErrorCode r;
  P retc = OK;
  B* oldfreevm = FREEvm;
  Mat* A = NULL;
  char* type = matType[mtype].type;
  PreassFunc preass = matType[mtype].preass;

  if (! dupid) RETURN_ERROR(DMPETSC_MATOVF);

  MAKE_DMPETSC_MATRIX(pframe);
  *(A = &DMPETSC_MATRIX_MATRIX(pframe)) = NULL;
  DMPETSC_MATRIX_M(pframe) = m;
  DMPETSC_MATRIX_N(pframe) = n;
  DMPETSC_MATRIX_DUPID(pframe) = dupid++;
  DMPETSC_MATRIX_MTYPE(pframe) = mtype;

  if ((r = MatCreate(PETSC_COMM_WORLD, A))) 
    goto err;
  if ((r = MatSetSizes(*A, m, n, PETSC_DETERMINE, PETSC_DETERMINE))) 
    goto err;
  if ((r = MatSetType(*A, type))) 
    goto err;
  if ((r = MatGetOwnershipRange(*A, &DMPETSC_MATRIX_GM(pframe), PETSC_NULL)))
    goto err;
  
  if (preass && (retc = preass(pframe, arg)))
    goto err;

  if ((r = MatSetOption(*A, MAT_ROWS_SORTED)))
    goto err;
  if ((r = MatSetOption(*A, MAT_COLUMNS_SORTED)))
    goto err;
  if ((r = MatSetOption(*A, MAT_NO_NEW_NONZERO_LOCATIONS)))
    goto err;

  DMPETSC_MATRIX_ASS(pframe) = ASSEMBLING;
  if ((r = MatAssemblyBegin(*A, MAT_FINAL_ASSEMBLY)))
    goto err;

  moveframe(pframe, rpframe);
  return OK;

 err:
  if (A && *A) MatDestroy(*A);
  FREEvm = oldfreevm;
  if (retc) return retc;
  RETURN_ERROR(errmap[r]);
}

// m n | mat
DM_INLINE_STATIC P petsc_mat_dense_create(void) {
  static B pframe[FRAMEBYTES];
  P retc;
  P m, n;

  if (FLOORopds > o_2) return OPDS_UNF;
  if (CLASS(o_2) != NUM || CLASS(o_1) != NUM) 
    return RNG_CHK;
  if (! PVALUE(o_2, &m) || m > L32MAX
      || ! PVALUE(o_1, &n) || n > L32MAX) 
    return UNDF_VAL;
  if (m < 1 || n < 1)
    return RNG_CHK;

  if ((retc = mat_create(m, n, DENSETYPE, pframe, NULL)))
    return retc;

  moveframe(pframe, o_2);
  FREEopds = o_1;
  return OK;
}

// <l irows> <l icols> n | mat
DM_INLINE_STATIC P petsc_mat_sparse_create(void) {
  static B pframe[FRAMEBYTES];
  P retc;
  P m, n;
  struct SparsePreass params;

  if (FLOORopds > o_3) return OPDS_UNF;
  if (TAG(o_3) != (ARRAY|LONG32TYPE) || TAG(o_2) != (ARRAY|LONG32TYPE))
    return OPD_ERR;
  if ((m = ARRAY_SIZE(o_3)-1) < 1) return RNG_CHK;
  if (! PVALUE(o_1, &n)) return UNDF_VAL;
  if (n > L32MAX || n < 1 || m > L32MAX) return RNG_CHK;

  params.irows = (L32*) VALUE_PTR(o_3);
  params.icols = (L32*) VALUE_PTR(o_2);
  if ((retc = mat_create(m, n, SPARSETYPE, pframe, &params)))
    return retc;

  moveframe(pframe, o_3);
  FREEopds = o_2;
  return OK;
}

// Stein's algorithm or binary gcd algorithm
// http://www.nist.gov/dads/HTML/binaryGCD.html
DM_INLINE_STATIC P gcd(P u, P v) {
  P g;

  // divide by two until we get an odd
  // u,v even: gcd(u,v) = 2*gcd(u/2, v/2)
  for (g = 0; ! ((u|v) & 1); ++g) {
    u >>= 1;
    v >>= 1;
  }

  // gcd(0, v) = v
  while (u)
    // u even, v odd: gcd(u,v) = gcd(u/2, v)
    if (! (u&1)) u >>= 1;
    else if (! (v&1)) v >>= 1;
    // u,v odd: gcd(u,v) = gcd(|u-v|/2, v)
    else {
      P t = (u-v) >> 1;
      if (u < v) v = -t;
      else u = t;
    }
  
  return v << g;
}

// m n M N | mat
DM_INLINE_STATIC P petsc_mat_blockdense_create(void) {
  static B pframe[FRAMEBYTES];
  P m, n, M, N;
  struct BlockDensePreass params;
  P retc;

  if (FLOORopds > o_4) return OPDS_UNF;
  if (CLASS(o_4) != NUM 
      || CLASS(o_3) != NUM 
      || CLASS(o_2) != NUM 
      || CLASS(o_1) != NUM) 
    return OPD_CLA;
  if (! PVALUE(o_1, &N)
      || ! PVALUE(o_2, &M)
      || ! PVALUE(o_3, &n) 
      || ! PVALUE(o_4, &m))
    return UNDF_VAL;
  if (N > L32MAX || M > L32MAX
      || n < 1 || m < 1 
      || m > M || n > N)
    return RNG_CHK;

  params.bs = (PetscInt) gcd(gcd(M-m, m), gcd(N-n, n));
  params.nb = (PetscInt) (n/params.bs);
  params.Nb = (PetscInt) ((N-n)/params.bs);

  if ((retc = mat_create(m, n, BLOCKDENSETYPE, pframe, &params)))
    return retc;

  moveframe(pframe, o_4);
  FREEopds = o_3;
  return OK;
}
  

DM_INLINE_STATIC P petsc_mat_destroy(void) {
  Mat A;
  
  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_1, A);
  
  DMPETSC_ERRCHECK(MatDestroy(A));
  DMPETSC_MATRIX_MATRIX(o_1) = NULL;
  
  KILL_OPAQUE();
  return OK;
}

// A B | B
DM_INLINE_STATIC P petsc_mat_copy(void) {
  Mat A, B;
  
  if (o_2 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_2, A);
  INIT_MAT(o_1, B);

  DMPETSC_ERRCHECK(MatCopy(A, B, SAME_NONZERO_PATTERN));

  moveframe(o_1, o_2);
  FREEopds = o_1;
  return OK;
}

// A | B(same shape as A)
DM_INLINE_STATIC P petsc_mat_dup(void) {
  PetscErrorCode r;
  P retc = OK;
  Mat A;
  B* pframe;
  Mat* Bm = NULL;
  B* oldfreevm = FREEvm;
  L32* row;
  
  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_1, A);

  MAKE_DMPETSC_MATRIX(pframe);
  *(Bm = &DMPETSC_MATRIX_MATRIX(pframe)) = NULL;
  DMPETSC_MATRIX_M(pframe) = DMPETSC_MATRIX_M(o_1);
  DMPETSC_MATRIX_N(pframe) = DMPETSC_MATRIX_N(o_1);
  DMPETSC_MATRIX_ASS(pframe) = ASSEMBLED;
  DMPETSC_MATRIX_DUPID(pframe) = DMPETSC_MATRIX_DUPID(o_1);

  row = &DMPETSC_MATRIX_GM(pframe);
  if ((r = MatDuplicate(A, MAT_DO_NOT_COPY_VALUES, Bm))
      || (r = MatGetOwnershipRange(*Bm, row, PETSC_NULL)))
    goto err;
  
  if (DMPETSC_MATRIX_GM(o_1) != *row) {
    retc = DMPETSC_ILLEGAL_OWNERSHIP;
    goto err;
  }

  moveframe(pframe, o_1);
  return OK;

 err:
  if (Bm && *Bm) MatDestroy(*Bm);
  FREEvm = oldfreevm;
  RETURN_ERROR(retc ? retc : errmap[r]);
}

// A | A
DM_INLINE_STATIC P petsc_mat_syncto(void) {
  Mat A;

  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_1, A);

  return OK;
}

// A | A
DM_INLINE_STATIC P petsc_mat_syncfill(void) {
  Mat A;

  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_MAT_WRITE(o_1, A);

  return OK;
}

// A | A
DM_INLINE_STATIC P petsc_mat_endfill(void) {
  Mat A;

  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_MAT_WRITEEND(o_1, A);
  return OK;
}

// <d > <l icols> m A | A
DM_INLINE_STATIC P petsc_mat_fill(void) {
  Mat A;
  L32* icols;
  D* row;
  P m;
  P n;
  L32 irows;

  if (o_4 < FLOORopds) return OPDS_UNF;

  INIT_MAT_WRITE(o_1, A);
  if (CLASS(o_2) != NUM) return OPD_CLA;
  if (! PVALUE(o_2, &m)) return UNDF_VAL;
  if (m < 0 || m >= DMPETSC_MATRIX_M(o_1)) return RNG_CHK;

  if (TAG(o_3) != (ARRAY|LONG32TYPE)) return OPD_ERR;
  icols = (L32*) VALUE_PTR(o_3);

  if (TAG(o_4) != (ARRAY|DOUBLETYPE)) return OPD_ERR;
  if ((n = ARRAY_SIZE(o_4)) != ARRAY_SIZE(o_3)) return RNG_CHK;
  if (n < 1 || n > L32MAX) return RNG_CHK;
  row = (D*) VALUE_PTR(o_4);

  irows = DMPETSC_MATRIX_GM(o_1) + (L32) m;
  DMPETSC_ERRCHECK(MatSetValues(A, 1, &irows,
				(L32) n, icols, 
				row, INSERT_VALUES));

  moveframe(o_1, o_4);
  FREEopds = o_3;
  return OK;
}

// <d > m n A | A
DM_INLINE_STATIC P petsc_mat_copyto(void) {
  P retc;
  Mat A;
  P m, n, len_arr, gm;
  L32 ncols;
  D* a;
  D* row;
  MatCopytoFunc copyto;
  MatGetrowFunc getrow;

  if (o_4 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_1, A);
  if (CLASS(o_2) != NUM || CLASS(o_3) != NUM) return OPD_CLA;
  if (! PVALUE(o_2, &n) || ! PVALUE(o_3, &m)) return UNDF_VAL;
  if (n < 0) return RNG_CHK;
  if (TAG(o_4) != (ARRAY|DOUBLETYPE)) return OPD_ERR;
  if (m >= DMPETSC_MATRIX_M(o_1) || m < 0) RETURN_ERROR(DMPETSC_NONLOCAL);

  len_arr = ARRAY_SIZE(o_4);
  gm = DMPETSC_MATRIX_GM(o_1);
  getrow = matType[DMPETSC_MATRIX_MTYPE(o_1)].getrow;
  if ((retc = getrow(A, &ncols, gm+m))) return retc;
  if (n + len_arr > ncols) return RNG_CHK;
  a = (D*) VALUE_PTR(o_4);
  row = (D*) FREEvm;
  moveD(a, row+n, len_arr);

  copyto = matType[DMPETSC_MATRIX_MTYPE(o_1)].copyto;
  if ((retc = copyto(A, gm+m, row, ncols))) return retc;

  moveframe(o_1, o_4);
  FREEopds = o_3;
  return OK;
}

// A | A
DM_INLINE_STATIC P petsc_mat_syncfrom(void) {
  Mat A;

  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_1, A);
  
  return OK;
}

// A m n <d > | <d sub-array>
DM_INLINE_STATIC P petsc_mat_copyfrom(void) {
	P retc;
  Mat A;
  P m, n, len_arr, gm;
  L32 ncols, ncols_;
  D* row;
	MatGetrowFunc getrow;

  if (o_4 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_4, A);
  if (CLASS(o_2) != NUM || CLASS(o_3) != NUM) return OPD_CLA;
  if (! PVALUE(o_2, &n) || ! PVALUE(o_3, &m)) return UNDF_VAL;
  if (n < 0) return RNG_CHK;
  if (TAG(o_1) != (ARRAY|DOUBLETYPE)) return OPD_ERR;
  if (m >= DMPETSC_MATRIX_M(o_4) || m < 0) 
    RETURN_ERROR(DMPETSC_NONLOCAL);

  gm = DMPETSC_MATRIX_GM(o_4);
  getrow = matType[DMPETSC_MATRIX_MTYPE(o_4)].getrow;
  if ((retc = getrow(A, &ncols, gm+m))) return retc;
  len_arr = ARRAY_SIZE(o_1);
  if (n >= ncols) return RNG_CHK;
  ncols_ = (len_arr < ncols - n) ? len_arr : ncols - n;
	row = (D*) FREEvm;
	moveD(row+n, (D*) VALUE_PTR(o_1), ncols_);

  moveframe(o_1, o_4);
  ARRAY_SIZE(o_4) = ncols_;
  ATTR(o_4) &= ~PARENT;
  FREEopds = o_3;
  return OK;
}

// A x | Ax (in x)
DM_INLINE_STATIC P petsc_mat_vecmul(void) {
  Mat A;
  Vec x;

  if (o_2 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_2, A);
  INIT_VEC(o_1, x);

  if (DMPETSC_MATRIX_M(o_2) != DMPETSC_VECTOR_N(o_1))
    RETURN_ERROR(DMPETSC_NOMATCH);

  DMPETSC_ERRCHECK(MatMult(A, x, x));

  moveframe(o_1, o_2);
  FREEopds = o_1;
  return OK;
}

typedef P (*KSPFunc)(KSP ksp, B* param);
typedef struct {
  KSPType t;
  KSPFunc f;
} KSPFlags;

static const KSPFlags ksptypes[] = {
  {KSPRICHARDSON, NULL},
  {KSPCHEBYCHEV, NULL},
  {KSPCG, NULL},
  {KSPCGNE, NULL},
  {KSPSTCG, NULL},
  {KSPGLTR, NULL},
  {KSPGMRES, NULL},
  {KSPFGMRES, NULL},
  {KSPLGMRES, NULL},
  {KSPTCQMR, NULL},
  {KSPBCGS, NULL},
  {KSPBCGSL, NULL},
  {KSPCGS, NULL},
  {KSPTFQMR, NULL},
  {KSPCR, NULL},
  {KSPLSQR, NULL},
  {KSPPREONLY, NULL},
  {KSPQCG, NULL},
  {KSPBICG, NULL},
  {KSPMINRES, NULL},
  {KSPSYMMLQ, NULL},
  {KSPLCD, NULL}
};

typedef P (*PCFunc)(PC pc, B* param);
typedef struct {
  PCType t;
  PCFunc f;
} PCFlags;

static const PCFlags pctypes[] = {
  {PCNONE, NULL},
  {PCJACOBI, NULL},
  {PCSOR, NULL},
  {PCLU, NULL},
  {PCSHELL, NULL},
  {PCBJACOBI, NULL},
  {PCMG, NULL},
  {PCEISENSTAT, NULL},
  {PCILU, NULL},
  {PCICC, NULL},
  {PCASM, NULL},
  {PCKSP, NULL},
  {PCCOMPOSITE, NULL},
  {PCREDUNDANT, NULL},
  {PCSPAI, NULL},
  {PCNN, NULL},
  {PCCHOLESKY, NULL},
  {PCSAMG, NULL},
  {PCPBJACOBI, NULL},
  {PCMAT, NULL},
  {PCHYPRE, NULL},
  {PCFIELDSPLIT, NULL},
  {PCTFS, NULL},
  {PCML, NULL},
  {PCPROMETHEUS, NULL},
  {PCGALERKIN, NULL},
  {PCOPENMP, NULL}
};
  
// ksptype ksparam pctype pcparams | KSP
DM_INLINE_STATIC P petsc_ksp_create(void) {
  PetscErrorCode r;
  P retc = 0;
  B* pframe;
  KSP* ksp = NULL;
  PC pc;
  P ksptype, pctype;
  B* oldfreevm = FREEvm;
  B* pcparam; B* kspparam;

  if (o_4 < FLOORopds) return OPDS_UNF;
  if (CLASS(o_4) != NUM) return OPD_CLA;
  if (PVALUE(o_4, &ksptype) 
      && (ksptype < 0 || ksptype >= (P) (sizeof(ksptypes)/sizeof(ksptypes[0]))))
    return RNG_CHK;
  kspparam = o_3;
  if (CLASS(o_2) != NUM) return OPD_CLA;
  if (PVALUE(o_2, &pctype)
      && (pctype < 0 || pctype >= (P) (sizeof(pctypes)/sizeof(pctypes[0]))))
    return RNG_CHK;
  pcparam = o_1;

  MAKE_DMPETSC_KSP(pframe);
  ksp = &DMPETSC_KSP_KSP(pframe);
  *ksp = NULL;
  DMPETSC_KSP_KSPTYPE(pframe) = ksptype;
  DMPETSC_KSP_PCTYPE(pframe) = pctype;
  DMPETSC_KSP_DUPID(pframe) = 0;
  DMPETSC_KSP_N(pframe) = 0;

  if ((r = KSPCreate(PETSC_COMM_WORLD, ksp))) goto err;
  if ((r = KSPSetInitialGuessNonzero(*ksp, PETSC_TRUE))) goto err;
  if ((r = KSPMonitorSet(*ksp, KSPMonitorDefault, 
			 PETSC_NULL, PETSC_NULL))) goto err;
  if (ksptype != PINF) {
    if ((r = KSPSetType(*ksp, ksptypes[ksptype].t))) goto err;
    if (ksptypes[ksptype].f 
	&& (retc = ksptypes[ksptype].f(*ksp, kspparam))) goto err;
  }
  if (pctype != PINF) {
    if ((r = KSPGetPC(*ksp, &pc))) goto err;
    if ((r = PCSetType(pc, pctypes[pctype].t))) goto err;
    if ((pctypes[pctype].f 
	 && (retc = pctypes[pctype].f(pc, pcparam)))) goto err;
  }

  moveframe(pframe, o_4);
  FREEopds = o_3;
  return OK;

 err:
  if (ksp && *ksp) KSPDestroy(*ksp);
  *ksp = NULL;
  FREEvm = oldfreevm;
  if (retc) return retc;
  RETURN_ERROR(errmap[r]);
}

// ksp | --
DM_INLINE_STATIC P petsc_ksp_destroy(void) {
  KSP ksp;
  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_KSP(o_1, ksp);

  DMPETSC_ERRCHECK(KSPDestroy(ksp));
  DMPETSC_KSP_KSP(o_1) = NULL;

  KILL_OPAQUE();
  return OK;
}

// ksp rtol atol dtol maxits | --
DM_INLINE_STATIC P petsc_ksp_tol(void) {
  D rtol, atol, dtol;
  LBIG maxits;
  KSP ksp;

  if (o_5 < FLOORopds) return OPDS_UNF;
  INIT_KSP(o_5, ksp);

  if (CLASS(o_1) != NUM 
      || CLASS(o_2) != NUM 
      || CLASS(o_3) != NUM 
      || CLASS(o_4) != NUM) return OPD_CLA;

  VALUE(o_1, &maxits);
  DVALUE(o_2, &dtol);
  DVALUE(o_3, &atol);
  DVALUE(o_4, &rtol);

  DMPETSC_ERRCHECK(
     KSPSetTolerances(ksp, 
		      ! ISUNDEF(rtol) ? rtol : PETSC_DEFAULT,
		      ! ISUNDEF(atol) ? atol : PETSC_DEFAULT,
		      ! ISUNDEF(dtol) ? dtol : PETSC_DEFAULT,
		      maxits != LBIGINF ? maxits : PETSC_DEFAULT));

  FREEopds = o_5;
  return OK;
}

// KSP A/null x b | x
DM_INLINE_STATIC P petsc_ksp_solve(void) {
  KSP ksp;
  Mat A;
  Vec x;
  Vec b;
  UL64* ldupid;
  L32* n;
  KSPConvergedReason rzn;

  if (o_4 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, b);
  INIT_VEC(o_2, x);
  if (TAG(o_3) != NULLOBJ) INIT_MAT(o_3, A);
  else A = NULL;
  INIT_KSP(o_4, ksp);

  ldupid = &DMPETSC_KSP_DUPID(o_4);
  n      = &DMPETSC_KSP_N(o_4);
  if (! A) {
    if (! *ldupid) RETURN_ERROR(DMPETSC_KSPSOLVE_NOINIT);
  }
  else if (! *ldupid) {
    *ldupid = DMPETSC_MATRIX_DUPID(o_3);
    *n      = DMPETSC_MATRIX_N(o_3);
  }
  else if (*ldupid != DMPETSC_MATRIX_DUPID(o_3))
    RETURN_ERROR(DMPETSC_KSPSOLVE_NODUP);

  if (*n !=  DMPETSC_VECTOR_N(o_2) || *n != DMPETSC_VECTOR_N(o_1)) 
    RETURN_ERROR(DMPETSC_NOMATCH);
  if (A) DMPETSC_ERRCHECK(KSPSetOperators(ksp, A, A, SAME_NONZERO_PATTERN));

  DMPETSC_ERRCHECK(KSPSetUp(ksp));
  DMPETSC_ERRCHECK(KSPSolve(ksp, b, x));
  DMPETSC_ERRCHECK(KSPGetConvergedReason(ksp, &rzn));
  if (rzn < 0) RETURN_ERROR(errmap[PETSC_ERR_MAX_VALUE + (-rzn)]);

  moveframe(o_2, o_4);
  FREEopds = o_3;
  return OK;
}

// ksp | iterations
DM_INLINE_STATIC P petsc_ksp_iterations(void) {
  KSP ksp;
  L32 its;
  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_KSP(o_1, ksp);

  if (! DMPETSC_KSP_DUPID(o_1))
    RETURN_ERROR(DMPETSC_KSPSOLVE_NOINIT);
  DMPETSC_ERRCHECK(KSPGetIterationNumber(ksp, &its));

  TAG(o_1) = (NUM|LONG32TYPE);
  ATTR(o_1) = 0;
  LONG32_VAL(o_1) = abs(its);

  return OK;
}

#include "dm-dmpetsc-main.h"
