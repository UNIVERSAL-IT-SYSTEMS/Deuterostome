#! @ENABLE_PERL@ -w

use warnings;
use strict;
use File::Temp qw(tempfile tempdir);
use IO::Handle;
use File::Basename;
use POSIX qw(:sys_wait_h setsid);
use File::Spec;

END {
	close(STDOUT);
	close(STDERR);
	while (wait() != -1) {};
};

my %tools = (
	a2ps => '@ENABLE_ATPS@',
	lp => '@ENABLE_LP@',
	ps2pdf => '@ENABLE_PSTPDF@',
	pdf2ps => '@ENABLE_PDFTPS@',
	dvipdf => '@ENABLE_DVIPDF@',
	xdvi => '@ENABLE_XDVI@',
	gs => '@ENABLE_GS@',
	pdflatex => '@ENABLE_PDFLATEX@',
	latex => '@ENABLE_LATEX@'
	);

foreach my $tool (keys %tools) {
	my $path = $tools{$tool};
	if (! length($path)) {
		$tools{$tool} = ['@dmstartdir@/runtool.sh', 'no', $tool];
	} {
		$tools{$tool} = ['@dmstartdir@/runtool.sh', 'yes', $path];
	}
}

sub mytool($) {
	my $tool = shift;
	return @{$tools{$tool}};
}
		

sub forker(@) {
	my $fork = fork;
	die "$!" if ! defined $fork;
	if (! $fork) {
		print "Executing: @_\n";
		exec {$_[0]} @_;
		die "$!";
	}

	return $fork;
}

sub background(@) {
	forker(@_);
}

sub foreground(@) {
	waitpid(forker(@_), 0);
}

sub gs(@) {
	my @pre;
@ENABLE_XTERM_START@
	@pre = ('@ENABLE_XTERM@', '-T', 'Ghostscript', '-e') 
	  if exists $ENV{DISPLAY};
@ENABLE_XTERM_END@

	foreground(@pre, mytool('gs'), @_);
}


sub shellf(@) {
	foreground('/bin/sh', '-c', "@_");
}

sub shellb(@) {
	background('/bin/sh', '-c', "@_");
}	

sub shellq(;$) {
	local $_ = defined $_[0] ? $_[0] : $_;
	s{([^A-Za-z0-9_/.\-])}{\\$1}og;
	return $_;
}

sub shellify(;@) {
	my @vals = @_ ? @_ : ($_);
	return map {'"' . shellq() . '"'} @vals;
}

sub tmpify($;@) {
	my $suff = shift;
	$suff = '.' . $suff if length $suff;

	my @vals = @_ ? @_ : ($_);
	my $tempdir = shellq(tempdir('print-XXXX', CLEANUP => 1, TMPDIR => 1));
	my ($i, @fs, @rs) = (0);
	foreach (@vals) {
		$i++;
		my $base = "f$i-" . fileparse($_);
		push @fs, ['"' . shellq() . '"', 
				   '"' . "$tempdir/" . shellq($base) . $suff . '"'];
		push @rs, "$tempdir/$base$suff";
	}

	return ([@fs], [@rs]);
}

sub sys(&@) {
	my $code = shift;
	my ($fs, $rs) = tmpify(shift, @_);
	shellf($code->(@{$_})) foreach @{$fs};
	return @{$rs};
}

my $DVTPSPATH = exists $ENV{DVTPSPATH} ? $ENV{DVTPSPATH} : '@pkgpsdatadir@';
my @GSDVTPSPATH = ("-sDVTPSPATH=$DVTPSPATH");
my @QGSDVTPSPATH = ("-sDVTPSPATH=" . shellify($DVTPSPATH));

my @xpsfiles;
push @xpsfiles, "$DVTPSPATH/$_.ps" 
	foreach ('form_2', 'text', 'graf_1', 'struct');
my @qxpsfiles;
push @qxpsfiles, shellify foreach @xpsfiles;

my @x1psfiles;
push @x1psfiles, "$DVTPSPATH/$_.ps" 
	foreach ('form_1', 'text', 'graf_1', 'struct');
my @qx1psfiles;
push @qx1psfiles, shellify foreach @x1psfiles;

my $xps = {
	gs => sub {
		gs(@GSDVTPSPATH, '-sPAPERSIZE=letter', '-dBATCH', @xpsfiles, $_)
			foreach @_;
	},
	lw => sub {
		sys {'cat', @qxpsfiles, $_[0],
			 '|', mytool('ps2pdf'), @QGSDVTPSPATH, 
			 '-dEmbedAllFonts=true -', $_[1], '&&',
			 mytool('lp'), $_[1]
		} pdf => @_;
	},
	xpdf => sub {
		sys {'cat', @qxpsfiles, $_[0],
			 '|', mytool('ps2pdf'), @QGSDVTPSPATH, 
			 '-dEmbedAllFonts=true -', $_[1], '&&', 
			 '@guipdf@', $_[1]
		} pdf => @_;
	}
};

sub dodvi($$@) {
	my ($tool, $suffix, @files) = @_;
	my @out = map {[fileparse($_, qr{\.tex})];} @files;
	shellf('cd', shellify($_->[1]), '&&',
		   $tool, '"\\nonstopmode\\input{' . shellq($_->[0]) . '}"')
		foreach @out;

	return map {"$_->[1]/$_->[0].$suffix"} @out;
}

my $funcs;
$funcs = {
	talk => {
		gs => sub {gs();}
	},
	ascii => {
		gs => sub {
			shellf(mytool('a2ps'), '-o- -2 --print-anyway=1 --medium=Letter',
				   shellify @_ , '|', mytool('gs'), 
				   '-sPAPERSIZE=letter -dBATCH');
		},
        xpdf => sub {
			sys {mytool('a2ps'), '-o- -2 --print-anyway=1 --medium=Letter',
				 $_[0],  '|', mytool('ps2pdf'), '-', $_[1], '&&',
					 '@guipdf@', $_[1]
			} pdf => @_;
	    },
		lw => sub {
			sys {mytool('a2ps'), 
				 '-o- -2 --print-anyway=1 --medium=Letter', $_[0],
				 '|', mytool('ps2pdf'), '-', $_[1], '&&',
				 mytool('lp'), $_[1], '&&'
			} pdf => @_;
		}
	},
	ps => {
		gs => sub {
			gs('-sPAPERSIZE=letter', '-dBATCH', $_) foreach @_;
		},
		xpdf => sub {
			sys {mytool('ps2pdf'), $_[0], $_[1], '&&',  
				 '@guipdf@', $_[1]
			} pdf => @_;
		},
		lw => sub {
			sys {mytool('ps2pdf'), $_[0], $_[1], '&&',
				 mytool('lp'), $_[1]
			} pdf => @_;
		}
	},
	xps => $xps,
	x2ps => $xps,
	x1ps =>  {
		gs => sub {
			gs(@GSDVTPSPATH, '-sPAPERSIZE=letter', '-dBATCH', @x1psfiles, $_)
				foreach @_;
		},
		lw => sub {
			sys {'cat', @qx1psfiles, $_[0],
				 '|', mytool('ps2pdf'), @QGSDVTPSPATH,
				 '-dEmbedAllFonts=true -', $_[1], '&&',
				 mytool('lp'), $_[1]
			} pdf => @_;
		},
		xpdf => sub {
			sys {'cat', @qx1psfiles, $_[0],
				 '|', mytool('ps2pdf'), @QGSDVTPSPATH,
				 '-dEmbedAllFonts=true -', $_[1], '&&',
				 '@guipdf@', $_[1]
			} pdf => @_;
		}
	},
	pdf => {
		gs => sub {
			$funcs->{ps}{gs}(sys {mytool('pdf2ps'), $_[0], $_[1]} pdf => @_);
		},
		lw => sub {foreground(mytool('lp'), @_);},
		xpdf => sub {shellf('@guipdf@', $_) foreach shellify @_;}
	},
	dvi => {
		lw => sub {
			$funcs->{pdf}{lw}(
				sys {mytool('dvipdf'), '-sPAPERSIZE=letter', @$_} pdf => @_);
		},
		xpdf => sub {
			$funcs->{pdf}{xpdf}(
				sys {mytool('dvipdf'), '-sPAPERSIZE=letter', @$_} pdf => @_);
		},
		xdvi => sub {
			background(mytool('xdvi'), $_) foreach @_;
		}
	},
	tex => {
		gs => sub {
			$funcs->{pdf}{gs}(dodvi(mytool('pdflatex'), 'pdf', @_));
		},
		lw => sub {
			$funcs->{pdf}{lw}(dodvi(mytool('pdflatex'), 'pdf', @_));
		},
		xpdf => sub {
			$funcs->{pdf}{xpdf}(dodvi(mytool('pdflatex'), 'pdf', @_));
		},
		xdvi => sub {
			$funcs->{dvi}{xdvi}(dodvi(mytool('latex'), 'dvi', @_));
		}
	}
};

@ENABLE_XTERM_START@
# if DISPLAY, run output through xterm.
if (exists $ENV{DISPLAY}) {
	my ($out, $outfile) = tempfile('print-XXXXXX', 
								   DIR => File::Spec->tmpdir(), 
								   UNLINK => 1);
	$out->autoflush(1);
	
	my $pid = $$;
	setsid;

	my $fork = fork;
	die "$!" if ! defined $fork;
	if (! $fork) {
		foreground('@ENABLE_XTERM@', '-T', 'Printing....', 
				   '-e', '@ENABLE_TAIL@', '-f', $outfile);
		kill HUP => -$pid;
		exit 0;
	}

	open(STDOUT, ">&", $out) or die "$!";
	open(STDERR, ">&", $out) or die "$!";
	STDOUT->autoflush(1);
	STDERR->autoflush(1);
}
@ENABLE_XTERM_END@

my $source = shift;
my $dest = shift;

if (exists $funcs->{$source} && exists $funcs->{$source}{$dest}) {
	$funcs->{$source}{$dest}(@ARGV);
} else {
	print STDERR "No transform from $source to $dest";
}
	
print "Done...\n";
sleep if exists $ENV{DISPLAY};
