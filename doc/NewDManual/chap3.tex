\chapter{THE  MACHINES}\label{chap:cluster}

D machines work in a group. The smallest group might include two D machines, both running on your desktop. One serves as a terminal, the other as the computational workhorse. You could extend this group to several workhorses, which might run locally in your (multi-processor) desktop or run in different physical hosts that are networked across your lab. In a variant, your D machine serving as terminal might run on your home computer and the other machines of the group on hosts in your lab. You might also recruit a group of D machines whose physical hosts are interconnected for high-speed communication to perform strongly coupled parallel computations (a `cluster').

Three specializations of D machine let you build groups that suit your work:

\begin{enumerate}
\item the D Virtual Terminal (\emph{dvt})
\item the D Node (\emph{dnode})
\item the D Pawn (\emph{dpawn})
\end{enumerate}

\noindent The \emph{dvt} serves as a combination of text and graphical terminal between you and one or many \emph{dnodes} that you have recruited to do computations for you.

A \emph{dnode} includes an extended set of mathematical operators for solving numerical problems (the set can be augmented  by extrinsic operators). A \emph{dnode} can use all processors of its host for multi-threaded computations.

A \emph{dnode} itself can create a set of \emph{dpawns} for solving large numerical problems in parallel on a cluster of hosts (and, automatically, all processors of each host).

The \emph{dvt} and \emph{dnodes}, and \emph{dnodes} among themselves, communicate point-to-point through a bi-directional stream protocol that runs on tcp/ip. A \emph{dnode} and its \emph{dpawns} communicate through the Multiple Message Protocol (mpi), which usually runs on tcp/ip. The \emph{mpi} allows a \emph{dnode} to control a cluster of \emph{dpawns} using broadcasted messages.

Parallel computations in \emph{dpawns} are supported by PETSc (`Portable, Extensible Toolkit for Scientific computation'). PETSc includes a large body of solvers for linear algebra problems. PETSc works on vectors and matrices that are stored across a machine cluster rather than in one machine. Work on different chunks of the vectors and matrices is divided amongst the different members of the cluster, so that much of the work can be done in parallel.

To do as much work as needed in parallel, not only must the parts directly supported by PETSc be done in parallel but also time-consuming work specific for the problem (`filling the matrix'). To allow you to do such specific work in parallel, the \emph{dpawn} machine is laid out as a general purpose D machine (including all computational means of a \emph{dnode}). The vectors and matrices that PETSc operators expect to work on are created in composite D objects, so that ordinary D operators can access them as well. These D objects are created in each \emph{dpawn} of the cluster to hold exactly the chunks of the vectors and matrices that this \emph{dpawn} is assigned to work on. These objects contain mapping information locating the local objects in the global vectors and matrices. You create the PETSc objects of each \emph{dpawn} by code specific to this \emph{dpawn} (this way parcelling the global vectors and matrices yourself rather than have PETSc operators assign the parcels). The code to fill in these objects and to do computations on them using PETSc can be the same for all \emph{dpawns} provided you write the code for filling the parcels using the mapping information contained in the PETSc objects.

 All phases of operating the \emph{dpawn} cluster are supported by a library of procedures that is loaded with the `startup' code of the \emph{dnode}. The library very much makes the \emph{dnode} look as the machine that solves the entire problem while the involvement of the \emph{dpawn} cluster remains visible only in a small amount of overhead.



\newpage

\section{Overview of machine-specific operators}

The following table summarizes the \emph{operators} that are specific for one or more varieties of D machine, or whose behaviors differ among machines. Only actual operators are included. These specific operators are complemented by machine-specific procedures (`operators written in D') that the different D machines derive from their specific `startup\_xxx.d' files.\\

\begin{tabular}{>{\sffamily\bfseries}l>{\sffamily}r>{\sffamily}r>{\sffamily}r}
operator & dvt & dnode & dpawn \\
\hline\\
connect & + & + & - \\
disconnect & + & + & - \\
send & + & + & - \\
getsocket & + & + & - \\
getmyname & + & + & - \\
getmyfqdn & + & + & - \\\\
Xwindows & + & + & - \\
Xdisplayname & + & + & - \\
screensize & + & + & - \\
makewindow & + & + & - \\
deletewindow & + & + & - \\
mapwindow & + & + & - \\
resizewindow & + & + & - \\
Xsync & + & + & - \\
mapcolor & + & + & - \\
drawline & + & + & - \\
drawsymbols & + & + & - \\
fillrectangle & + & + & - \\
drawtext & + & + & - \\
makewindowtop & + & + & - \\\\
Xauth & + & + & - \\
Xauthrev & + & + & - \\
Xauthgen & + & + & - \\
Xauthset & + & + & - \\
Xwindows\_ & - & + & - \\
Xconnect & - & + & - \\
Xdisconnect & - & + & - \\\\

nextevent & + & - & - \\
aborted & + & - & - \\
getmyport & - & + & - \\
setconsole & - & + & - \\
console & - & + & - \\
killsockets & - & + & - \\
socketdead & - & + & - \\\\
loadlib & - & + & + \\
nextlib & - & + & + \\\\
\end{tabular}

\begin{tabular}{>{\sffamily\bfseries}l>{\sffamily}r>{\sffamily}r>{\sffamily}r}
operator & dvt & dnode & dpawn \\
\hline\\
quit & + & - & + \\\\
lock & - & + & + \\
unlock & - & + & + \\
serialize & - & + & + \\
threads & - & + & + \\
makethreads & - & + & + \\
tostderr & - & + & + \\
halt & - & + & + \\
continue & - & + & + \\
vmresize & - & + & + \\
getplugindir & - & + & + \\\\
matmul\_blas & - & + & + \\
decompLU\_lp & - & + & + \\
backsubLU\_lp & - & + & + \\
invertLU\_lp & - & + & + \\
norm2 & - & + & + \\
matvecmul\_blas & - & + & + \\
triangular\_solve & - & + & + \\
givens\_blas & - & + & + \\
rotate\_blas & - & + & + \\\\

rthreads & - & + & - \\
makerthreads & - & + & - \\
checkrthreads & - & + & - \\
rsend & - & + & + \\
\end{tabular}

\begin{tabular}{>{\sffamily\bfseries}l>{\sffamily}r>{\sffamily}r>{\sffamily}r}
operator & dvt & dnode & dpawn \\
\hline\\
mpiprobe & - & - & +\\
mpiiprobe & - & - & +\\
mpisend & - & - & +\\
mpirecv & - & - & +\\
mpibarrier & - & - & +\\
mpibroadcast & - & - & +\\
mpirank & - & - & +\\
mpisize & - & - & +\\
groupconsole & - & - & +\\\\
petsc\_vec\_create & - & - & + \\
petsc\_vec\_copy & - & - & + \\
petsc\_vec\_copyto & - & - & + \\
petsc\_vec\_copyfrom & - & - & + \\
petsc\_vec\_syncto & - & - & + \\
petsc\_vec\_syncfrom & - & - & + \\
petsc\_vec\_max & - & - & + \\
petsc\_vec\_min & - & - & + \\
petsc\_vec\_destroy & - & - & + \\
petsc\_mat\_create & - & - & + \\
petsc\_mat\_copy & - & - & + \\
petsc\_mat\_copyto & - & - & + \\
petsc\_mat\_copyfrom & - & - & + \\
petsc\_mat\_syncto & - & - & + \\
petsc\_mat\_syncfrom & - & - & + \\
petsc\_mat\_destroy & - & - & + \\
petsc\_mat\_dup & - & - & + \\
petsc\_mat\_vecmul & - & - & + \\
petsc\_ksp\_create & - & - & + \\
petsc\_ksp\_destroy & - & - & + \\
petsc\_ksp\_tol & - & - & + \\
petsc\_ksp\_iterations & - & - & + \\
petsc\_ksp\_solve & - & - & + \\\\
\end{tabular}

\newpage


\section{The  D Virtual Terminal (\emph{dvt})}\label{sec:dvt}
You can start a \emph{dvt} process from a shell. Better support is provided to a \emph{dvt} through a \emph{dvt}-configured \emph{emacs} environment. In this environment, you can start a \emph{dvt} by the \emph{emacs} command `esc-x dvt'. In both shell environments, the \emph{dvt} inherits the shell as its console. You therefore retain the editing capabilities of that shell when you work at the console of the \emph{dvt}. In addition, the \emph{emacs} environment provides many \emph{dvt} supporting functions through bound keys. \emph{emacs} itself will operate through an X Window system. The \emph{dvt} then will bring up an additional, graphical user interface to itself consisting of three \emph{dvt} windows.

\subsection{The \emph{dvt} mill}

The test phase of the \emph{dvt} mill is implemented in D code (cf. \ref{sec:mill}). This D code is loaded upon initialization when the file `startup\_dvt.d' is interpreted. The D code of the outermost loop of the \emph{dvt} uses a dvt-specific operator, \emph{nextevent}, to determine, and react to, an event that requires the attention of the machine. This operator delivers requests made by you at the console  of the \emph{dvt}, requests made by windows associated with the \emph{dvt}, requests made from \emph{dnodes} over network connections, and an emergency signal. By this \emph{modus operandi} a \emph{dvt} will attend to new requests made to it only after its current activity is completed. (This is an important difference with regard to the behavior of a \emph{dnode} or \emph{dpawn}). A \emph{dvt} is only interrupted upon sending it an emergency signal: pressing `control-c' from \emph{bash} or `control-c control-c' from the \emph{emacs} shell. Upon receiving this signal, the \emph{dvt} will execute the \emph{abort} operator. Likewise, when an error is discovered in a \emph{dvt} activity itself, \emph{abort} is executed after displaying an error message.

 If you make the \emph{dvt} perform major services (e.g., automate the coordination of a job involving many \emph{dnodes}), you must organize your D code such that it can be executed in short bursts of mill cycles rather than, in the worst case, in an endless loop that prevents the outermost loop of the \emph{dvt} from attending to external events through \emph{nextevent}. If your \emph{dvt} code being tested turns out such an obstinate customer, use the emergency signal from the keyboard to restore \emph{dvt} responsiveness.

The  operation of the \emph{dvt} mill ceases when  the operator \emph{quit} is executed; this terminates the Linux process of the \emph{dvt}.

Whenever a component of the \emph{dvt} detects an error condition, it initiates a consistent error response: a string (revealing the instance of discovery, like the operator name) and a numeral (coding for the type of the error) are pushed on the operand stack, and the `error' is executed. The operator \emph{error} uses the string and numeral on the operand stack to formulate a console error message; after showing this message, \emph{abort} is executed. This drops all stacks and resumes execution of the outermost loop of the \emph{dvt}.



\subsection{The \emph{dvt} operators}\label{ssec:dvtops}

The operator set of the \emph{dvt} includes operators that either are unique to the \emph{dvt} or are implemented there in a unique way. Many of these `operators' actually are D procedures defined in the file `startup\_dvt.d'.\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
  stringbuf & nextevent & eventparams...\\
  active\_obj & aborted & --\\
  instance\_string error\_num & error & --\\
  instance\_string error\_num stringbuf & errormessage & message\_substring\\
  -- & quit & --\\
\end{tabular}

\index{operator!nextevent}
\index{operator!aborted}
\index{operator!error}
\index{operator!errormessage}
\index{operator!quit}

\noindent \emph{nextevent} takes a string buffer as operand and blocks until an event requiring \emph{dvt} attention occurs. Several kinds of event are detected and cause \emph{nextevent} to push an active name on the execution stack. These names and their significance are:\\

\begin{tabular}{>{\sffamily\bfseries}l>{\sffamily}l}
  consoleline & `a phrase is available from the console keyboard'\\
  nodemessage & `a message has been sent from a \emph{dnode}'\\
  windowsize  & `request to change the size of an X window'\\
  drawwindow  & `request to (re)draw an X window'\\
  mouseclick  & `a mouse click into an X window has occurred'\\\\
\end{tabular}

Additional information relevant for the event is communicated by \emph{nextevent} as follows:

\begin{description}
\item[consoleline] The keyboard phrase is returned in a substring of the string buffer operand
\item[nodemessage] Dependent on the form of the message used in the \emph{send} operator executed in the \emph{dnode}, a \emph{save} operation is performed, and/or the root object of a received object tree is pushed on the operand stack. In all usages of \emph{send}, the received message string (substring of the string buffer) is pushed on the operand stack. 
\end{description}

\noindent If the event originates from activity in an X window, the dictionary associated with the window name is pushed on the dictionary stack; this dictionary must be defined by you in \emph{userdict} and be associated there with a properly formed name: the letter `w' followed by digits specifying the window\# (see \ref{ssec:windows}). The dictionary must associate \emph{windowsize}, \emph{drawwindow}, and \emph{mouseclick} with window-specific procedures. These procedures receive their operands from \emph{nextevent}:  

\begin{description}
\item[windowsize] The width and height of the window are pushed on the operand stack
\item[drawwindow] No operands are passed 
\item[mouseclick] The abscissa, ordinate, and modifiers describing the mouse event are pushed on the operand stack. Modifiers are generated by keyboard keys simultaneously held down when the mouse button is clicked, or by using the 2nd to 5th button of a multi-button mouse. The encoding of the modifiers is the standard encoding of the X Window library (see file `startup\_dvt.d' for assignments used in the \emph{dvt}).
\end{description}

Procedures named \emph{consoleline} and \emph{nodemessage} are defined in \emph{userdict} when the file `startup\_dvt.d' is interpreted. These procedures are part of the D  code that implements the behavior of the \emph{dvt} that we describe in this section.

\emph{aborted} marks the current top object of the execution stack as the object to which the stack is dropped when \emph{abort} is executed. Typically there is only one \emph{aborted} context in a \emph{dvt}. \emph{error} is automatically invoked when a \emph{dvt} operator discovers an error condition. \emph{error} expects two operands indicating the instance and cause of the error condition on the operand stack. It assembles a message string from this information (decoding the error number into a text message), prints the error message on the console screen, and forces the execution of \emph{abort}. \emph{errormessage} also composes an error message; it returns the message as substring of the designated string buffer and resumes normal execution.

\emph{quit} terminates the \emph{dvt} process.



\subsubsection{Supervising of \emph{dnodes}}

When a \emph{dvt} hooks up over a network with \emph{dnodes}, it serves as the console of these D machines. The \emph{dvt} provides a mechanism to switch the console among the various D machines that are hooked up to it. Initially, the console targets the \emph{dvt}'s D machine itself.\\  


\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
  -- & h\_ & --\\\\
\end{tabular}

\noindent prints a help message summarizing all `operators' that are provided to the \emph{dvt} via the `startup\_dvt.d' file.\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
  -- & hk\_ & --\\\\
\end{tabular}

\noindent prints a help message summarizing all keys that have been bound to \emph{dvt}-supporting \emph{emacs} functions when the \emph{dvt} runs inside \emph{emacs}.\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
(hostname) port\# group\# & \_c & --\\\\
\end{tabular}

\noindent opens a connection between the \emph{dvt} and the \emph{dnode} described by the name of its host and the D machine port where this \emph{dnode} is listening (this port number is assigned to the \emph{dnode} when the \emph{dnode} is started from a shell (see the section on \emph{dnodes})). Port numbers are positive integers including $0$. When the connection is established, the target \emph{dnode} is instructed to use this \emph{dvt} as its console and to send \emph{X Window} communications to the \emph{X Window} server on the host of this \emph{dvt}. (There is a more fancy version of this command that tells also the \emph{dnode} to color all its text communications with the \emph{dvt} so that they appear as visually distinct.) The connected \emph{dnode} is assigned a node number. Node numbers are positive integers ($0$ is reserved for the \emph{dvt}) and are assigned and disassigned to \emph{dnodes} as these are connected and disconnected (thus node 3 may be unused, whereas node 4 may be in use). Connected \emph{dnodes} can be grouped by associating them with a group number (a negative integer). The \emph{dvt} broadcasts console phrases to all \emph{dnodes} of a group when a group is selected as the current target.\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
(hostname) port\# group\# dim\_array & \_csu & --\\\\
\end{tabular}

\noindent includes the functions of \emph{\_c} but also sets up the storage capacities of the \emph{dnode} to the dimensions specified in \emph{dim\_array} that has the entries: $<$l opdssize excssize dictssize vmsize\_in\_MB userdictsize $>$ (`opdssize', for instance, is the capacity, in objects, of the \emph{dnode's} operand stack). \emph{\_csu} also instructs the \emph{dnode} to read and interpret the `startup\_dnode.d' file, which defines a library of procedures in the primed \emph{dnode}.\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
-- & c\_ & --\\\\
\end{tabular}

\noindent prints on the \emph{dvt} console screen the node numbers of the dvt (which is $0$), and of all currently connected \emph{dnodes} together with their host name, port number, status (`ready' or `busy'), and group number.\\  


\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
node\# & \_dc & --\\\\
\end{tabular}

\noindent disconnects the specified \emph{dnode} from this \emph{dvt}. Note that you can connect, disconnect, and reconnect \emph{dnodes} as often as you wish without interfering with ongoing activity in the \emph{dnode's} D machine: the \emph{dnode} can continue to execute D code that constitutes a long job, independent of whether it is connected to a \emph{dvt}. \emph{\_dc} does not tell the node to close \emph{X Window} activity on the \emph{dvt} host. You can continue to interact with the \emph{dnode} using these windows, even though the \emph{dnode} is no longer connected to a \emph{dvt} on this host.\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
node\# & \_dx & --\\\\
\end{tabular}

\noindent acts like \emph{\_dc} but also instructs the \emph{dnode} being disconnected from the \emph{dvt} to close all \emph{X Window} activities with the \emph{dvt} host.\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
node\# & kill & --\\\\
\end{tabular}

\noindent acts like \emph{\_dx}, and, in addition, tells the \emph{dnode} being disconnected to resize its memory allocations to those of a dormant \emph{dnode}. This terminates all ongoing activity in that \emph{dnode}, except its listening to incoming connection requests.\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
node\#\_or\_group\# & \_t & --\\\\
\end{tabular} 
 
\noindent selects a node or group of nodes as the target(s) for subsequent console input. (again, node \#$0$ directs keyboard input to the \emph{dvt} itself).\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
node\# & \_r & --\\\\
\end{tabular} 

\noindent forces the `ready` status of the node. When a \emph{dnode} that is the currently selected target is given a console phrase to execute, the status of this node is set to `busy`, and the console phrase is delivered to the \emph{dnode} together with a request to inform the \emph{dvt} when the activity started by this console phrase has been completed (or stopped). When the \emph{dvt} receives this completion message, it sets the status of the node to `ready'. This mechanism ensures that activity initiated by a console phrase delivered to a \emph{dnode} will be completed before you can give another console phrase to the \emph{dnode}. (\emph{dnodes} interrupt their activity to respond to requests made on their connections). If you try to give a console phrase to a `busy' node, the \emph{dvt} will refuse (discard) it and warn you by the console message ``Wait!''. You can override this mechanism by prefixing your console phrase with a tag (see below). Note that this mechanism belongs to the \emph{dvt} --- \emph{dnodes} are unaware of its existence.

Many of the \emph{dvt} operators described above can be invoked, in a more convenient interface, by selecting from an \emph{X Window} window entitled ``TheHorses'' (described later in this section).

\subsection{Tagged console phrases}

Certain characters when appearing as the first character of a console phrase direct the \emph{dvt} to treat the remainder of the console phrase in some special way. The effect of the tag will also depend on the currently selected target type, \emph{dvt} or \emph{dnode}.\\

\begin{tabular}{>{\sffamily\bfseries}l>{\sffamily\itshape}l>{\sffamily}l}

No tag & dvt & execute phrase as D code\\
&        dnode & transmit phrase as D code to the \emph{dnode}, observing\\
&              & the `ready/busy` rule\\\\
! & dvt & execute phrase as D code\\
  & dnode & transmit phrase as D code to the \emph{dnode}, disregarding\\
  &       & the `ready/busy` rule\\\\ 
\$ & dvt & submit phrase as Unix shell command to the host of the \emph{dvt}\\
   & dnode & transmit phrase and submit it as Unix shell command to the\\
   &       & host of the \emph{dnode}, observing the `ready/busy' rule\\\\
\# & dvt & execute phrase in the D machine of the \emph{dvt}, use results to\\
   &     & build a Unix shell command, submit the shell command\\
   &     & to the host of the \emph{dvt}\\
   & dnode & execute phrase in the D machine of the \emph{dvt}, use results to\\
   &     & build a Unix shell command, submit the shell command\\
   &     &  to the host of the \emph{dnode}, observing the `ready/busy' rule\\\\
@ & dvt & execute phrase in the D machine of the \emph{dvt}, use results to\\
  &     & build a Unix shell command, submit the shell command\\
  &     &  to the host of the \emph{dvt}\\
  & dnode & transmit the phrase to the \emph{dnode} and execute it in the D\\
  &       & machine of the \emph{dnode}; make the \emph{dnode} build\\
  &       & a Unix shell command from the results, and submit it\\
  &       &  to the host of the \emph{dnode}, observing the `ready/busy' rule\\\\
\end{tabular}

The last two tags have complex effects --- you will hardly use them when typing console phrases (they rather are used in `macros' produced by clicks into the ``DVT macros'' window maintained by the \emph{dvt} when it uses \emph{X Window}.

\subsection{Key bindings supporting the \emph{dvt}}

When a \emph{dvt} is started through the \emph{emacs} command `esc-x dvt', the following key bindings with \emph{dvt}-supporting \emph{emacs} functions are created:\\ 

\begin{tabular}{>{\sffamily\bfseries}l>{\sffamily}l}
    f1 & execute the previous console phrase\\
    f2 & send `continue' to the dvt/dnode\\
    f3 & send `stop' to the dvt/dnode\\
    f4 & send `abort' to the dvt/dnode\\
    f5 & pop up TheHorses window\\
    f6 & pop up all dvt/dnode windows\\
    shift-f6 & iconify all dvt/dnode windows\\
    f7 & raise the dvt emacs frame\\
    f8 & start a local dnode\\
    control-h d & get this help\\
    control-! & ignore busy state when sending to dnodes\\
    control-1 & same as control-!\\
    control-c c & clear preceding text from emacs window\\
    control-c control-a & send phrase wrapped in `debug abort'\\
    control-$>$ & send output to log file\\
    control-c control-n & narrow dvt buffer\\
    control-c control-w & widen dvt buffer\\\\
\end{tabular}

If you wish to see also the names of the corresponding emacs Lisp functions, use `control-h d'.

Another service provided by the \emph{emacs} environment is language support for D. When you edit D code in a edit buffer or the shell buffer you receive editing support (e.g. matching parentheses are indicated). The different D objects are highlighted in color (you can toggle this feature off or on using the standard \emph{emacs} command `esc-x fontlockmode').

\subsection{The graphical user interface of the  \emph{dvt}}

When the \emph{dvt} process is running on a host that provides an \emph{X Window} server, it will create and maintain three windows, two of which are \emph{dvt}-specific and one of which is also implemented by \emph{dnodes}. The D code for operating these windows is contained in the file `startup\_dvt.d', so that it is loaded when the \emph{dvt} process is started up. The three windows are:

\begin{description}
\item[TheHorses] shows the list of D machines that currently form a cluster. The \emph{dvt} is listed at the top, followed by the connected \emph{dnodes} (described as hostname: port\#). The background of each entry shows the status of the node: white for `ready', and green for `busy'. The currently selected target(s) for console input is (are) are highlighted by showing their name(s) in blue and boldface. You can select a D machine as target by a mouse click. You can select a group of \emph{dnodes} as targets by control/clicking on one of the nodes of the group. Only one \emph{dnode} or group will be selected at a given time. You can force the \emph{dvt} to set a \emph{dnode} connection to the `ready' status by shift/clicking on it. If you have a multi-button mouse: shift/click and control/click are equivalent to clicking on buttons 2 or 3.

\item[DVT macros] displays a list of command mnemonics. When you click on a mnemonic, a string is placed into the console screen. You can execute this string as a console phrase by moving the cursor over it and pressing `return' (function key `F1' combines both actions). Typically, you will have to click two mnemonics to produce a complete command, one designating a source and the other a destination object. The source and destination objects, in turn, are derived from objects selected in the third window, called `TheEye`. For instance, you may select a .tex file using \emph{TheEye}, and click, in \emph{DVT macros}, `tex' on the `PrintFrom' line, and `pdf' on the `PrintTo' line, followed by pressing `F1'. This will compile the .tex file and submit it to a program for display and optional printing. The services of the \emph{DVT macros} are defined by shell scripts and by D code contained in `startup\_dvt.d'. Note that you can modify console phrases produced by \emph{DVT macros} by editing them prior to submitting them for execution: clicking mnemonics of \emph{DVT macros} simply provides templates for commands that are hard to remember. Such a command phrase is placed into the console buffer so that you can execute it (press F1), or execute it after some editing from your hand.

\item[TheEye] lets you view any object contained in the associated D machine, and any file system known to the host from which the \emph{TheEye} originates. Thus \emph{TheEye} is the universal browser of D machines. Both the \emph{dvt} and \emph{dnodes} connected to a \emph{dvt} will create and maintain their own \emph{TheEye} windows (with their owners identified in the window header). TheEye is operated through the mouse.

\begin{itemize}
\item The body of the window is divided into two pages. The left page shows permanent objects at the top followed by objects opened during use of TheEye. The right side lists the objects in the currently open object.

\item A field along the bottom of each page lets you scroll to the beginning or end of the page, up and down by one page, or up and down by one line. Click on the respective symbols.

\item Composite D objects are highlighted in both pages by backgrounds in different shades of green; simple D objects are displayed on a white background. File directories are listed on a purple background, and simple files on white background.

\item The left page shows in two columns the class of D object in an intuitive notation, or `DIR' for file directories. The second column shows the name of the object.

\item The right page shows in the left column the name of D objects and in the right column an intuitive description of the composite object or the value of a simple object. A filesystem is displayed in a single column of names, starting with directories (on a purple background) and followed by simple files. Each group of entries is alphabetically sorted.

\item A field along the top of the two pages is used to display information on the object (of either page) that you click on.

\item Control-clicking (or clicking the right mouse button) onto a composite D object or directory opens the contents of that object in the right page and appends the object to the left page (unless it already exists there). You can remove an item from the left page by shift-clicking on it.

\item Clicking the middle mouse button (or pressing the `superkey' and the left mouse button) selects an item. You can select only one item on the left page but many items on the right page. Selected items are highlighted in boldface and red (left page) or blue (right page).
\end{itemize}

Selected items can be inquired by your D code from \emph{TheEye} running from the same D machine using procedures that are loaded with the `startup' file into \emph{userdict}:\\

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
stringbuf index & faxLpage & stringbuf new\_index\\
stringbuf index & faxRpage & stringbuf new\_index\\
-- & getLpage & object true\\
   &          & false\\
-- & getRpage & [ D\_object\ldots ]\\
   &          & [ (path) [ (dir/filename)\ldots ]]\\
   &          & [ ]\\\\
\end{tabular}

\index{operator!faxLpage}
\index{operator!faxRpage}
\index{operator!getLpage}
\index{operator!getRpage}

\emph{faxLpage} or \emph{faxRpage} append to a byte array the string representation of a directory selected in the left page or of directories/files selected in the right page and update the buffer index to the position folowing the insertion. The string format is suitable for presenting arguments to shell commands. If nothing is selected or other types of object are selected, nothing is appended.

\emph{getLpage} returns a D object selected in the left page, or a string containing the path of a selected directory, and true, or simply false if no object is selected. \emph{getRpage} returns a list, which is empty if no object of the right page is selected. Selected D objects are returned as the value of the list. For selected directories or files a path string followed by a list of directory/filename strings is returned. 


 

\end{description}



\section{The D node (\emph{dnode})}\label{sec:dnode}

The \emph{dnode} is the specialization of D machine that provides you with computational workhorses. A \emph{dnode} is brought up by a shell command addressed to its host. The command is `dnode \#' where `\#' is a numeral that defines a communication port at which this `dnode' will listen for connection requests made via the network. (The specified port number will be used as an offset into the range of user-reserved ports, with no absolute warranty that your chosen port is free -- in rare instances you may have to choose a different port). The D machine of the \emph{dnode} is assigned minimal memory resources at this time. More memory can be allocated when you take control of the \emph{dnode} via the network.

 A \emph{dnode} is alerted (from a state of dormancy that uses no CPU cycles, or amidst the execution of D code) whenever a connection request is made to it, when an established connection is the receiving end of the \emph{send} operator executed in another D machine, or when an established \emph{X Window} connection requires attention. The code that schedules reactions to such events is buried in the mill of the \emph{dnode} (whereas in the \emph{dvt} these events are attended to by code written in D).

The \emph{dnode} mill tests for external conditions at intervals no greater than the time needed to go round 100 turns, which typically is a very small amount of time on a human scale. When an event is detected it is attended to, interrupting and suspending ongoing execution of D code.  You can protect a D context against such interruption by executing it using the \emph{locked} operator. A \emph{dvt} normally will pace the execution of your console phrases so that the \emph{dnodes} it supervises will not be interrupted. X window events do not pace their demands made to the \emph{dnode}, particularly when they arise from an impatient user. It is therefore a good idea to protect X window responses of a \emph{dnode} by \emph{lock}. The interruption of other D code by X window events is not a problem because X window response procedures leave behind the same D machine state that existed when the interrupt occured (please remember when you write your own).

The \emph{dnode} mill schedules D code in response to X window events in the same way as the \emph{dvt} operator \emph{nextevent} (see \ref{ssec:dvtops}). Thus the same D code can be used in \emph{dvt} and \emph{dnode} machines to service X windows. When a message is received from another D machine (that uses \emph{send}), the received object is made active and pushed on the execution stack. If this (composite) object is not a string, a \emph{save} is executed before the object is unfolded into the VM space (see also \ref{ssec:network}).

A \emph{dnode} is terminated by killing its process from the Linux shell that was used to bring it up. A \emph{dnode}, however, will typically not be killed after a job: it rather is put into a dormant state (using \emph{vmresize}) from which it can be recruited by a \emph{dvt} for new work. Thus \emph{dnodes} are used like servers.

Whenever the mill of the \emph{dnode} detects an error condition, it initiates a consistent error response. Four objects are pushed on the operand stack (from bottom to top): the host name of the \emph{dnode}, the port\# of the \emph{dnode}, a string (revealing the instance of discovery, like the operator name), and a numeral (coding for the type of the error). The active name `error' is pushed on the execution stack. `error' normally resolves to the operator \emph{error}. \emph{error} formulates an error message from the four objects pushed by the mill on the operand stack, sends the message to the current console, and invokes the operator \emph{halt}. \emph{halt} has two effects: (1) it pushes a copy of itself on the execution stack and (2) it directs the mill to submit phrases entered to the console to execution. Thus you can interact with the failed \emph{dnode}, e.g., inspect stack and object contents related to the error while the context that produced the error is suspended. If you can fix the error from the console, you may choose to execute \emph{continue}, which drops the execution stack below the topmost \emph{halt} object and thus resumes execution of the context suspended by that \emph{halt}. Alternatively, if you consider the problem fatal, you can terminate the flawed context by executing \emph{stop} (if you have set up a capsule with \emph{stopped}) or \emph{abort}. \emph{abort} drops all stacks to their floors (which on the dictionary stack leaves only \emph{systemdict} and \emph{userdict}). This cancels all activity in the \emph{dnode}, and returns the machine to a state in which it will respond to \emph{dnode} and X window connections.


\subsection{Operators for administrating  a \emph{dnode}}\label{ssec:opsdnode} 



\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
long\_array/null  & vmresize & bool\\
-- & halt & --\\
-- & continue & --\\
-- & stop & --\\
-- & abort & --\\
active\_obj & lock & --\\ 
-- & console & consolesocket/null\\
consolesocket/null & setconsole & --\\
string & toconsole & --\\
string & tostderr & --\\
hostname port\# sourcestr numerr & error & --\\
hostname port\# sourcestr numerr strbuf & errormessage & messstr\\
-- & getmyport & port\#\\
-- & Xwindows\_ & bool\\
(hostname:screen\#) & Xconnect & --\\
-- & Xdisconnect & -- \\
num & makethreads & --\\ 
-- & threads & num\\ 
active\_obj & serialize & --\\
-- & getlibdir & string\\
(path) (filename) & loadlib & lib\_dict\\
-- & hi & (library description)\\
-- & libnum & num\\
null/lib\_dict & nextlib & dict true\\
               &         & false\\\\
\end{tabular}

\index{operator!halt}
\index{operator!continue}
\index{operator!stop}
\index{operator!abort}
\index{operator!lock}
\index{operator!console}
\index{operator!setconsole}
\index{operator!toconsole}
\index{operator!tostderr}
\index{operator!error}
\index{operator!errormessage}
\index{operator!getmyport}
\index{operator!Xwindows\_}
\index{operator!Xconnect}
\index{operator!Xdisconnect}
\index{operator!makethreads}
\index{operator!threads}
\index{operator!serialize}
\index{operator!getlibdir}
\index{operator!loadlib}
\index{operator!hi}
\index{operator!libnum}
\index{operator!nextlib}


The \emph{dnode} lets you resize the VM and stack dimensions (\emph{vmresize}). When given the \emph{null} object as operand, \emph{vmresize} establishes a tiny VM, renders the \emph{dnode} dormant, and returns \emph{true}. When given the array of type long as operand, \emph{vmresize} establishes stack, VM, and \emph{userdict} dimensions as specified by the elements of the array, in the order: operand stack size (in objects), dictionary stack size, execution stack size, VM capacity (in MB), and userdict capacity (in associations). \emph{vmresize} indicates sucess/failure of the attempted memory allocation in \emph{bool}. When used with the array operand, \emph{vmresize} also sets the startup and working file directories back to the original working directory (from which the \emph{dnode} has been started up); lastly, \emph{vmresize} makes the \emph{dnode} interpret the file `startup\_dnode.d'. 

\emph{halt} suspends the execution of the object file currently held on the execution stack, while accepting and executing keyboard phrases from the console as well as any new objects placed on the execution stack via the console (e.g., to investigate a condition that produced execution of \emph{halt}). The suspension is removed (and the halted activity continued) by \emph{continue}. \emph{stop} or \emph{abort} also unblock the execution stack but drop the execution stack according to the latest context established by \emph{stopped} or to the bottom of the stack (\emph{abort} also clears operand and dictionary stacks, excluding the permanent dictionaries).

The \emph{dnode} normally reacts to any message received from another D machine within 100 turns of the mill. If a context is not to be interrupted this way, execute this context by making it the operand of \emph{lock}.

Several operators allow a \emph{dnode} to organize its interactions with the current console. \emph{console} inquires the socket currently subserving the console connection. It returns a socket-type \emph{null} object when a console is connected. Otherwise, a plain \emph{null} object is returned. \emph{setconsole} when given the object returned by \emph{console} directs \emph{toconsole} to the connected console or to 'stderr' of the \emph{dnode} host. \emph{toconsole} sends the contents of its string operand to the target chosen by \emph{setconsole}. \emph{tostderr} sends its string operand always to `stderr' of the host.

Upon detecting an error the \emph{dnode} mill invokes the active name \emph{error}, which it provides with four operands: hostname (string), port number (where the \emph{dnode} is listening for connection requests, actually an offset used when the \emph{dnode} is started from a shell), a string describing the source of the error, and a numeral specifying the nature of the error (positive: D machine error; negative: extrinsic operator error) on the operand stack. \emph{error} is by defaults associated with an operator that composes an error message from this information (in red) and sends it to the current console (or `stderr' by default). \emph{error} executes \emph{halt} after the error information has been successfully decoded; otherwise it executes \emph{abort}. \emph{errormessage}, rather than sending the error message to the console and interrupting execution in the \emph{dnode}, simply places the message into a string buffer and returns the message string (excluding color accents) for use by \emph{dnode} code itself..

\emph{Xwindows\_} inquires whether X Window capabilities have been compiled into this \emph{dnode} when the \emph{dnode} was built (by contrast, the common operator \emph{Xwindows} inquires whether a connection to an X Window system has been established so that you can make windows). An X Window connection is made by \emph{Xconnect} and broken by \emph{Xdisconnect}. See \ref{ssec:windows} for a description of the protocols by which the \emph{dvt} and \emph{dnode} cooperate to connect up to X windows.

The standard mathematical operators described in Chapter \ref{chap:machine}, and their `old-style' extensions described in \ref{ssec:oldstyle}, can be executed using multiple threads (processors) available in the host Linux box. \emph{makethreads} creates the number of threads specified by the numeral operand (1 through a maximal number, which currently is 8). When a \emph{dnode} is started up or when it is reduced to the dormant state by \emph{vmresize}, it operates with a single thread. It is possible, though unlikely to be helpful, to have more threads than physical processors in a Linux box. If you wish to execute a context in a single thread although multiple threads currently exist, submit the context to \emph{serialize}. \emph{threads} inquires the current number of created threads. The `new-style' (BLAS- and LAPACK-based) extensions of mathematical operators use an intrinsically set number of threads (fixed when the \emph{dnode} program is built for the particular host).

In addition to the intrinsic operators, \emph{dnodes} can make use of libraries of extrinsic operators (which typically support specific projects or experimental extensions of the D machine). \emph{getlibdir} inquires the directory path where libraries for the \emph{dnode} are stored (this path is established when the \emph{dnode} is started). \emph{loadlib} loads a library of operators; libraries are stored from the top of the VM downwards (competing for VM space with D objects, which are stored from bottom up) and returns the dictionary of the extrinsic operators contained in that library. \emph{loadlib} also merges the extrinsic operators of the library into \emph{systemdict} (with the exceptions of \emph{hi} and \emph{libnum}). You cannot load multiple copies of the same library. A library dictionary must include two obligatory operators with library-specific effects, \emph{hi} and \emph{libnum}. \emph{hi} returns a string specifying the library name and version. \emph{libnum} returns a dynamic index for this library (1,..., in the order of loading). You can inquire which libraries are currently loaded by \emph{nextlib}, which works similarly to \emph{nextobj}. Extrinsic operator libraries are not individually unloaded; they rather are altogether removed by \emph{vmresize}.


\subsection{More mathematical operators (old style)}\label{ssec:oldstyle}

These operators have been added to the D machine as ad hoc extensions. They fill demands made by specific applications and alleviate computational bottlenecks. The old style operators should be considered obsolete for most new work -- they have been or will be replaced by new-style versions that execute faster by better use of the hardware. These old-style operators describe two-dimensional arrays as lists of row arrays. New-style operators will consistently use different representations of multi-dimensional arrays.\\


\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
c a b & matmul & c\\
b a & mattranspose & b\\
c a b & matvecmul & c\\
array & integrateOH & array\\
array & integrateRS & array\\
y\_array dx\_array & integrateOHv\\
a b c r u & solvetridiag & u bool\\
bandlist bandrh main\_idx & solv\_bandmat & bool\\
a idx & decompLU  & d true\\
      &          & false\\
a idx b & backsubLU & b\\
a idx b & invertLU & b true\\
        &          & false\\
bandlist llist main\_idx idx & bandLU & bandlist llist main\_idx idx bool\\
bandlist llist main\_idx idx b & bandbs & b\\
array dir & complexFFT & array \\
array dir & realFFT & array\\
array dir & sineFFT & array\\\\
\end{tabular}

\index{operator!matmul}
\index{operator!mattranspose}
\index{operator!matvecmul}
\index{operator!integrateOH}
\index{operator!integrateRS}
\index{operator!integrateOHv}
\index{operator!solvetridiag}
\index{operator!solv\_bandmat}
\index{operator!decompLU}
\index{operator!backsubLU}
\index{operator!invertLU}
\index{operator!bandLU}
\index{operator!bandbs}
\index{operator!complexFFT}
\index{operator!realFFT}
\index{operator!sineFFT}




\emph{matmul} forms the matrix product $c = a \ast b$. Each matrix is described as a list of row arrays. The number of columns in \emph{a} must equal the number of rows in \emph{b}, and in \emph{c} the number of rows is the same as in \emph{a} and the number of columns is the same as in \emph{b}. All arrays are of type `/D'. \emph{mattranspose} transposes matrix \emph{a} and returns the result in matrix \emph{b} (the number of colums in \emph{a} equals the number of rows in \emph{b}, and the number of rows in \emph{a} equals the number of columns in \emph{b}). \emph{matvecmul} forms the product $c = a \ast b$ of the matrix \emph{a} with the column vector \emph{b} (given as an array) and returns the result in column vector \emph{c} (an array). (If matrix \emph{a} is $m \times n$ then \emph{b} is of dimension $n$ and \emph{c} is of dimension $n$). These matrix operators are multi-threaded (like the common mathematical operators).

\emph{integrateOH} forms a running sum of array elements in place using the one-half rule of integration (it takes arrays of all types and it returns twice the sum). \emph{integrateRS} forms the simple running sum of a `/D' type array. \emph{integrateOHv} takes any type of ordinate array and replaces its value by twice the running integral based on the one-half rule and the (generally non-uniform) abscissa intervals given in \emph{dx\_array} (which needs not match the type of \emph{y\_array}).

\emph{solvetridiag} takes five array operands all matching in type (either `/S' or `/D'): \emph{a} holds the subdiagonal matrix elements (the first element is ignored); \emph{b}, the diagonal elements; \emph{c}, the supradiagonal elements (the last element is ignored); \emph{r}, the right-hand sides; \emph{u} receives the solution of the tridiagonal linear equations system. The boolean indicates whether a valid solution was obtained.

\emph{solve\_bandmat} solves a linear equation system whose coefficients are a bandmatrix (based on \emph{bandet1} and \emph{bansol1} of Wilkinson/Reinsch I/6). The list \emph{bandlist} contains the coefficients as band arrays running parallel to the main diagonal and starting with the bottom-most diagonal; the index of the main diagonal array in \emph{bandlist} is given by the numeral \emph{main\_idx}. The first element of all band arrays corresponds to the first column of the matrix; positions falling outside the matrix must be filled by zeroes. \emph{bandrh} provides the right-hand side vector and is overwritten by the solution, whose validity is indicated by \emph{bool}. All arrays must have identical dimensions and type `/D'.

\emph{decompLU} performs the LU-decomposition of the matrix \emph{a} in place (given as a list of row arrays of type `/D'). The array \emph{idx} is of type `/X' and receives row permutation information to be used by \emph{backsubLU}. The returned numeral \emph{d} signals an even/odd number of permutations, and \emph{bool} signals a valid decomposition (or a singular matrix). \emph{backsubLU} computes the solution of a linear equation system using the LU-decomposed coefficient matrix \emph{a} with the permutation information \emph{idx} and a column vector of right-hand values \emph{b}, which is overwritten by the solution. \emph{invertLU} inverts the matrix \emph{a} and returns the inverse in matrix \emph{b} (internally using LU-decomposition and repeated backsubstitution); upon return, \emph{a} and array \emph{idx} contain the LU-decomposed matrix and row permutation information. A \emph{false} value of \emph{bool} signals singularity of the matrix.

\emph{bandLU} performs the LU-decomposition of a bandmatrix described by \emph{bandlist} and \emph{main\_idx} (see \emph{solve\_bandmat}) and returns the results in \emph{bandlist}, the bandmatrix buffer \emph{llist}, and the `/X' array \emph{idx} (see \emph{decompLU}). \emph{bool} is set false when singularity is discovered. For details see Press et al. 2.4. \emph{bandbs} computes a solution of the banded linear equation system for the right-hand vector given in array \emph{b}, which overwrites the vector.  

\emph{complexFFT} perform the FFT transform on an array of complex numbers (presented as alternating real and imaginary parts) in place, in the direction specified by \emph{dir} (1 - forward, -1 - inverse). The array is of type `/D' and its dimension is a power of two. \emph{realFFT} performs the forward transform on an array of real numbers, returning in the modified array: real parts of first and last spectral point, then alternating real and imaginary parts up to the Nyquist frequency. \emph{sineFFT} takes an array of real numbers and returns the real amplitudes of the sine spectrum and vice versa, as directed by \emph{dir}. Sequential application of the forward and reverse transforms reproduces the original array data in all forms of these FFT transforms.
   

       
\subsection{More mathematical operators (`blas' and `lp' styles)}

The operators of this group are based on matrix-algebra libraries that have been imported into the D machine (BLAS and LAPACK). These libraries accept matrices that are mapped in a variety of possible ways on memory for minimizing space demands while maintaining efficient access. We have implemented at this time only the general matrix. Maps for banded or other forms of sparse matrices could be implemented, but are not at this time. 

Although these linear-algebra operators use only vectors and matrices, we base their usage on a general map that projects a n-dimensional array onto a one-dimensional D array. The D array is dimensioned to hold (at least) the entire value of the n-dimensional array. The projection is separately described by a \emph{map}, which is in the form of a list of numerals\\

\begin{equation}
[ N N_{-1} N_{-2} \ldots N_{-n} ]
\end{equation}

\noindent where $N$ is the product of all dimensions, $N_{-1}$ the product of the $n-1$ dimensions excluding that of the highest-ranked dimension, and so on, down to and including $N_{-n}=1$ (the last element, although trivial, is necessary to consistently describe arrays of any number of dimensions including zero).

The form of the \emph{map} facilitates the mapping of elements of the next-lower array dimension, an operation that can be repeatedly applied down to the zero-order dimension if a simple element of the n-dimensional array is to be mapped. Since the data storage and the map describing it are separate, a D array can be used with multiple maps to create a variety of multi-dimensional arrays. Storage efficiency extends to the maps themselves because submaps created in the operation of accessing array elements are children objects of the full map rather than created new.\\

 \begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
[ dimensions ] & map & map\\
array map i & ss & subarray submap\\\\
\end{tabular}

\emph{map} converts a list of dimensions into a list holding the corresponding map (this is done in place). The dimensions are given in descending order; the lowest-ranked dimension is $1$.

The `subscript' operator has been given a short name, \emph{ss}. It returns the subarray of \emph{array} holding the highest-order $i$-th element of the multi-dimensional organization described by \emph{map}; it also returns the map of the subarray (which is the sublist of \emph{map} comprising the second and following elements of \emph{map}). Repeated use of \emph{ss} yields descriptions of lower- and lower-ranked elements of the multi-dimensional array.\\

\begin{tabular}{>{\sffamily}l}
[ 15 20 100 1 ] map dup /Amap name 0 get /d array /A name\\
A Amap 2 ss 9 ss 12 ss /amap name /a name\\\\
\end{tabular}

\noindent This example defines \emph{A} as a three-dimensional array and associates it with the map \emph{Amap}. Then performs three rounds of indexing to extract element $a_{2,9,12}$. This returns the map of a zero-dimensional array (as the D list [1]), and the zero-dimensional array containing the element (as a D array of length 1).

The `blas' and `lp' operators are executed using the cache facilities and processors in the host of the \emph{dnode}. They do not themselves distribute work among different hosts in a cluster.\\

\begin{tabular}{>{\sffamily\bfseries}l>{\sffamily}l}
matmul\_blas & $\alpha A^{t?} B^{t?} + \beta C \Rightarrow C $ \\
matvecmul\_blas & $\alpha A^{t?} x + \beta y \Rightarrow y$ \\
givens\_blas & compute Givens transformation \\
rotate\_blas & rotate\\
norm2\_blas & compute $\lVert x \rVert _2$\\
solvetriang\_blas & $A^{t?,-1} x \Rightarrow x$\\
decompLU\_blas & compute LU decomposition of $A$\\
backsubLU\_blas & compute LU backsubstitution with RHS\\
invertLU\_blas & compute inverse matrix following LU decomposition\\\\
\end{tabular}

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
C Cmap beta A Amap Atrans B Bmap Btrans alpha & matmul\_blas & C Cmap \\
y beta A Amap Atrans x alpha & matvecmul\_blas & y \\
x12 & givens\_blas & c s \\
c s x y & rotate\_blas & x y \\
x & norm2\_blas & num \\
x A Amap Atrans upper unit & solvetriang\_blas & x \\
A Amap pivot & decompLU\_lp & A Amap pivot true \\
                 &              & false\\
rhs A Amap pivot & backsubLU\_lp & rhs \\
A Amap pivot & invertLU\_lp & A Amap \\\\
\end{tabular}

\index{operator!matmul\_blas}
\index{operator!matvecmul\_blas}
\index{operator!givens\_blas}
\index{operator!rotate\_blas}
\index{operator!solvetriang\_blas}
\index{operator!norm2\_blas}
\index{operator!decompLU\_blas}
\index{operator!backsubLU\_blas}
\index{operator!invertLU\_blas}


The operands specified as capitalized names (e.g., \emph{A}) are /D arrays holding matrix data, described by a map (\emph{Amap}). A boolean (\emph{Atrans}) when true designates use of the transposed matrix rather than the matrix itself. Names in greek letters stand for /D scalars, and lower-case names are vectors (/D arrays), a /L array (\emph{pivot}), or /D scalars (\emph{c}, \emph{s}).

\emph{matmul\_blas} and \emph{matvecmul\_blas} perform generalized matrix-matrix or matrix-vector multiplications.

\emph{givens\_blas} computes the cosine (\emph{c}) and sine (\emph{s}) of a Givens transformation for a two-element vector \emph{h}, overwriting the vector. The plane Givens rotation on a pair of vectors \emph{x} and \emph{y} is effected in place by \emph{rotate\_blas}. 

\emph{solvetriang\_blas} solves the linear system with the triangular coefficient matrix \emph{A} where the boolean \emph{upper} indicates in which half of \emph{A} the triangular coefficients are located; the boolean \emph{unit} forces unit diagonal elements regardless of their values in \emph{A}. The vector \emph{x} contains the right hand side on input and the solution on output.

\emph{decompLU\_lp}  performs the LU-decomposition of matrix \emph{A} in place and inserts pivoting information into the vector \emph{pivot}. The decomposed matrix and pivoting are used by \emph{backsubLU\_lp} and \emph{invertLU\_lp} to generate a solution given for a right-hand-side vector (returning it in the vector), or to compute the inverse of the decomposed matrix in place.
 
 
Some of these operators return a boolean indicating success/failure of the attempted operation. Others (e.g., \emph{solvetriang\_blas}) can also fail, but, for reasons due to error-reporting quirks of the BLAS/LAPACK libraries, report an operator error via the \emph{error} mechanism of the D \emph{dnode}. An additional message detailing the error reported by the library is written to `stderr' (which you may wish to redirect to a log file for having an ear at the horse's mouth).

\subsection{Communicating with a cluster of \emph{dpawns}}

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
[ n1 dict1 n2 dict2 \ldots ] & makerthreads &  socket \\
null & makerthreads & -- \\
-- & rthreads & n \\
& checkrthreads & bool \\
idx active\_obj / string & rsend & -- \\\\
\end{tabular}

\index{operator!makerthreads}
\index{operator!rthreads}
\index{operator!checkrthreads}
\index{operator!rsends}

A cluster of \emph{dpawns} is created on the network by \emph{makerthreads} (make remote threads). The list argument of the operator generally has several to many paired entries. The first item of a pair gives the number of \emph{dpawns} to be brought up on the Linux box described by the second item, a dictionary. The dictionary is specific for the \emph{mpi} environment and provides, under \emph{mpi}-specific names a set of associated strings. \emph{makethreads} starts a child process of the \emph{dnode} called the `rook'. The rook mediates communications between the \emph{dnode} and \emph{dpawns} via \emph{mpi}. \emph{makerthreads} returns a socket (i.e. socket-type null object) for communication with the rook via the \emph{dnode} operator \emph{send} (see below). Messages sent by \emph{dpawns} to the \emph{dnode} will be addressed (via \emph{mpi}) to the rook, who communicates them to the \emph{dnode} through the socket established by \emph{makethreads}. A second usage of \emph{makerthreads}, taking a \emph{null} argument, kills the rook and the current \emph{dpawns} (it returns nothing). The rook is used to couple \emph{dnode} and \emph{dpawns} in this way in order to facilitate cleanup of failed \emph{dpawn} activities without compromising the continuity of the \emph{dnode} itself. 

\emph{rthreads} inquires the current number of \emph{dpawns}, independent of their functional states. \emph{checkrthreads} returns \emph{true} if the rook and all current \emph{dpawns} are responsive. If the rook is unresponsive, \emph{checkrthreads} eliminates all remote threads from the \emph{dnode} and returns \emph{false}. If one or more \emph{dpawns} are unresponsive, \emph{checkrthreads} simply returns \emph{false}.

You can send messages to the rook using \emph{send} with the socket number obtained from \emph{makerthreads}. The rook will broadcast such a message to all current \emph{dpawns}. The standard method for transmitting messages to \emph{dpawns}, however, is \emph{rsend}. To identify a particular \emph{dpawn} as target, specify its index \emph{idx} (automatically assigned by \emph{makerthreads} in the order of its argument list elements, starting from 0). To send to all current \emph{dpawns}, specify \emph{idx} as `undefined' (*). The active object or string will be submitted to the target \emph{dpawn(s)} for execution (see also \emph{send}).

\subsection{The PETSc procedure library of the \emph{dnode}}

\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
/name $<$d data$>$ & vec\_create & vecdict \\
/name $<$d data$>$ nrows ncols & dense\_mat\_create & matdict \\
/name $<$d data$>$ ??? & band\_mat\_create & matdict \\
/name $<$l irows$>$ $<$l icols$>$ $<$d data$>$ ncols & sparse\_mat\_create & matdict \\
vecdict & get\_vector & vecdict\\
matdict & get\_matrix & matdict\\
matdict vecdict & get\_matvecmul & vecdict\\
/name & ksp\_create & kspdict\\
vecdict & vec\_destroy & --\\
matdict & mat\_destroy & -- \\
kspdict & ksp\_destroy & --\\
kspdict Adict xdict bdict & ksp\_solve & --\\
kspdict xdict bdict & ksp\_resolve & --\\
kspdict Adict xdict bdict & get\_ksp\_solve & xdict\\
kspdict xdict bdict & get\_ksp\_resolve & xdict\\
\\\\
\end{tabular}

\index{operator!vec\_create}
\index{operator!mat\_create}
\index{operator!get\_vector}
\index{operator!get\_matrix}
\index{operator!get\_matvecmul}
\index{operator!ksp\_create}
\index{operator!vec\_destroy}
\index{operator!mat\_destroy}
\index{operator!ksp\_destroy}
\index{operator!ksp\_solve}
\index{operator!ksp\_resolve}
\index{operator!get\_ksp\_solve}
\index{operator!get\_ksp\_resolve}

These procedures internally communicate with a cluster of \emph{dpawns} where they initiate operations involving PETSc operators. The \emph{dnode} keeps records of the PETSc objects that are created in the form of dictionaries. Currently three varieties of PETSc object are represented this way:\\

\tablecaption{Vector dictionary}
\begin{supertabular}{>{\sffamily\bfseries}l>{\sffamily}l}
id & name\\
data & /d\_array\\\\
\end{supertabular}

The \emph{id} is the name used when creating the PETSc object. The \emph{data} array is the array provided when defining the object. Its value will be overwritten by PETSc results when PETSc procedures with the prefix `get' in their name are executed. 

\tablecaption{Matrix dictionary}
\begin{supertabular}{>{\sffamily\bfseries}l>{\sffamily}l}
id & name\\
data & /d\_array\\
irows & /l\_array\\
icols & /l\_array\\
nmax & \# of rows for last dpawn\\\\
\end{supertabular}

The arrays \emph{irows} and \emph{icols} locate the non-zero elements of the matrix, and \emph{data} holds the non-zero element values in the order in which their locations are described by \emph{irows} and \emph{icols}.  

\tablecaption{Krylov Space Solver dictionary}
\begin{supertabular}{>{\sffamily\bfseries}l>{\sffamily}l}
id & name\\
rtol & relative tolerance (1e-12)\\
atol & absolute tolerance (*)\\
dtol & divergence tolerance (1/rtol)\\
maxits & maximal number of iterations\\
pctype & type of preconditioner (*, i.e. JACOBI)\\
ksptype & type of ksp solver (*, i.e. GMRES)\\
kspparam & parameters for the ksp type (null)\\
pcparam & parameters for preconditioner type (null)\\\\
\end{supertabular}


\section{The D pawn (\emph{dpawn})}

The \emph{pawn} variety of D machine is created and killed by operators of a supervising \emph{dnode}. The \emph{dpawn} includes the general-purpose operators also available to a \emph{dnode}, uses a different set of communication operators based on the \emph{mpi} protocol, and taps the computational facilities of the PETSc library through D operators that map to PETSc library functions.

The operator set of a \emph{dpawn} differs from that of a \emph{dnode} in the following ways:

\begin{itemize}
\item The operators
\begin{tabular}{>{\sffamily\bfseries}l}
console\\
setconsole\\
getmyport \\
Xconnect\\
Xdisconnect\\

\end{tabular}
\end{itemize}


\subsection{Operators for administrating a \emph{dpawn}}

Most of these operators are synomymous with \emph{dnode} operators but have slightly different behaviors.
\begin{tabular}{>{\sffamily}r>{\sffamily\bfseries}l>{\sffamily}l}
long\_array/null  & vmresize & bool\\
-- & halt & --\\
-- & continue & --\\
-- & stop & --\\
-- & abort & --\\
active\_obj & lock & --\\ 
-- & console & consolesocket/null\\
consolesocket/null & setconsole & --\\
string & toconsole & --\\
string & tostderr & --\\
hostname port\# sourcestr numerr & error & --\\
hostname port\# sourcestr numerr strbuf & errormessage & messstr\\
-- & getmyport & port\#\\
-- & Xwindows\_ & bool\\
(hostname:screen\#) & Xconnect & --\\
-- & Xdisconnect & -- \\
num & makethreads & --\\ 
-- & threads & num\\ 
active\_obj & serialize & --\\
-- & getlibdir & string\\
(path) (filename) & loadlib & lib\_dict\\
-- & hi & (library description)\\
-- & libnum & num\\
null/lib\_dict & nextlib & dict true\\
               &         & false\\\\
\end{tabular}

\index{operator!halt}
\index{operator!continue}
\index{operator!stop}
\index{operator!abort}
\index{operator!lock}
\index{operator!console}
\index{operator!setconsole}
\index{operator!toconsole}
\index{operator!tostderr}
\index{operator!error}
\index{operator!errormessage}
\index{operator!getmyport}
\index{operator!Xwindows\_}
\index{operator!Xconnect}
\index{operator!Xdisconnect}
\index{operator!makethreads}
\index{operator!threads}
\index{operator!serialize}
\index{operator!getlibdir}
\index{operator!loadlib}
\index{operator!hi}
\index{operator!libnum}
\index{operator!nextlib}

\subsection{Operators for communicating via \emph{mpi}}
    

