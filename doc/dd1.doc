

ÇhÄD MANUAL 6/27/95Ç| 4 ls
ÇhÄCONTENTS


ÇhÄCHAPTER Å1Ç| mÄINTRODUCTIONÇ| 1 ls

Ç            mÄ1.1 A Computer of ObjectsÇ| 1 ls
Ç            mÄ1.2 Talking in ObjectsÇ| 1 ls

ÇhÄCHAPTER Å2Ç| mÄTHE MACHINEÇ| 1 ls

Ç            mÄ2.1 The ObjectsÇ| 1 ls 
Ç            mÄ2.2 Where Objects LiveÇ| 1 ls
Ç            mÄ2.3 The Text Representation of ObjectsÇ| 1 ls
Ç            mÄ2.4 The MillÇ| 1 ls
Ä            ÇmÄ2.5 The Virtual TerminalÇ| 1 ls

ÇhÄCHAPTER Å3Ç| mÄTHE OPERATORSÇ| 1 ls
Ç           
Ç            mÄ3.1 ToolboxesÇ| 1 ls
Ç            mÄ3.2 Operator LexiconÇ| 1 ls

ÇNewPage

ÇhÄCHAPTER Å1Ç| mÄINTRODUCTIONÇ| 1 ls

ÇpÄ'D' is the name of a virtual computer and also names the native language of Äthis machine. The virtual D computer requires a physical host to operate, but Äcreates a private computing environment that isolates you from many, albeit not Äall, idiosyncrasies of the host.Ç|

ÇpÄD is not a new concept, it is a combination of long-known concepts that the 
Äauthor found useful in organizing his own information shop. It has been Ädistilled from experiences made over 25 years, leaving behind as superfluous Ämuch more than what was preserved as worthy.Ç|Ä 

ÇpÄThree concepts are essential. D encodes information in a form that allows Ärecognition independent of  context.  D makes no principal distinction between Äinformation that serves as 'datum' and information that serves as 'instruction'.Ä  D organizes all  composite information linearly.Ç|

ÇpÄThese  principles  are natural as they underlie also the chemistry  of  a 
Äliving  cell.  The  molecules of a cell can recognize  one another;  they 
Ätravel on their own,  yet find their targets.  Substrates and enzymes are 
Ämade of one set of atoms or molecular  sub-assemblies.  Three-dimensional 
Äproteins are built as linear chains of aminoacids.  The cell develops  in 
Äspace  and  time using genetic information encoded in  linear  arrays  of 
Änucleotides.Ç|

ÇpÄPerhaps, D is a more natural way of using a computer.Ç|

ÇcÅ1.1 A computer of objectsÇ|

ÇpÄThe  D computer works with quanta of information,  which we  shall  call 
Ä'objects'  (adding  a usage to an existing term,  rather  than  inventing 
Äsomething like 'quarks').  An object comprises a ÅvalueÄ (the essence, from 
Äyour   point  of  view)  and  a  ÅdescriptionÄ  that  carries  a   thorough 
Äspecification (transparently used by the machine,  but also accessible to 
Äyou).  Once  information has been organized in the form of  objects,  the Ämachine can work with it in an abstract way,  because it knows the  physical 
Äimplications and 'understands' the objects that it manipulates as well as 
Äyou do.  Conversely, thinking in D objects is not a tour de force for the 
Ähuman mind,  because these objects are familiar abstractions. Objects provide  aÄ common ground between person and machine.Ç|
Ä 
ÇpÄD  sets out from a few varieties ofÑ Åsimple  objectÄ.  Among  them,  ÑnameÄ, 
ÑnumeralÄ,  andÑ  operatorÄ are the workhorses.  Simple objects serve as  the 
Äbuilding  material  of Åcomposite objectsÄ.  There  are  several  composite 
Ävarieties,  such as the ÑlistÄ  and  the  ÑdictionaryÄ. 
ÄComposite objects Äthemselves Äcan become elements of higher composite objects, Äand so 
Äon.  There  is no logical limit to the internal complexity  of  composite 
Äobjects that you create.  With regard to quantity, anything from a single 
Ämeasured sample to accumulated experimental results of several years  can 
Äbecome an object to the D machine.Ç|

ÇpÄObjects serve as the elements of data as well as of  instructions:  they 
Äcan be used as operands or can be executed with specific effects. 'Datum' 
Äor 'instruction' are changeable attributes,  not fundamental  properties. 
ÄBecause  one  and the same form fits datum  and  instruction,  these  two 
Ävarieties of information are readily combined into composite objects that 
Ärepresent  both Åpassive and active propertiesÄ of things that you wish  to 
Ämodel in the computer.Ç|

ÇpÄD  retrieves  objects by ÅassociationÄ.  Collections of objects  that  are 
Ämutually associated in some sense can be created in the form of composite 
Äobjects.  Composite  objects that hold associations of objects are  ÅlistsÄ 
Äand  ÅdictionariesÄ.  Lists  hold  an array of objects  that  are  accessed 
Ärandomly or sequentially through a numerical index.  Dictionaries hold an 
Äarray of paired entries, of which the first is a name, and the second any 
Äobject that is associated with the name.  References within  dictionaries 
Äare made by name.  Lists and dictionaries are dynamic:  entries are  made 
Äand re-defined at any time.Ç|

ÇpÄAlbeit  a logical entity,  the value and the description of a  composite 
Äobject are physically distinct.  When you logically designate a composite 
Äobject,  you  physically  refer  to  a  description  of  the  object.  By 
Äphysically  duplicating  only  the description  of  a  composite  object, 
Ämultiple   logical  copies  of  the  composite  object  can  be   created 
Äeconomically and used in multiple associations.Ç|

ÄD  lets you create also composite objects that comprise a subset  of  the 
Ävalue of a parent composite object. These Åchildren objectsÄ do not receive 
Äa duplicate of the parent's value:  they share one and the same original. 
ÄChildren  objects are combined with other objects (including children  of 
Äother composite objects) into new composite objects in unlimited cut-and-
Äpaste operations.  Altogether,  these techniques,  transparently based on 
Äobject  descriptions  as the representatives of values,  let  you  create 
Ämultiple specific access schemes to a body of information.Ç|

ÇpÄThe  most  common method for the retrieval of a D object is  through  an 
Äassociated  name,  a time-honoured practice.  Upon every reference  to  a 
Äname,  however,  the D machine determines the Åcurrently associated objectÄ 
Äthrough  an ad hoc search of the vocabulary in use.  This  vocabulary  is 
Äsubject to change. Names can be defined or re-defined in each dictionary, 
Äand  dictionaries as a whole can be moved in and out of  use.  Thus,  the 
Ämachine  is  capable  of  'learning' new  terms  or  'switching'  between 
Äalternate  definitions of terms.  The swapping of dictionaries gives  the 
Ämachine a touch of intelligence,  in that it can dynamically relate  term 
Äand context.  Furthermore,  it enables the machine to attend a variety of 
Ätasks  randomly  without becoming confused,  and enables it  to  securely 
Äcontrol  the  access to information.  The instructions to  control  these 
Äcapabilities are very simple.Ç|Ä  

ÇpÄD  uses  the  object form to organize information  bothÅ  internallyÄ  (in 
Ämemory) and ÅexternallyÄ (e.g.,  in disk mass storage).  This has two major 
Äbenefits.  First,  information is exchanged efficiently between  internal 
Äand external sites,  because the object value is stored coherently and is 
Ämoved  as a literal,  bit-for-bit copy (a small set of special  operators 
Äsuffices  to  move object values or their  subsets).  Second,  since  the 
Ädescription and value of a composite object are physically separate, operations Äthat do not involve the value can be performed solely with the description  in 
Ähand.  Thus  you  can build lists and dictionaries  of  external  logical 
Äobjects  in internal memory and store these on arbitrary media.  You  can 
Äbuild  information schemes that involve pieces stored in  many  different 
Ämedia.  Conversely,  you  can  reference one and the same value  in  many 
Ädifferent ways and contexts. No new rules or tricks are needed here: it is Åone ÅgameÄ of objectsÇ|

ÇpÄThe  D  machine  takes  direct control  of  external  object  media  and 
Äorganizes  these private media separately and in parallel to  the  host's 
Äfile systems (which you can access as well).Ç|

ÇpÄA  D  machine at work Åfeeds on objectsÄ,  consuming them one at  a  time. 
ÄEvery received object is dealt with immediately according to the rules of 
Äthe  Ñreverse  Polish  notationÄ (RPN,  as  familiar  from  Hewlett-Packard 
Äcalculators). A consumed object either is transferred to the operand stack 
Äto serve as operand, or initiates one or several operations. An operation 
Äconsumes some or all of the objects accumulated on the operand stack, and 
Äin turn may push result objects on the stack,  ready for being  processed 
Äby  subsequent operations.  By an ironclad design  rule,  operations  are 
Äunaware  of  their  precursors  or  followers  (that  is  your  exclusive 
Äprivilege).  Information  passed  from one operation to  another  by  the 
Äimplicit  use of the stack needs not be specified.  This keeps  the  code 
Älean and the focus on the action.  Perhaps the most important windfall of 
ÄRPN is that for any single object that you feed the machine you know  the 
Äexact  consequences and the exact instant when these occur.  No high-level Äsyntax can substitute for this knowledge.Ç|

ÇpÄThe  D  machine  accepts  objects in  two  forms:  ÅtextÄ  or  ÅbinaryÄ.  It 
Ärecognizes automatically which form is being presented (by inspecting the 
Ädescription of the composite source object).  When working from  text,  D 
Äautomatically   translates  text  tokens  into  binary   objects   before 
Äsubmitting  them to its internal mill of binaries.  This front end  makes 
Äobsolete  intermediaries  such  as  command  line   interpreters,   batch 
Äprocessors,  compilers, linkers, or loaders of executable files, together 
Äwith their many idioms.  Conversely,  binary objects are easily converted 
Äinto their text form and saved in a file. The contents of such files, for 
Äexample,  may  be  made  available  to  PostScript  devices  for  printed 
Ärepresentations  (PostScript and D share compatible text  notations).  In 
Äeffect, one Ñlingua francaÄ, D, serves to concisely express and communicate 
Äall kinds of datum or instruction.Ç|

ÇpÄAs a language of action,  D thrives on verbs,  here called ÑoperatorsÄ and 
ÑproceduresÄ. ÅOperatorsÄ invoke instruction modules directly executed by the 
Ähost  machine.  Some  operators  do jobs as small as  those  of  hardware 
Äinstructions of the host machine,  but the majority provide services that 
Ärequire  many host instructions.  Polymorphic D operators accept  diverse 
Äkinds of object to work on,  and tune themselves using information in the 
Äobject  descriptions.   For  instance,   the  'add'  operator  takes  any 
Äcombination of numeral types,  performs the addition in several  possible 
Äforms of arithmetic or precision,  and combines scalar with scalar, array 
Äwith  array,  or  scalar with array.  Old and new  undefined  values  are 
Ärecognized  and  propagated into the results without  need  for  explicit 
Äexception handling.  Your plan can be formulated in D without  attracting 
Äthe usual cloud of confusing, albeit necessary, second thoughts.Ç|

ÇpÄVersatile  operators keep D programs concise and comfortable  to  write. 
ÄFurthermore,  D  lets you define new operators in the form of  Åprocedures 
Ä(lists  of  objects  to be executed).  The  overhead  of  composition  is 
Äminimal.  In the text representation, a pair of {} brackets wrap a set of 
Äobjects  that constitute the procedure;  a subsequent  operation  usually 
Ägives the new thing a name.  Procedures being executed can use the  stack 
Äfor  their operands and results as do the operators.  Thus,  there is  no 
Äformal  difference  between  references to an operator  and  those  to  a 
Äprocedure.   This  continuity  fosters  the  fine-grain  decomposition  of 
Äinformation,  and,  together with explicit and well-thought names,  produces 
Ästructured code that is intelligible to person and machine.Ç|

ÇpÄWhile executing objects,  the machineÅ controls its own operationÄ like  a 
Äphysical computer that executes its native code.  Hence,  D can implement 
Äfunctions of operating systems, shells, graphical interfaces, debuggers, menus, Ätasks, or  whatever layers of instruction are desirable. The capacity of Äself-organization flows from a capacity sheepishly excluded by conventional Äprogramming models: data  and instructions are formed from one and the same set,Ä  objects. The D  machine 
Äcan compute 'instructions' like it  computes 'data'.  This capacity is  a 
Ätrademark  of living things as well as of human-made systems designed  to 
Äexplore  'artificial intelligence'.  No matter what your  ambitions  are: 
Äcomputed  instructions  offer  solid,   elegant,   and  sometimes  unique 
Äsolutions  for problems that span the range from particularly  boring  to 
Ähair  raising.  Among all dimensions opened by D,  this is one of  the 
Ämost exciting and most rewarding to explore. If your breathing space in the Äfourth dimension is collapsing, try this one!Ç|Ä 

ÇpÄDefining  a  problem in D involves developing a specific  vocabulary  of 
Äobjects,  and  in this sense a new language.  D may be paraphrased  asÑ  Åa 
Ålanguage to make languagesÄ.  Diversified vocabularies are one strength of 
Äthe D machine; a strong stomach is another. Almost never will you have to 
Äwrite  an  ad hoc interpreter of your new idiom,  because  the  secondary 
Älanguage code can go right through the existing D  mill. D code resembles 
Äthe vectors constructed by a molecular biologist: it achieves the desired 
Äproduct not by creating a new,  but by exploiting an existing,  machinery 
Äfor expression.Ç|
Ä  
ÇpÄD likely differs from most 'programming' techniques you have met.  There 
ÄisÅ no 'high-level' syntaxÄ to learn,  you learn  a minimal syntax and then 
Ämany  ÑverbsÄ  (operators).  You  can work through  these  by  installment, 
Äignoring what you do not need,  gearing up as you go, and winding down as 
Äyour project matures.  Re-learning is eased by the extreme consistency of 
Äform.  D code flows smoothly,  because there are few computer expletives; 
Äsyntactical  errors become a rare mishap.  Underneath its  easy  manners, 
Ähowever, the D machine hides a Laconian.Ç|

ÇpÄD isÅ robustÄ, because it is simple and because it works with objects that 
Äinclude a thorough specification.  Operators,  for example,  will  choose 
Äeither  to  adapt to their operand objects or to reject such  objects  as 
Änon-suitable  for  the  attempted  use  (this  summarizes  most  of   the 
Äsafeguards necessary to let the machine steer clear of crashes). An  able 
Ädefender of its own integrity, the machine abstains from questioning your 
Ädesigns in terms of selfish syntactical rules. Instead, D simply respects 
Äyou:  it  accepts  every  word that you present and  executes  this  word 
ÅverbatimÄ.  This  may  remind you of the ways of a fool,  but it  is  also 
Äreminiscent  of the method of Socrates:  the machine dares you to  follow 
Äthrough  what  you conceive.  You are rewarded by  solutions  that  work, 
Äconvince, and are delivered with egg-laying promptness.Ç|

Ä 


ÇcÅ1.2 Talking in ObjectsÇ|

ÇpÄThe widely used languages,  Fortran,  Basic,  C, or Pascal, use a multi-
Älevel syntax: tokens form expressions, expressions statements, statements 
Äfunctions,  and  functions  programs.  D  uses a syntax  of  objects  and 
Ärequires no rules of composition beyond those of constructing objects.Ç|

ÇpÄYou may wonder how D organizes objects into instructions.  A comparative 
Älook  at  phrases  in  C and D shows that the  method  of  D  is  simple, 
Äconsistent, and very generally useful.Ç|

Ç1 lsÄ Ç/tabs [[108 1] [ textwidth 108 sub 1 ] ] def

ÇnÄThe C statement:Ç| tÖy = 9.8 * exp(-x/tau);Ç| 1 ls

ÇnÄreads in D:Ç| tÖ/y 9.8x neg tau div exp mul defÇ|

ÇpÄThe  C code assigns the result of an algebraic expression to a  variable 
Äand neatly concludes the phrase with a semicolon.  The D code is an open-
Äended  string of objects.  Like you walk by putting one foot in front  of 
Äthe other,  the D machine computes by executing one object in the  string 
Äafter another:Ç|

Ç/paragraphindent -48 defÄ Ç/paragraphspace 20 def

ÇpÖ/yÄ -- pushes a name object of value 'y' onto the operand stack
Ä         (the '/' gives the name the ÑpassiveÄ attribute, designating
Ä          it for use as a literal)Ç| Ä 
ÇpÖ9.8Ä -- pushes  a  numeral  object of value '9.8' onto  the  operand  stack 
Ä       (thereby 'executing' the numeral)Ç|
ÇpÖxÄ -- looks up the object associated with the name 'x' (a numeral in  our 
Ä      case) and pushes a copy of it onto the operand stack (a name without  the 
Ä      '/' prefix receives the ÑactiveÄ attribute, designating it for use in 
Ä      a dictionary  search)Ç|
ÇpÖnegÄ -- looks up the object associated with the name 'neg',  which is an 
Ä         operator;  invokes the operator,  which negates the value of the 
Ä         top element of the operand stack (the copy of x)Ç| 
ÇpÖtauÄ -- pushes the object associated with 'tau' onto the operand stack  (you 
Ä         got the idea)Ç|
ÇpÖdivÄ -- divides the next-to-top element of the operand stack by the  top 
Ä         element, removes the divisor and divident from the stack, pushes 
Ä         the quotientÇ| 
ÇpÖexpÄ -- replaces the top element of the stack by its exponentialÇ| 1 ls
ÇpÖmulÄ -- multiplies  the  top two elements of the operand stack  (9.8 and 
Ä         exponential) by each other, replaces the factors by the productÇ| 
ÇpÖdefÄ -- this  name resolves to an essential operator,  which  associates 
Ä         the  object at the top of the stack (the numeral result  of  the 
Ä         expression) with the name ('y',  now the next-to-top element  of 
Ä         the stack), and places the new association pair into the current 
Ä         dictionary for future reference.Ç|

Ç/paragraphspace 30 def /paragraphindent 0 def

ÇpÄD  code  thus  builds  on operands and operators  held  together  by  an 
Äinvisible  glue,  the Ñreverse Polish notationÄ.  The rule is  minimal:  an 
Äoperator  expects that the operand stack contain a sufficient  number  of 
Äsuitable operands.  Beyond that, there are very few formal constraints on 
Äthe order or choice of objects that form a D script.Ç|

ÇpÄThe C code has the appeal of high-school algebra:  sort of  familiar.  D 
Äresorts  to  the more elegant and general  concept  of  operators.  Since 
Äelegance can be measured by the frugality of means,  let's count:  the  C 
Äexample needs twelve tokens,  two more than D; C uses six kinds of token, 
ÄD three. The advantage is on D, albeit small. We will note below that the 
Ädistance grows steeply even with mild increases of difficulty.  D travels 
Äon foot where C gets only with heavy gear.Ç|

ÇpÄThe C code in this example is shorter to type than the D  code,  because 
Äit  employs  special characters as shorthands.  Good  D  style  generally 
Äabstains  from  shorthand in order to keep things  clear  and  consistent 
Ä(shorthand  systems have a knack to befuddle their inventors).  You  will 
Äsee  below that D lets you spell out in full what is needed for  clarity, 
Äand nevertheless allows you to be more concise than in shorthand C code.Ç|

ÇpÄHaving  looked  at algebra,  we may ask:  how does D express  a  control 
Ästatement?  For  instance,  C implements a 'for' loop through  a  special 
Ägrammatical  construct called a 'for-statement'.  D builds a  'for'  loop 
Äthrough an operator and does so without grammatical ado.  Thus,  to  form 
Äthe sum of the integers between 0 and 100 by brute force,  you may writeÇ|Ä 
Ç1 ls

Ç/tabs [ [36 1][ textwidth 108 sub 1 ] [72 2]] def
ÇnÄIn C:Ç| tÖfor (k=sum=0; k<=100; k++)  sum += k;Ç| 1 ls

ÇnÄIn D:Ç| tÖ/sum 0   0 1 100 { add } for   defÇ|

ÇpÄThe  'sum'  is  defined  as the effect of the  'for'  operator  and  its 
Äoperands  (i.e.  0 1 100 { add } ) onto a value seeded on the  stack,  0. 
Ä'for'  executes  the loop body (the procedure,  { add } ) once  for  each 
Ävalue from the initial 0,  by steps of 1,  to the limit 100.  The current 
Äcount is passed to the procedure by pushing it on the operand stack.  The 
Äprocedure in our example contains a single operator,  'add',  which  adds 
Äthe current count to the running sum maintained on the stack.Ç|

ÇpÄThe C 'for' statement is compact,  as it bristles of shorthands.  Yet it 
Äneeds  20 tokens,  whereas the D statement has 11.  The C code uses  nine 
Ädifferent kinds of token, the D code, four.Ç|

ÇpÄTo prime an array x of n real numbers with zeroes you may writeÇ| 1 ls

ÇnÄIn C:Ç| tÖfor (k=0; k<n; k++) x[k] = 0.0;Ç| tÄ(20 tokens)Ç| 1 ls

ÇnÄIn D:Ç| tÖ0.0 x copy Ç| tÄ(3 tokens)Ç|

ÇpÄThere is no need not look for the champion here.  D uses an  intelligent 
Äoperator that determines automatically the dimension of the object it  is 
Äworking  with  and  controls  an internal  loop  accordingly.  In  the  C 
Äconstruct,  you are responsible for the count,  and an error in the limit 
Ävariable can cause a crash;  you also have to reckon with C's expletives, 
Äwhich please a compiler but hardly a programmer.Ç|

ÇpÄThis example raises the question of how fast the intelligent D operators 
Äexecute.  Obviously,  they  have to do a lot of object checking.  On  the 
Äother hand,  D operators absorb the innermost loop when working on  whole 
Äcomposite  objects  such  as arrays,  and then execute as  fast  as  host 
Ämachine  code.  Only small-grain number crunching will  be  significantly 
Äslower.  But does this really matter?  Science is change, and the economy 
Äof   instructing  a  computer  for  a  new  twist  of  science   precedes 
Äconsiderations regarding the speed of computation (consider:  programming 
Äcosts  ÅyourÄ prime time,  whereas execution ties up a computer  and,  when 
Änumerically extensive,  often can use 24 hours a day). Furthermore, after 
Äa routine has evolved,  it always can be speeded by replacing bottlenecks 
Äby fast ad hoc operators.  This still is by far less work than developing 
Äthe entire project in a language like C.Ç|

ÇpÄMoving up in syntax, let's cast the exponential expression from before as 
Äa  function,  such that x and tau are submitted and the expression  value 
Äreturned. In C, this reads:Ç|

Ç/tabs [ [36 1] [textwidth 36 72 add sub 1][ 72 2 ]] def 1 ls
ÇnÄIn C:Ç| tÖfloat myexp(tau,x)Ç| tÄ                          (27 tokens)Ç|
ÇnÄ Ç| tÖfloat tau,x;Ç|
ÇnÄ Ç| tÖ{Ç|
ÇnÄ Ç| tÖreturn(9.8 * exp(-x/tau));Ç|
ÇnÄ Ç| tÖ}Ç| 1 ls

ÇnÄIn D:Ç| tÖ/myexp { Ç| tÄ                                 (10 tokens)Ç|
ÇnÄ Ç| t Ödiv neg exp 9.8 mulÇ|
ÇnÄ Ç| tÖ } def Ç|

ÇpÄYou associate the name 'myexp' with a procedure,  whose body is  enclosed 
Äbetween {}.  When you enter this code,  the objects in the procedure body 
Äare not executed: they are translated into their internal form and stored 
Äfor later invokation (the D analog of 'compilation').Ç|

ÇpÄInvokations of this function/procedure could read:Ç| 1 ls
Ä       
ÇnÄIn C:Ç| tÖy = myexp(x,tau);Ç| 1 ls
ÇnÄIn D:Ç| tÖ/y x tau myexp defÇ|

ÇpÄBoth  languages provide the means for partitioning code  into  ràe-uÄsable 
Ätools  (functions in C,  procedures in D).  Both use a stack to  transfer 
Äarguments.  C  functions can take many arguments and return at  most  one 
Ävalue,  whereas  D procedures can return more than one value (since  they 
Äcommunicate their results through the stack).Ç|

ÇpÄAre things in C and D really that similar? They are not:Ç|

ÇpÄ- The C function takes exactly the kind of argument it is declared  for. 
ÄIt  produces  potentially fatal nonsense if fed other  numeral  types  of 
Äarguments (like 'short' instead of 'float').  Furthermore, it needs to be 
Äinvoked explicitly for each individual array element when the exponential 
Äof  an  array  is to be calculated.  The D function  (and  the  contained 
Äoperators)  adapt  to varying types of numeral,  and  they  automatically 
Äexpand the operations to all elements of array  arguments.  Generally,  D 
Äprocedures can take, work on, and return composite objects.Ç|

ÇpÄ-  The  compiled  C function is linked  into  a  program.  The  function 
Äthenceforth stays as is,  subserves the program,  and can be invoked only 
Äfrom  the  context of the program.  The  D  procedure,  in  contrast,  is 
Äassimilated as an individual object into the machine.  Any D code already 
Äpresent, passing through, or assimilated thereafter can use it or be used 
Äby it.  The gentleness of D in assimilating (procedure or other)  objects 
Ägoes an essential notch further than even an 'incremental compiler' would 
Ägo: the name-object associations are not finalized in the form of address 
Älinks.  Associations  remain a matter of make and break  (even  intrinsic 
Äoperators do not 'own' their names;  hence, there are no 'reserved words' 
Äin  D and, conversely, you can substitute or expand system operators by Äprocedures that you associate with the former operator names).  In  effect,  Äwhereas the elements of a C program are  rigid  and 
Äwelded together, those of a D process remain ductile and able to form new 
Äconnections.Ç|

ÇpÄAlthough  D  objects  can  assemble  ad  hoc  in  the   machine,   their 
Ärelationships are tightly controllable.  The method is encapsulation. The 
Äfollowing code invokes a procedure twice,  each time providing it with  a 
Ädifferent context by executing it with different current dictionaries:Ç| 1 
Çls


ÇnÄ Ç| tÖdict_A begin that_procedure endÇ|
ÇnÄ Ç| tÖdict_B begin that_procedure endÇ|

ÇpÑThat_procedureÄ  can retrieve objects from all dictionaries currently  on 
Äthe dictionary stack.  If it defines or re-defines objects in the  course 
Äof  its execution,  these changes are made exclusively in the  dictionary 
Äplaced  on  top of the dictionary stack through the ÑbeginÄ  operator  (and 
Älater removed by Ñend)Ä;  this holds true for the entire dynamic context of 
Ñthat_procedureÄ.  The current dictionary, hence, provides a semi-permeable 
Äcapsule around the procedure.  The invoking program can put objects to be 
Äused  by the procedure into the capsule,  read results deposited  in  the 
Äcapsule,  or  may  leave  the capsule alone as a  private  space  of  the 
Äprocedure.  Since any number of capsules can be maintained, the procedure 
Äcan be used randomly in varying contexts without a risk of confusion.Ç|Ä 

ÇpÄEncapsulation is a responsibility of the caller. This greatly simplifies 
Äthe  writing of procedures,  because no attention needs be given  to  the 
Äscope  of  their object names:  you can write along as if  there  was  no 
Äpossibility  of  interference  with other code.  This  technique  is  the 
Äopposite  to C's approach to control access,  where the lexical scope  is 
Ädetermined by declarations contained in each function.  The encapsulation 
Ätechnique is used by operating systems, to isolate the system itself from 
Äuser  processes and one user process from another.  It is the  method  of 
Ächoice in all systems that do not Ña prioriÄ restrict the players.Ç|

ÇpÄD  extends encapsulation to the flow of control.  You can  execute  code 
Äwith  the  provision that control can return immediately to  the  calling 
Äcode,  cutting through a nest of pending procedures or loops. Consider as 
Äan example:Ç| 1 ls

ÇnÄ Ç| tÖ{ my_program } stopped Ç|

ÇpÄThe  ÑstoppedÄ operator invokes the procedure operand,  which  contains  a 
Äreference  to a user program.  If Ñmy_programÄ executes the  ÑstopÄ  operator 
Äupon  recognizing a severe problem anywhere within its  dynamic  context, 
Äexecution resumes with the object following ÑstoppedÄ (a boolean object  is 
Äreturned  on  the operand stack to inform the caller about  the  kind  of 
Ätermination).  D provides a hierarchy of such escape mechanisms by  which 
Äunpredicted events trigger orderly retreats to prepared  positions.  Most 
Äprocedures can be written on the assumption that things go well,  because 
Äsurprises are passed from their discoverer straight to the supervisor  of 
Äthe  context  rather than bubbling back through a chain  of  command  and 
Ärequiring attention at every intermediate level.Ç|

ÇpÄWe now turn to composite objects.  Such objects (and nests ÄthereÄof)  are 
Änot  declared like a C function or structure.  D operators let you  ÑbuildÄ 
Äsuch  objects  from  constituent  objects,   or,  conversely,  ÑdissectÄ  a 
Äcomposite  object  into smaller entities for specific  uses.  D  objects, 
Ähence, are inherently dynamic.Ç|

ÇpÄThe following examples produce some composite objects:Ç| 1 ls


ÇnÄ1:Ç| tÖ100 (w) arrayÇ| 
ÇnÄ2:Ç| tÖ(This is a string)Ç|
ÇnÄ3:Ç| tÖ<s 120. 40. 28. 1e5 29.546 1 -99>Ç|
ÇnÄ4:Ç| tÖ[ a b 100 (HOHOHO) ]Ç|
ÇnÄ5:Ç| tÖ12 dict  13 listÇ|
ÇnÄ6:Ç| tÖ{ (\nHonni soit qui mal y pense) toconsole }Ç|

ÇpÄThe objects are:  (1) an array of 100 16-bit integers holding unpredictable Äinitial values;  (2)  an  initialized string  (i.e.  array  of  byte 
Äintegers);  (3)  an initialized array of single-precision  floating-point 
Änumbers;  (4)  a  list of the objects included between  brackets;  (5)  a 
Ävirgin  dictionary  for  up to 12  associations,  and  a  list  initially 
Äcontaining 13 null objects;  (6) a procedure that when executed writes  a 
Äbonmot on the console screen.  The composite objects 
Äthus created populate the top 7 positions of the operand stack.Ç|

ÇpÄComposite  D objects include arrays (a set of numeral values that  share 
Äthe  same  characteristics),  and  lists (a set  of  arbitrary  objects). 
ÄLists and arrays can be created in a fashion that defines all elements of 
Ätheir value,  or with initially undefined or null elements.  Elements  of 
Äthese objects are accessed through an index. Alternatively, a composite D 
Äobject  is  built  in the form of a dictionary,  where  each  element  is 
Äassociated with a name for reference.  Dictionaries are created empty and 
Äare filled explicitly by subsequent operations.Ç|

ÇpÄAs  an example of composite object dynamics in D,  consider a family  of 
Ärecorded current sweeps from a voltage clamp experiment.  A subsection of 
Äeach  sweep  represents a 'tail' current.  Assume that in one  sweep  the 
Äblock of 200 samples that starts at index 1750 contains the tail current. 
ÄTo make a new object from this block, useÇ| 1 ls

ÇnÄ Ç| tÖ/tail sweep 1750 200 getinterval defÇ|

ÇpÄThe  'getinterval' operator creates a new array object  that  represents 
Äthe specified subset of the values contained in the array associated with 
Ä'sweep'; we associate the subset object with 'tail'.Ç| 

ÇpÄTail  current  objects thus created are grouped together into  a  family 
Äobject by:Ç| 1 ls

ÇnÄ Ç| tÖ/tailfamily [ tail .. ] defÇ|

ÇpÄThe  family  then may be submitted as an entity to analysis  or  picture 
Ätaking.  Note  that  tail  currents need not occupy the  same  subset  of 
Äsamples  in  each  sweep:  they can start anywhere and  be  of  arbitrary 
Älengths, because the objects formed about them automatically inherit this 
Äinformation  and  carry it on to operators,  which will use it  to  focus 
Ätheir effects. These objects and their ÄlistÄ form a new and more specific 
Äsystem of reference for your data.Ç|

ÇpÄOn another occasion, you have received, on a floppy sent by a colleague, 
Äan alphanumerical list consisting of one-column tables of floating  point 
Änumbers.  You  want to submit this material to an analysis that you  have 
Ädeveloped on your D machine.  All you need to do is use Äthe text Äeditor
Ä(Äthat is built into the virtual console of the D machineÄ) to put 'vectors'
ÄlikeÇ| 1 ls

ÇnÄ Ç| tÖ/RateConstants <s ... > defÇ|

ÇpÄaround the tables that you wish to package.  Then,  back from the editor, 
Äyou demandÇ| 1 ls

ÇnÄ Ç| tÖ(that_textfile) fromfilesÇ|

ÇpÄto transform these data into named arrays, which you can refer to as you 
Ädo with your own data.  ÑfromfilesÄ,  by the way, is not an operator, but a 
Äremarkably simple D procedure. This and other generally useful procedures 
Äare part of an environment created when a D machine is 'booted'.Ç|

ÇpÄLet's  step  back  and re-consider what happened  here.  We  invented  a 
Änotation to present data to the computer,  a language so to  speak.  That 
Älanguage happens to be D. By this trick, we assimilated the data into the 
Ämachine   without  having  written  a  single  line  of   classical   I/O 
Äinstructions.   The  technique  is  attractive  because  the  grammatical 
Äoverhead of D is so small.Ç|Ä 

ÇpÄNow,  assume  that  these  data came in non-standard  units  related  to 
Äphysical  quirks  of  the  colleague's  recording  apparatus.   For   re-
Äcalibration,  you include, after the data and in the same text file, some 
ÄD  code  that  transforms  the raw arrays  into  the  proper  units,  for 
Äexample:Ç| 1 ls

ÇnÄ Ç| tÖ[ array_name .. ] { 1.745e-6 mul pop } forallÇ|

ÇpÄThe  'forall' operator applies the calibration procedure to  all  arrays 
Äwhose  names  are included in the list (enclosed  between  []),  and  the 
Ämultiplication  operator  in the procedure scales all  elements  of  each 
Äarray (evidently, D is not verbose).Ç|

ÇpÄWhenever  you  will  go back to this data file,  you  will  get  properly 
Äcalibrated  data  without  sacrificing the original or  losing  track  of 
Äyour additional calibrations.  With minimal ado,  you have converted this 
Ädata set into something that takes care of itself:  an object  comprising 
Äboth 'data' and 'instruction', self-calibrating data, so to speak.Ç|

ÇpÄA natural form of organizing larger collections of objects is the  ÅtreeÄ. 
ÄA  tree  starts  from a dictionary or list that  holds  simple  or  other 
Äcomposite objects;  these composite objects,  again,  can hold  composite 
Äobjects, and so on to any level of nesting. Since trees are a very useful 
Äform  of organizing objects,  D provides operators to move  entire  trees 
Äamong media. For instance,Ç| 1 ls

ÇnÄ Ç| tÖSolutionBook OptDisk toboxÇ|
ÇnÄ Ç| tÖOptDiskProtocols /SolutionBookputÇ|

ÇpÄputs the tree that starts with the list ÑSolutionBookÄ into a  ÅboxÄ 
Äobject  and  stores  that  object  on  the  medium  associated  with  the 
Äidentifier OptDisk. This listcontainsa collection of all solution Ädescriptionsever used in your lab, probably in the form of one dictionary per Äsolution; each dictionary has a number of standardized entries, including lists Äof stock solution names, their indices in the book, and pipetted Ävolumes.Altogether, 
Ämoving this whole structure piecewise would be very cumbersome, and moving only Ächanged or added pieces would be error prone. The ÑtoboxÄ operator performs this Älarge job in one safe sweep and returns the new box object, which 
Äis included into the dictionary ÑOptDiskProtocolsÄ for later  reference.  In 
Äorder to load this tree into internal VM during a later session,  useÇ|  1 
Çls

ÇnÄ Ç| tÖOptDiskProtocols /SolutionBookget fromboxÇ|
ÇnÄ Ç| tÖuserdict /SolutionBook putÇ|

ÇpÄThis retrieves the box object from the dictionary ÑOptDiskProtocolsÄ, loads 
Äthe  tree  contained  in the box into internal  VM,  returning  the  root 
Älist of the solutionbook tree,  and places a reference to that  object 
Äinto the user dictionary (the root dictionary of the ÄD machineÄ). You now can Älook up individual solutions or add new entries to the book.Ç|

ÇpÄA  procedure (provided in a general tool  library),  ÑtofileÄs,  lets  you 
Ätranslate  a tree into its text equivalent and save that text in a  file. 
ÄThe  converse procedure,  ÑfromfilesÄ,  executes the D code contained in  a 
Ätext file and thus creates in the internal VM all objects that are defined 
Äin  a  text  file.  You can use ÑtofileÄs to prepare a  file  containing  a 
Äcollection  of D objects that you wish to submit in toto to a  PostScript 
Ämachine for printing or plotting. Thus, objects organized as trees can be 
Ämoved and converted efficiently with a few simple operators.Ç|

ÇpÄIn  the  recent  examples,  no equivalent C phrases  have  been  listed, 
Äbecause  C  lacks  the intrinsic means to hold  its  ground.  The  means, 
Äthough,  can be created ÄinÄ C, by ÄcomposingÄ a virtual D machine. This explains Ähow D came into existence - and to a name.Ç|

ÇpÄThis concludes our intuitive view of D. The following chapters will give 
Äa full reference of the machine model and operators.  The best way to 
Älearn D,  as always,  is by example.  The D machine comes with a stock of 
Äuseful D objects in text files. These implement basic utilities that you likely Äwill use in most work on the D machine. They include operator-like extensions ofÄ the D machine in the form of procedure libraries, a mouse-operated universal Äbrowser that lets you inspect and select any information organized by the D Ämachine (called 'the eye'), and a menu-driven toolbox for editing, file Ähandling, printing etc. (called 'the hand'). These use many of the capacities Äthat set D apart from other language models, and thus may serve you also as a Ägrab bag of useful bits and pieces.Ç| 3 ls



ÇNewPage
ÇhÄCHAPTER Å2Ç| mÄTHE MACHINEÇ| 1 ls

ÇpÄThis chapter gives you a thorough tour of the D machine and informs you of
Äthe substrates of the machine, the D objects.Ç|

ÇcÅ2.1 The objectsÇ| 1 ls

Ç/tabs [ [144 1] [textwidth 144 sub 1] ] def

ÇnÄSimple objectsÇ| tÅnullÇ|Ä    
ÇnÄ              Ç| tÅnumeralÇ|Ä  
ÇnÄ              Ç| tÅoperatorÇ|
ÇnÄ              Ç| tÅnameÇ|
ÇnÄ              Ç| tÅmarkÇ|
ÇnÄ              Ç| tÅbooleanÇ| 1 ls

ÇnÄComposite objectsÇ| tÅarrayÇ|
ÇnÄ                 Ç| tÅlistÇ|
ÇnÄ                 Ç| tÅdictionaryÇ|
ÇnÄ                 Ç| tÅboxÇ|

ÇpÄSimple  objects  are  unique,   self-contained  quanta  of  information. 
ÄComposite objects may be or may not be unique,  and always consist of two 
Äseparate  parts:  information that describes the object  and  information 
Äthat represents the value of the object.  Simple objects are analogous to 
Äsmall  pieces  of  merchandise  that can  be  traded  over  the  counter. 
ÄComposite objects are analogous to real estate. When you pass a composite 
Äobject  via the operand stack to an operator,  you pass  the  information 
Äthat describes the object,  you do not pass the value. Likewise, when you 
Ätrade your house,  you do not put it physically on the negotiation table: 
Äyou bring the deed.Ç|

ÇpÄThe ÅnullÄ object fills a space and serves as a void.Ç|

ÇpÄThe  ÅnumeralÄ  object comes in several  types.  Since  all  manipulations 
Äinvolving  numeral values are delegated to the equivalent of a  math  co-
Äprocessor,  numeral types are not an intrinsic aspect of D and vary among 
Äimplementations and hosts. Invariable, however, is their orthogonal treatment. ÄAlmost all operators take any kinds and combinations of numerals or numeral Äarrays and return meaningful results.Ç|

ÇpÄThe  numeral types  available  in  the  Apple PowerPC and 68k implementations Äcomprise three ranges of integer (ÑbyteÄ, ÑwordÄ, andÑ longÄ), and 
Ätwo precisions of IEEE real, ÑsingleÄ and ÑdoubleÄ (32-bit and 64-bit). Operators Äthat work on existing numeral  objects use the intrinsic type specification to  Ädetermine what arithmetics and type conversions are required.  Where numeral Ätypes need 
Äto  be specified explicitly (e.g. when creating an array),  this is done by nameÄ objects whose  initial 
Ächaracter is a type mnemonic, e.g. /w or /Word.Ç|

ÇpÄThe  ÅoperatorÄ object represents an operation intrinsic to D or  provided 
Äin user-created libraries of extrinsic operators.  Operators resolve into 
Ähost machine code. They in principle are composite, because references to 
Äan  operator imply a description that is separate from the  machine  code 
Äthat  constitutes  the  value.  Operators de  facto  behave  like  simple 
Äobjects, because (for reasons of sanity) you cannot perform operations on 
Ätheir values.Ç|

ÇpÄThe  ÅnameÄ  object  holds  a  name  to  serve  in   associations.   Since 
Äassociations  in  D are dynamic,  reference to a name implies  an  actual 
Äsearch for its current association.  A fast search  algorithm,  employing 
Ähashing,  performs  this  critical task (most searches conclude  after  a 
Äsingle name comparison regardless of the size of the searched vocabulary).Ç|

ÇpÄTheÅ markÄ object is explained by its name.Ç|

ÇpÄThe ÅbooleanÄ object's value is either 'true' or 'false'.Ç|

ÇpÄAn ÅarrayÄ value is formed by a linearly ordered set of numeral values  of 
Äidentical  types.  A  ÑstringÄ is an array of  byte-integers.  Elements  of 
Äarrays  are referred to by index;  the index of the  first  array 
Äelement is ÑzeroÄ.Ç|

ÇpÄA  ÅlistÄ value is formed by a linearly ordered,  generally mixed  set  of 
Ä(whole)  simple  objects  and/or  (descriptions  of)  composite  objects. 
ÑProceduresÄ  are  Ñactive Älists (see below),  of objects  to  be  executed. 
ÄBecause the list value,  again,  may contain lists or  dictionaries,  you 
Äcan use lists to build nested high-order structures.  (Value) elements of 
Älists  are  referred to by index;  the index of  the  first  list 
Äelement is ÑzeroÄ.Ç|

ÇpÄNote  the  difference  between arrays and  lists:  arrays  pack  numeral 
Ävalues, not objects, whereas lists contain objects. Although you can make 
Äa  list of exclusively numeral  objects,  an  array  will  be 
Äpreferable for organizing numerals of identical types,  because the array 
Ästores  the  numerical  values  in  a  more  compact  form  and   because 
Ämathematical  operators deal more efficiently with array than  with  list 
Ävalues.Ç|

ÇpÄWhen you duplicate an array or list object,  or when you create a  child 
Äobject that represents a subset of an array or list value, the respective 
Äoperators create a new description, but they do not duplicate elements of 
Äthe  value.  Hence the new objects share their values with the  original. 
ÄChanges made to a shared value (by modifying the value of one of the sharing Äobjects) will affect all sharing objects.Ç|

ÇpÄA ÅdictionaryÄ value is formed by a set of association pairs, of which one 
Äpartner is a name,  and the other partner, any object. If the association 
Äis with a composite object,  that object is represented by a  description 
Ärather than the value.  Associations are constructed dynamically, through 
Äoperators. Dictionary entries are always made or retrieved through a name 
Äkey,  rather  than  a numerical index.  The information  contained  in  a 
Ädictionary is transparently organized for quick retrieval by  name.  This 
Äorganization precludes access via an index or subpartitioning into  child 
Ädictionaries.Ç|

ÇpÄA  ÅboxÄ value also is comprised of composite objects. A box in internal memory Äbrackets a set of composite objects that can be discarded selectively (e.g. Äarrays temporarily created and used during the execution of an algorithm). A boxÄ in external memory (see section 2.2) stores a folded tree of objects, which areÄ saved and retrieved en bloc.Ç|


ÇpÄObjects  haveÅ attributesÄ.  In composite objects,  these  attributes  are 
Äpart  of the description;  objects that share a value thus need not  have 
Äidentical  attributes.  An  object  is either  ÑpassiveÄ  or  ÑactiveÄ.  This 
Äattribute  is changeable and directs the use of the object,  as datum  or 
Äinstruction. Once a composite object is given the ÑreadonlyÄ attribute, its
Ävalue  can only be read,  but not modified (note that Ñreadonly  Ädoes  not 
Äpreclude  changes  to the value made through  other  objects).  Composite 
Äobjects are either ÑinternalÄ or ÑexternalÄ.  This distinction refers to  the 
Älocation  of  the  object ÑvalueÄ.  For  external  objects  this  attribute 
Äincludes the identifier of the medium where the object value resides (see 
Äbelow).  If the creation of a composite object involves the creation of a 
Ävalue,  this  object receives the ÑparentÄ attribute;  objects  created  to 
Äshare  a subset of a parent object value receive the ÑchildÄ attribute.Ç|  2 
Çls


ÇcÅ2.2 Where D objects liveÇ|

ÇpÄObjects can exist both in the ÑinternalÄ  memory of the host computer  and 
Äin ÑexternalÄ mass storage. We first consider ÅinternalÄ sites of residence.Ç|

ÇpÄInternal  objects  live  on  three stacks and in  a  large  memory  area 
Äreferred to as the Virtual Memory (VM). Sizes of these storage facilities 
Ämay  be chosen when the D machine is brought up.  The stacks  hold  whole 
Äsimple  objects  or descriptions of composite objects.  The  VM  holds  a 
Ämaster  description  and  the  value of  all  internal  parent  composite 
Äobjects.Ç|

ÇpÄThe Åoperand stackÄ holds objects to be consumed by operators or resulting 
Äfrom operators. D uses the Ñreverse Polish notationÄ, and the operand stack 
Äserves as the universal vehicle for passing operands from one operator to 
Äanother.  Objects  accumulate on this stack until a subsequent  operation 
Äconsumes them as operands.  While they remain on the stack,  they can  be 
Äexplicitly manipulated by stack operators.Ç|

ÇpÄThe  Åexecution  stackÄ  holds a file of objects  in  execution.  The  top 
Äelement  is the next in line for execution,  whereas elements  below  are 
Äsuspended.  An  object carrying the ÑactiveÄ attribute can be submitted  to 
Äexecution by pushing it on the execution stack (by an operator or through 
Äreference  to  an associated active name).  The execution stack  will  be 
Äpopulated mostly by strings or procedures (active lists).  After a string 
Ähas been moved to the execution stack,  the object tokens contained in it 
Äare successively translated and submitted to execution,  until the string 
Äis  exhausted  and  removed from the execution stack  (this  exposes  the 
Älatest suspended object).  With a procedure, the objects constituting its 
Ävalue  are successively submitted to execution.  Other objects pushed  on 
Äthe execution stack are consumed at once.Ç|
Ä  
ÇpÄThe  execution  stack  is used also by the operators  that  control  the 
Ärepeated  execution  of procedures (like loop operators).  In  this  way,  the 
Äexecution  stack suffices to maintain the entire flow of control in  a  D 
Ämachine.Ç|

ÇpÄObjects  moved  to  the execution stack can  be  earmarked  as  dropback 
Älevels.  If  an  object subsequently pushed on the  stack  for  execution 
Äinvokes  a certain control operator,  this operator drops  the  execution 
Ästack  down to the latest earmarked object.  This effects a return  to  a 
Äformer  level  of execution,  skipping intermediate levels  of  procedure 
Äcalls or nested loops if necessary.  Activities can be swiftly terminated 
Äor  aborted in this way,  returning control to an  embracing  layer.  The 
Ätechnique also serves to terminate loops from within.  D is a  structural 
Äpurist's language:  there is no 'goto' statement. The dropback mechanism, 
Ähowever,  provides  for all cases where a 'goto' might be desirable in  a 
Ästructured program.Ç|

ÇpÄThe Ådictionary stackÄ holds dictionary objects currently in use.  When  an 
Äactive  name  object  is  executed,  the  name  is  looked  up  in  these 
Ädictionaries,  beginning  with the dictionary on top of  the  stack.  The 
Äfirst  object  found to be associated with the name substitutes  for  the 
Äname  object.  The  dictionary  stack is  explicitly  maintained  through 
Äoperators.Ç|

ÇpÄThe ÅVMÄ occupies a large part of the host machine's internal memory.  It 
Äis  called  'virtual'  because  you can  use  this  memory  only  through 
Äoperators that establish a particular logical memory model.Ç|

ÇpÄAs  internal composite objects become defined during a D  session,  they 
Äconsume  storage space in VM and eventually exhaust all available  space.
ÄThis is prevented by using three housekeeping operators, by which sets of VM Äobjects are earmarked and selectively discarded (references made to them in Äremaining objects are voided).Ç|

ÇpÄD organizes also external media for the storage of objects. The external 
Ämedium  is administrated and accessed as an Åexternal  VMÄ.  Each  physical 
Äsubstrate  like  a  hard disk or optical cartridge  surface  becomes  a 
Äseparate eVM,  which carries a unique identifier.  This identifier serves 
Äto  specify  the  eVM to operators,  and it becomes part  of  all  object 
Ädescriptions that refer to values located on the medium. The utility that 
Äprimes  media  for  use as eVM automatically creates  a  dictionary  that 
Äserves as the root object of the new eVM.  As you create more objects  in 
Äthis  eVM,  you  can  define associations to these objects  in  the  root 
Ädictionary  for  later retrieval.  Whereas this method might work  for  a 
Äfloppy  disk  that contains only a few objects,  you  can  create  larger 
Äaccess   schemes (trees)   of  unlimited  sophistication  by   just   using   Äthe possibilities inherent to composite objects.Ç|

ÇpÄRecall  that  composite objects held by stacks or included in  lists  or 
Ädictionaries are represented by their descriptions.  Hence references  to 
Äexternal  objects  can be passed around in the D machine and  may  become 
Äpart of values stored in internal or external VMs,  while the referred-to 
Äobject  values  rest in their respective external storage media  (in  the 
Äcase of removable media,  they may be even locked away).  This separation 
Ägives you the freedom to organize as many reference systems to externally 
Ästored values as you wish,  and it allows you to maintain these reference 
Äsystems  wherever you wish.  For instance,  you may keep a  directory  of 
Äexternal  information  that you are analyzing in internal  VM  (to  speed 
Älookup),  or  you may store a specific access system to an external  data 
Äbase on a separate medium (for reasons of security or redundancy).Ç|Ä  

ÇpÄExternal  VM shares the property of internal VM,  that  objects  created 
Äthere  accumulate and eventually fill up all space.  When you  create  an 
Äobject in external VM,  you have two options:  you can create a permanent 
Äor a temporary object.  The space of a permanent object can be  reclaimed 
Äonly  by repriming the entire medium.  Temporary objects can  be  deleted 
Älike internal VM objects by an operator. The values of both permanent and 
Ätemporary  objects  are accessible for modification.  You can  wave  this 
Äprivilege  by  giving objects to be safeguarded the  ÑreadonlyÄ  attribute. 
ÄNote  that  permanent and temporary storage are no more than  options  at 
Äyour disposal.  You can fill an entire medium with either temporary or permanentÄ 
Äobjects exclusively, if that suits your needs or self-confidence.Ç|
Ä 
ÇpÄExternal VM serves as the main storage and backup facility of  permanent 
Äinformation  in the D machine.  It is independent of and parallel to  the 
Ämass  storage  organized  by the operating system of  the  host.  D  also 
Äprovides  operators for access to and maintainance of the  domestic  file 
Äsystem of the host.  File contents,  for instance, are exchanged with the 
Ävalue of string objects. Text files holding executable D code or data are 
Äreadily  imported  into the D machine in  this  fashion.  Operators  that 
Äcommunicate  with  the console and other resources (such as  ports)  also 
Äwork directly into and out of D objects.Ç| 2 ls


ÇcÅ2.3 The text representation of objectsÇ|

ÇpÄObjects are formulated in text using the printable subset of the USASCII Ächaracter set  plus  the 
Äcontrol characters,  'space', 'newline', and 'carriage return'. 'Newline' 
Äand 'carriage return' are equivalent in terminating a line.Ç|

ÇpÄObject  tokens  are  separated  by Åwhite  spaceÄ,  a  single  or  several 
Äsuccessive control characters. ÅCommentÄ, a '|' character and its followers 
Äup  to the end of the line, also act as white space (they  are  otherwise 
Äignored).  In  addition  to the separation by white  space,  objects  are 
Ädelimited by any of the special characters,  ( ) [ ] { } < >, which serve 
Äto segregate enumerated contents of composite objects.Ç| 1 ls

Ç/tabs [ [48 1] [textwidth 48 sub 1 ]] def

ÇpÄA   ÅnumeralÄ  starts  with  a  digit,   sign,   or  '*'   character.   An 
ÅintegerÄ ÅnumeralÄ consists of (optional)  sign  and a sequence  of  digits, 
Äoptionally  followed  by a type specifier.  The range of the  integer  is 
Ädetermined by the specifier ('b/B' for byte,  'w/W' for word,  'l/L'  for 
Älong (default integers are long). A Åreal numeralÄ is distinguished from an 
Äinteger  by  the  presence  of at least one  of  a  fractional  part,  an 
Äexponent,  or a 's/S' or 'd/D'  specifier.  The exponential part consists of oneÄ of 
Äthe  characters  'e/E'  immediately followed by a  (signed)  sequence  of 
Äexponent   digits.   Real  numbers are  stored  with  32-bit   (single) or 
Ä64-bit (double) precision. Numerals that do not carry a type specifier will by Ädefault be of type /L (when lacking real-number features) or /D.Ç|

ÇpÄNumeral  values  can  be  ÑundefinedÄ.  Mathematical  operators  using  an 
ÑundefinedÄ value as an operand return ÑundefinedÄ results. Thus, arrays that 
Äcontain invalid data in a few positions may be submitted to  computations 
Äwithout special attention to such exceptions,  a little luxury that saves 
Ätedious programming.  The text representation of an undefined numeral  is 
Äan  '*',  which  may  be  followed by a decimal  point  (to  indicate  an 
Äundefined real numeral), or by one of the type specifiers.Ç|
Ä 
ÇpÄA ÅnameÄ is a sequence of letters,  digits, or 'underline' characters (the 
Äleading character cannot be a digit). Names are limited to 14 significant 
Ächaracters (longer names are silently truncated).  Upper and lower case 
Äare distinguished. A name preceded by '/' is given the ÑpassiveÄ attribute; 
Äotherwise the attribute is ÑactiveÄ.  If you are familiar with  PostScript, 
Äplease note the difference that D excludes you from using characters like 
Ä'?!@#&%' in names.Ç|

ÇpÄSimple  objects  other  than  numeral  or  name  have  no  direct   text 
Ärepresentation.  Such  objects  are specified through  associated  names: 
Ä'null' for the Ånull Äobject,  'true' or 'false' for a ÅbooleanÄ,  and  names 
Äsuch as 'add' for Åoperator Äobjects.  The ÅmarkÄ object and a  complementary 
Älist  operator  are accessed through the '[' and ']'  special  characters 
Ä(making  list  construction  ÑformallyÄ  similar  to  array  or   procedure 
Äenumerations).Ç|

ÇpÄAll  classes of ÅcompositeÄ object can be created through  operators,  but 
Äonly  ÅarraysÄ  and active lists (ÅproceduresÄ) can be  defined  directly  in 
Ätext form by enumerating their elements.Ç|

ÇpÅArraysÄ  are  composed of numeral values enclosed 
Äbetween  '<'  and  '>';  the array type applies to all numerals in the array andÄ is specified by  a  letter that immediately 
Äfollows  the  '<'  character.  Arrays  of  the byte type (ÅstringÄ) may be definedÄ  also  by 
Äalphanumerical  enumeration enclosed between '()';  character codes  that 
Äcannot  be designated directly in such an enumeration are represented  by 
Äbackslash sequences:Ç|

Ç/tabs [ [72 1] [textwidth 72 sub 1 ]] def

ÇnÄ\nÇ| tÄnewline (line feed)Ç|
ÇnÄ\rÇ| tÄcarriage returnÇ|
ÇnÄ\(Ç| tÄleft parenthesisÇ|
ÇnÄ\)Ç| tÄright parenthesisÇ|
ÇnÄ\\Ç| tÄbackslashÇ|
ÇnÄ\dddÇ| tÄcharacter code ddd (octal)Ç|
ÇnÄ\newlineÇ| tÄno character - both are ignoredÇ|

ÇpÄElements  of an enumerated ÅprocedureÄ are embraced by  '{}'.  Objects  so 
Äembraced  are  not  executed:  they are translated  into  their  internal 
Ärepresentation  and  simply stored as the value of the  procedure  object 
Ä(compiled,  so  to  speak).  In particular,  no dictionary  searches  are 
Äperformed  for active names at this time.  The objects contained  in  the 
Äprocedure  value  will  be  executed  only  through  invokations  of  the 
Äprocedure.Ç|

ÇpÄArrays  and  procedures  defined by enumeration have  to  be  completely 
Äcontained  within a single portion of text submitted to  the  translator. 
ÄThe  translator  is used implicitly by the D executive  (mill)  described 
Äbelow,  and  is made available for explicit use through an operator (a  D 
Äprogram can study its own code).Ç|

ÇpÄIn  summary:  the  text  form  of D  code  is  translated  with  minimal 
Ägrammatical ado into a linear sequence of internal objects. Object tokens 
Äbecome  either individual simple objects,  or become incorporated into  a 
Äcomposite  object  when  they  are  enclosed  between  certain  types  of 
Äbracket.Ç| 1 ls

ÇcÅ2.4 The millÇ|

ÇpÄThis  chapter specifies the executive of the D machine,  briefly  called 
Äthe 'mill'.  The mill accepts the objects that are handed to the machine and 
Äguides  them  to their targets,  where  they  are  stored,  consumed,  or 
Ätransformed. Like with any machine that you operate, you want to know how 
Äit is turned on or off, and what rules it follows while running.Ç|
Ä 
ÇpÄWhen  the  program  that  implements  the  D  machine  is  brought   up, 
Äinitializations are performed. These effect that:Ç|

ÇpÄ-- the  dictionary stack contains the system dictionary  (of  intrinsic 
Äoperators) and a user dictionary.Ç|

ÇpÄ-- the execution stack holds a single,  string object. The string value 
Äis  derived  from a text file called 'startup.d' and retrieved  from  the 
Ädirectory 'DM' (a folder in your startup volume).  This string holds the first 
Äsequence  of  objects  to be executed and,  thus,  is  analogous  to  the 
Ä'bootstrap'  code  of an ordinary computer. The D objects imported from the Ästartup file extend the operator set of the system by a library of procedures Äthat are needed very often and may be viewed as operators that happen to be Äwritten in D.Ç|

ÇpÄ-- The internal VM is empty. No external VM's are in use.Ç|


ÇpÄAfter this initialization,  the mill will cycle through a succession  of 
Äthree  phases.  The ultimate goal of the mill's activity is to empty  the 
Äexecution stack by fair play.Ç|

ÇpÄEach  turn of the D mill  begins with the Åtest phaseÄ for  evaluating  Äconditions  that 
Ärequire an interruption of the current context. This is followed by the Åfetch 
ÅphaseÄ,  during  which  the next object in sequence  is  determined.  That 
Äobject, then, is executed in the Åexecution phaseÄ.Ç|

ÇpÄIn the Åfetch    phaseÄ,    the   execution   stack   is   inspected    to 
Ädetermine the next object of execution. This stack will hold only objects 
Äwith   the  ÑactiveÄ  attribute.   A  simple  object   will be popped   and 
Äsubmitted directly to the  execution  phase.  Of a  procedure  or string, 
Äinstead, the first (translated) object is extracted, and the remainder of 
Äthe  procedure or string remains on the execution stack until the  entire 
Äprocedure or string has been exhausted.Ç|

ÇpÄA fine point to note is that a procedure object actually is popped  from 
Äthe  execution stack ÑpriorÄ to the execution of its last value object  (to 
Äsave stack space during end-to-end recursion).Ç|

ÇpÄAny  ÑpassiveÄ  object  passed to the Åexecution  phaseÄ  is  'executed'  by 
Ätransferring it to the operand stack.Ç|

ÇpÄAn  ÑactiveÄ  object is given special attention if it is a  ÑnameÄ.  A  ÑnameÄ 
Äobject is replaced by the currently associated object.  The search for an 
Äassociated  object  involves  the  dictionaries  currently  held  on  the 
Ädictionary  stack and proceeds from the top to the bottom of  the  stack. 
ÄThe first association detected for the name is used. An active associated 
Äobject  is pushed on the execution stack,  whereas a  passive  associated 
Äobject is pushed on the operand stack. The mill starts a new turn.Ç|

ÇpÄExecution  of other active objects also is directed by class:Ç|
Ä 
ÇpÄ-- A Ñnull Äobject is discarded.Ç|

ÇpÄ--  An  ÑoperatorÄ  object  is  invoked, i.e.  the  host  program  module 
Ärepresented  by the operator is executed.  A large set of system operators has Äbeen built into the D machine and is accessible through the system dictionary Ä(ÑsystemdictÄ), which is permanently present at the bottom of the dictionary Ästack.Ç|

ÇpÄ-- Any other object is executed like a passive object,  by  transferring 
Äit to the top of the operand stack.Ç|

ÇpÄTwo points deserve a note here:  (1) AÑ Äpassive null object is pushed  on 
Äthe  operand  stack,  but  an active null  object  effects  nothing.  (2) 
ÄA procedure object  encountered on the execution stack always  serves  as 
Ä'instruction' because of its ÑactiveÄ attribute;  reference to a  procedure 
Äthrough  an  active name has the same effect.  If a procedure  is  to  be 
Äworked  on  as 'data',  it needs to be transferred to the  operand  stack 
Ä(operators see to that).Ç|

ÇpÄMany functions that are essential for the D machine,  such as definition 
Äof name-object associations,  are not of concern to the mill. The mill is 
Äconcerned only with the orderly consumption of objects,  whereas specific 
Ätasks   belong  to  the  operators.   This  strict  division   of   labor 
Äkeeps  things simple and the D machine robust.  Operators will  be  dealt 
Äwith in Chapter 3.Ç|

ÇpÄThe  mill  consults a timer to ÅinterruptÄ the context being  executed  at 
Äregular intervals (0.1 s).  The timer is examined in the Åtest phaseÄ  that 
Äleads  each  turn.  When the end of the interval  is  recognized,  a  new 
Äinterval is started, the active name ÑinterruptÄ is pushed on the execution 
Ästack,  and  execution  resumes.  ÑinterruptÄ should be associated  with  a 
Äprocedure that tests external conditions of interest (e.g.  a request for 
Äoperator  intervention from the console),  or effects timed events  (e.g. 
Äthe preventive dumping of a disk cache). By default, ÑinterruptÄ is associated Äwith a no-op operator; you can at any time substitute a procedure that suits 
Äyour needs.Ç|

ÇpÄOn each timer tick (and whenever it is idle), the mill consults  the virtual Äterminal (VT, described in the next section) for host events that require its Äattention. Most of the numerous events that the Apple operating system reports  Äto an application are attended to by the VT; only 'cooked' events that serve to Ädirect the execution of D objects are handed to the mill. These events are:Ç|

ÇpÄ- a request to (re)draw the contents of a graphical VT screen. When such a Äscreen is created by an operator, a dictionary is associated with the screen. ÄWhen the (re)draw request is received, the mill pushes the screen dictionary on Äthe dictionary stack and the active name 'drawscreen' on the execution stack. Ä'drawscreen' should resolve to a procedure that uses the appropriate drawing Äoperators to build the contents of the screen.Ç|

ÇpÄ- a request to respond to a mouse click over a graphical VT screen. The mill Äpushes the screen dictionary on the dictionary stack, the mouse coordinates and Ämodifier keys on the operand stack, and the active name 'mouseclick' on the Äexecution stack. 'mouseclick' should resolve to a procedure that attends to the Ämouse click.Ç|

ÇpÄ- the user has pressed the command/escape keys on the keyboard. This directs 
Äthe mill to submit the next phrase entered to the console screen to direct Äexecution by the mill (by pushing the phrase string on the execution stack).Ç|

ÇpÄLast not least, in the act of consulting the VT, the mill offers the Apple Äoperating system an opportunity to take control and to allow other 
Äapplications to be executed concurrently with the D machine. Thus, the D machineÄ can be moved between foreground and background operation in response to mouse Äclicks into the Apple menu bar or visible windows belonging the different Äapplications. The D machine, hence, is a good citizen in terms of the Apple Äcooperative multi-tasking concept. The principle of yielding adequate time to Äother applications is maintained also in the design of operators that could Äwaste considerable processor time by waiting for some external events (like a Ämessage from a communication line). Such operators are transparently subdivided Äinto smaller operators such that waiting intervals can be used otherwise.Ç|

ÇpÅErrorsÄ  in  object usage recognized by the  mill,  text  translator,  or 
Äoperators  lead  to a uniform response. A string object  indicating  the 
Äinstance  of  discovery and a numeral object representing the  error  are 
Äpushed onto the operand stack, and the active name 'error' is pushed on the Äexecution stack. 'error', unless reassigned by you, is associated with an  Äoperator that prints an error message on the console screen and pushes a 'halt' Äoperator on the execution stack. 'halt' directs console phrases to the mill for Ädirect execution, but once placed on the execution stack does not allow the Ästack to drop below the 'halt' operator (in effect, it loops endlessly). You canÄ remove the 'halt' operator from the execution stack by executing one of the Äoperators 'continue' (which makes the mill resume execution of the context in Äwhich the error occurred), 'stop' (which terminates the innermost context Äenclosed by 'stopped'),  or 'abort' (which reprimes all stacks and discards all Äactivities in progress).Ç|

ÇpÄThe  mill  of the D machine halts when  the 'quit' operator is executed; this
Äterminates the application that implements the D machine 
Äand returns control to the operating system of the host computer.Ç|

ÇpÄIn  summary,  the D mill can execute any object submitted to it via  the 
Äexecution stack, with effects that depend on the active/passive attribute 
Äand the class of the object.  Object associations by name are resolved in 
Äthe act. Executed objects eventually precipitate in objects pushed on the 
Äoperand  stack  (to  serve  as 'data' for  operators),  or  lead  to  the 
Äexecution  of  host  program modules (which  perform  the  'instructions' 
Äimplied by D operators). The mill can schedule responses to external events and Äthus provide a degree of pre-emptive multi-tasking in executing D objects. It Äprovides a uniform response to errors.Ç|

ÇcÅ2.5 The Virtual TerminalÇ|

ÇpÄThe D machine communicates with you using the video screen, keyboard, and mouseÄ of the Apple host computer. Since these facilities and others (like CPU time) 
Äare shared among concurrent applications running in the Apple computer, they Äneed to be negotiated. In these negotiations, the D machine uses an Äintermediary, the virtual terminal (VT). From the perspective of a D program, Äthe VT appears as a combined text and graphics terminal subserved by a set of Äoperators. The Apple computer sees a normal application that conforms with the ÄApple cooperative multitasking. You see a neat and responsive console, from Äwhich you can steer the D machine. A multi-screen editor built into the VT Äassists you at all times, because it works concurrently with the D mill and Äother applications running on the host.Ç|Ä   

ÇpÄThe VT organizes the physical screen of the Apple computer, 
Äsuperimposing the windows of all other applications that are not in the Äforeground. The screen is divided into three horizontal zones spaning the full Äwidth:Ç|

ÇpÄ- the standard Åmenu barÄ (containing the Apple and application menusÇ|Ä)Ç|

ÇpÄ- Åtext and graph screensÄ. The VT maintains 1 to 10 virtual screens. Screen #0 Äis created automatically when the D machine is brought up; this is a text screenÄ and receives the console dialogue. Other screens are created/discarded by Äoperators and can be of text or graph types. A text screen is of fixed size and Äspans the entire text screen zone (thus only one text screen is visible at a Ätime). Graph screens are made to variable sizes and arrangements (thus several Ägraph screens may be visible on top of a text screen).Ç|

ÇpÄ- ÅMenu screensÄ. A strip along the bottom of the physical screen is reserved Äfor graph screens usually dedicated to view and select menus created by D Äapplications. Each menu screen fills this entire strip, so one is visible at a Ätime.Ç|

ÇpÄYou can randomly select screens for view, by pressing the corresponding
Änumeral key of the numeral keypad together with 'control'. Screens can also
Äbe switched by a VT operator.Ç|

ÇpÄText screens have two possible behaviors: ÅeditÄ or ÅdialogueÄ. Each text screen isÄ associated with a private text memory (the console screen, for instance, has a Äcapacity of 500 rows of 80 columns). Edit screens use their memory linearly, so Äthey can fill up. Dialogue screens use their memory cyclically, overwriting the Äoldest rows as space for new rows runs out; they do not fill up. Edit screens Älet you modify their text via the keyboard, whereas dialogue text can only be Äviewed. The console screen blends these two behaviors. Text already passed to Äthe D mill (or written by D operators to the console screen) is treated like in Äa dialogue screen. Text being entered from the keyboard but not yet submitted toÄ the D machine is treated as if it were in an edit screen (text in this edit Äzone is shown in blue, whereas text in the dialogue zone is in black). A portionÄ of text is submitted to the D mill only after it has been closed by a Ä'return'.Ç|

ÇpÄText screens are subdivided in a uniform way. The main, central area shows a Äportion of text. A strip along the top contains two fields in Äwhich you can enter strings to be used in searches or text replacements. A bar Äalong the screen bottom represents the unused (white), filled (gray), and Ädisplayed (black) fractions of the text memory. One method for scrolling Äthrough the text memory is by clicking the mouse over particular portions of theÄ text screen:Ç|

ÇpÄ- in the scroll bar below the screen: the top of the display moves in the Ätext corresponding to the chosen mouse location in the bar;Ç|

ÇpÄ- in the background of the top border without or with pressing the control key:Ä scrolls down one or five rows; note that with the three-button mouse, you can Äuse the middle button instead of 'control/click'.Ç|

ÇpÄ- in the background of the bottom border without or with pressing the control Äkey: scrolls up one or five rows;Ç|

ÇpÄThe screen is scrolled also in response to the 'home', 'end', 'page up, and Ä'page down' keys, and it scrolls automatically as necessary to keep text being Äentered in the viewed range.Ç|

ÇpÄClicking the mouse over the search or replacement fields lets you enter or Ämodify the search or replacement string (shown in blue while being entered; Äconclude with 'return'). Clicking the mouse over the main part of the screen Äplaces the text cursor at the mouse position. Clicking again while pressing the Äcontrol key marks a block of text, which extends between the old cursor positionÄ and the new mouse location (forward or backward).Ç|

ÇpÄKeystrokes not dedicated to control functions enter text into the text memory 
Äof the current console or edit text screen. This text is organized in a fixed Ägrid of rows of maximally 80 columns (a fixed-pitch font, Courier, is used for Äviewed text). When text being entered overflows the current row, the current Äword is carried over into a new row; no line separator is inserted unless you Äpress a 'return'; you can force insertion to continue in a new row by pressing Ä'control/return' (this does also not insert a line separator). When you are 
Äentering/editing D code, line separators have no role beyond that of token Äseparator. For the console, however, 'return' is relevant because it makes a Äphrase ready for submission to the D mill (usually terminating your opportunity Äto correct it). Another use of multi-row phrases is to build paragraphs; Äwhen a paragrph is fragmented by insertions or deletions, can be swiftly Äreshaped by pressing 'escape'. The fixed pitch of the displayed text helps in Äarranging structured D code; for word-processing text, the arrangements made on Äthe screen are useful for editing, but are overruled by imbedded typesetting Äinstructions when a hardcopy is printed (see below).Ç|

ÇpÄThe following control functions are available in both ÑeditÄ and ÑdialogueÄ Äscreens:Ç| 1 ls

Ç/tabs [ [textwidth 1 ]] def
ÇnÖcontrol/sÄ - start entering search stringÇ|
ÇnÖcontrol/uparrowÄ or Öcontrol/leftarrowÄ - search backwardsÇ|
ÇnÖcontrol/downarrowÄ or Öcontrol/rightarrowÄ - search forwardsÇ|
ÇnÖcontrol/hÄ - mark current viewÇ|
ÇnÖcontrol/tÄ - return to marked viewÇ|
ÇnÖcontrol/xÄ - remove cursor and release blockÇ|

ÇpÄIn ÑeditÄ screens the following additional control functions are available:Ç| 1 ls

ÇnÖtabÄ - add spaces to fill the current triplet of columnsÇ|
ÇnÖcontrol/dÄ or ÖdelÄ or ÖclearÄ - delete character under cursorÇ|
ÇnÖcontrol/bÄ or ÖdeleteÄ - delete character to the left of cursorÇ|
ÇnÖcontrol/returnÄ - continue insertion in a new rowÇ|
ÇnÖreturnÄ - close phrase or paragraph and start new rowÇ|
ÇnÖcontrol/lÄ - delete entire row that contains cursorÇ|
ÇnÖcontrol/nÄ - enter replacement stringÇ|
ÇnÖcontrol/rÄ - replace search string at current cursorÇ|
ÇnÖcontrol/cÄ - insert copy of block starting at current cursorÇ|
ÇnÖcontrol/kÄ - kill text in current blockÇ|
ÇnÖcontrol/mÄ - move text in block to current cursorÇ|
ÇnÖescapeÄ - reformat the current paragraph starting at the cursorÇ|

ÇpÄDialogue screens can hold only plain ÅASCIIÄ text. Edit screens can be created inÄ two versions: plain ASCII and word processing (ÅWPÄ). The console screen is Äalways plain ASCII. Word processing screens allow you to direct typesettingÅ Äby aÄ ÅPostScriptÄ hardcopy device: PostScript instructions are embedded between Äprintable text, and, within printable text, you can switch within a set of Äenhancements (such as font characteristics, subscripting, etc). This method of Ätypesetting provides the maximal possible flexibility, because it deals with a ÄPostScript device directly, without being limited by what a word processor knowsÄ to do with PostScript (usually not much). This manual, by the way, was preparedÄ with the VT text editor in WP mode.Ç|

ÇpÄThe WP-extended functions of edit screens include:Ç| 1 ls

ÇnÖcontrol/escapeÄ: toggle between PostScript / printableÇ|
ÇnÖcontrol/1Ä - use 'normal' fontÇ|
ÇnÖcontrol/2Ä - use 'bold' fontÇ|
ÇnÖcontrol/3Ä - use 'italic' fontÇ|
ÇnÖcontrol/4Ä - use '4th' font (usually Symbol)Ç|
ÇnÖcontrol/5Ä - terminate super/subscriptÇ|
ÇnÖcontrol/6Ä - start superscriptÇ|
ÇnÖcontrol/7Ä - start subscriptÇ|
ÇnÖcontrol/8Ä - start superscript to be aligned above a subscriptÇ|
ÇnÖcontrol/9Ä - start/terminate inline stretchÇ|
ÇnÖcontrol/0Ä - insert a potential hyphenation site (underlined space)Ç|

ÇpÄThese selections are doubled by the (unmodified) function keys F12, and F1 - ÄF10 respectively.Ç|

ÇpÄThe 4th font is always displayed in ÅblueÄ and has two alternate representations:Ä Symbol or Courier. In the Symbol variety, for instance, letters are rendered inÄ ÑGreekÄ rather than Roman type (see code tables for these fonts).Ç| 1 ls

ÇnÖcontrol/fÄ - toggle between Symbol/Courier representation of 4th fontÇ|

ÇpÄText enhancements are shown on the screen in a rudimentary representation (likeÄ face, color, or size variations of the screen's fixed-spaced Courier font). TheÄ hardcopy can use all registers of the PostScript engine, because the text Äenhancements made with the editor are subject to interpretation by PostScript Äinstructions (embedded or supplied in 'include' files prepared for particular Äforms of document).Ç|

ÇpÄNote that during typing text enhancements stay in effect until they are Äexplicitly turned off (cursor movement does not automatically do this).Ç|

ÇpÄThe VT lets you enter ASCII codes that are not in the standard printable set Ä(but may be necessary to reach printable characters in other code tables or to Äexert control in communications). Control characters of the ASCII table (in the Ärange from 0x01 to 0x1F) are generated like on a teletype keyboard, by pressing Ä'command' (or in a few cases, 'command/option') plus a printable key (like Äcommand/T for code 0x18). Codes in the upper half of the ASCII table (>0x80) areÄ reached by pressing 'option' together with printable keys; these characters areÄ rendered in the viewed text (using the Courier font encoding table).Ç|
ÇpÄThe D machine communicates with the VT through operators and through a direct Äexchange between the VT and the D mill (when console phrases are submitted to Äexecution or when events requiring attention to graph screens occur). Text Äscreen operators let you exchange text between text screen memory and string Äobjects (necessary conversions between plain ASCII and WP formats are done Äautomatically). Except for these simple exchanges, text screens operate Äautonomously, without requiring D instructions. Graph screens depend on D Äinstructions when they need to be drawn or when a mouse click needs attention. DÄ operators provide all basic graphic primitives. The D mill automatically Äschedules the execution of drawing or mouse-response procedures that you Äinstruct it to use when you create the screen (this frees you from polling the ÄVT).Ç|

ÇpÄWP text exported from a text screen into a D string uses escape sequences to Ämark changes in text interpretation. Each escape sequence consists of 'escape' Äfollowed by a bitwise encoded byte:Ç| 1 ls

ÇnÄbit 7 - always true (MSB)Ç|
ÇnÄbit 6 - not usedÇ|
ÇnÄbit 5 - subscriptÇ|
ÇnÄbit 4 - superscriptÇ|
ÇnÄbit 3 - underlineÇ|
ÇnÄbit 2 - italicÇ|
ÇnÄbit 1 - lightÇ|
ÇnÄbit 0 - boldÇ|

ÇpÄThese bit assignments are historical and in fact some bits are interpreted in Äother than the original ways: (1) text in light style is PostScript code; (2) Äunderlined text (except in super/subscript) is kept on the same hardcopy line; Ä(3) text following underlined text in superscript is backspaced to the beginningÄ of the superscript; (4) the bold and italic bits encode for one of four fonts. ÄLines in both ASCII in WP texts are terminated by '\n'. When a WP text is Äimported into an ASCII text screen, the escape sequences are simply discarded. ÄWhen an ASCII text is imported into a WP screen, it is copied as is.Ç|

ÇpÄText screens other than the permanent console screen use (text) memory that is Ätaken away from the memory available to the VM (dynamically reducing the 'total'Ä VM space). This memory is given back when the screen is removed. Multiple text Äscreens can be created and removed in random order (freed space is transparentlyÄ compacted).Ç|

ÇpÄIn summary, the VT text editor lets you compose and edit any text that you may Äwish to produce, although it is much simpler than any commercial utility. ÄThis simplicity flows from a clear separation of the activities, editing and Ätypesetting. You benefit in several ways: (1) You deal with one problem at a Ätime. (2) You can render a document once created in as many different forms Äas you wish. (3) Your editor is always at hand, is simple, and works fast.Ç|
Ä  