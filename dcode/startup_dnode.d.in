
|======================== startup_dnode.d ================================

| Contains procedures for:
|  - inspection of objects
|  - object/text interconversion
|  - transcription of objects
|  - file <=> VM interchange
|  - module support
|  - emulators of dvt operators


|============================= userdict =================================

/false 0 1 eq def                             | boolean prototypes
/true 0 0 eq def

/dm_type /dnode def

2 list dictstack dup 0 get /systemdict name   | name the roots
                     1 get /userdict name

getsocket setconsole
/toconsole_ ~toconsole def

/makefont {
    ~[exch 3 -1 roll 1 ~index 0 ~put] bind
} bind def

| ///////// INTERNALIZED ////////////
|-------------------------- lock -------------------
|
| This requires the convention that no one set a lock
| and then drop out (say by a stop or end of procedure)
| before clearing the lock, which will be the case
| if this function is used to handle the lock.
|
| ~active | -- <<active executed>>
|
| /lock {
|   getlock {exec} {
|     true setlock
|     stopped
|     false setlock
|     {stop} if
|   } ifelse
| } bind def

|------------------------ low-level information -------------------------
| For debugging and quick information about objects, stacks, and system
| resources use:

| _   show top object of operand stack in brief form
| v_  show value of composite top object of operand stack
| s_  show value of string top object of operand stack 
| a_  show all objects on operand stack in brief form, top first

| d_  show top object of dictionary stack in brief form
| da_ show all objects on dictionary stack in brief form
| dg_ get k-th element from top of dictionary stack (0 = top)

| xa_ show all objects on execution stack in brief form
| xg_ get k_th element from top of execution stack (0 = top)

| m_  show current stack, VM, and AM use


/debug_dict 50 dict dup begin

/line 100 /b array def
/consolebuf 1000 /b array def

/oclasses 11 dict dup begin                      | object
   /nullclass  { * (null) text } bind def
   /handleclass {(handle:) fax * object handleid mkact text} bind def
   /numclass   { * object * number } bind def
   /opclass    { * (op: ) text * /object find text } bind def
   /nameclass  { /object find active not { * (/) text } if
                 * /object find text } bind def
   /arrayclass { * (<) text  * /object find type text * ( .. > of ) text
                 * /object find length * number } bind def
   /listclass  { * /object find active
                    { ({ .. } of ) } { ([ .. ] of ) } ifelse text
                 * /object find length * number } bind def
   /dictclass  { * (dict of ) text
                 * object length * number * ( max and ) text
                 * object used * number * ( used) text } bind def
   /markclass  { * ([) text } bind def
   /boolclass  { * object {(true)} {(false)} ifelse text } bind def
   /boxclass   { * (box of ) text
                 * object length * number * ( bytes) text } bind def
end mkread def

/vclasses 11 dict dup begin                  | value
   /nullclass  /_ mkact def
   /handleclass ~_ def
   /numclass   /_ mkact def
   /opclass    /_ mkact def
   /nameclass  /_ mkact def
   /arrayclass { intuples } def
   /listclass  { { _ pop } forall } bind def
   /dictclass  { { exch
                   line 0
                   -16 4 -1 roll text 
                   0 exch getinterval toconsole_ showobj pop
                 } forall
               } bind def 
   /markclass  /_ mkact def
   /boolclass  /_ mkact def
   /boxclass   /_ mkact def
end mkread def

/showobj { dup /object name
   /object find readonly { (r ) } { (  ) } ifelse toconsole_
   line 0 /object find oclasses begin class mkact exec end
   * (\n) text 0 exch getinterval toconsole_
} bind def

/tuples 6 dict dup begin
   /B 10 def
   /W 10 def
   /L 5 def
   /X 2 def
   /S 5 def
   /D 2 def
end def

/intuples { /col 0 def
   { /value name tuples value type get /tuple name
     line 0 -80 tuple div value * number
     0 exch getinterval toconsole_
     /col col 1 add dup tuple ge { pop 0 (\n) toconsole_ } if def
   } forall
  col 0 ne { (\n) toconsole_ } if
} bind def

/topfirst {                        | show list value in reverse order
   dup length 1 sub -1 0 { 
      2 copy get _ pop pop
      } for
   pop
} bind def

end def                            | of debug_dict

/_ { debug_dict begin              | show top object on opd stack
   count 0 eq
     { (OPDS is empty\n) toconsole_ }
     { showobj }
     ifelse
   end
} bind def

/a_ { debug_dict begin              | show entire opd stack
   count 1 sub 0 1 3 -1 roll { index _ pop } for
   end
} bind def

/v_ { debug_dict begin              | show value at top of opd stack
  dup vclasses begin dup class mkact exec end
  end
} bind def

/s_ { dup                           | show text string at top of opd stack
dup dup class /arrayclass eq exch type /B eq and
  { { (\n) search { toconsole_ toconsole_ }
                  { toconsole_ (\n) toconsole_ exit } ifelse
    } loop
  } { v_ } ifelse
} bind def

/m_ { debug_dict begin              | show memory capacities and usage
   vmstatus  /vmused name  /vmmax name
   line  0 19 (VM) text
           10 (DICTS) text
           10 (EXECS) text
           10 (OPDS) text
           * (\n) text
         0 exch getinterval toconsole_
   line  0 -10 (max) text
            10 vmmax * number
            * (\n) text
         0 exch getinterval toconsole_
   line  0 -10 (used) text
            10 vmused * number
            10 countdictstack * number
            10 countexecstack * number
            10 count * number
            * (\n) text
         0 exch getinterval toconsole_
   end
} bind def

/d_  { currentdict _ pop } bind def
/da_ { countdictstack list dictstack
       debug_dict begin topfirst end } bind def     
/dg_ { countdictstack list dictstack
       dup length 3 -1 roll sub 1 sub get } bind def
/xa_ { countexecstack list execstack 
       debug_dict begin topfirst end } bind def
/xg_ { countexecstack list execstack
       dup length 3 -1 roll sub 1 sub get } bind def

|----------------------- object-to-text conversion ------------------------

| The following procedures operate on collections of objects organized
| in 'trees'. A tree comprises a root (dictionary or list) and recursively
| all objects nested therein.

| A tree can be encoded into text form through 'xtext', 'xtexts', or 
| 'pstext'. These translate a tree specified by its root object into
| text accumulated in a string as by the 'text' operator. 'xtext' expands
| byte array values as numerals, 'xtexts' expands byte array values
| literally, and 'pstext' works like 'xtexts' and in addition translates
| arrays into lists for use by PostScript.
| 
| use:  textbuffer index object | textbuffer index

/xtext  { xtext_dict begin /dprec 15 def /d_bnum  totext end } bind def
/xtexts { xtext_dict begin /dprec 15 def /d_blit  totext end } bind def
/pstext { xtext_dict begin /dprec 6 def  /ps_blit totext end } bind def

/xtext_dict 40 dict dup begin
 
/inword { dup class mkact exec } bind def

/newline { * (\n) text indents () text /colleft 75 indents sub def 
} bind def

/indent { indents add /indents name } bind def

/ftext { /chunk name 
  colleft chunk length 1 add sub /colleft name colleft 0 lt 
    { newline * chunk text /colleft colleft chunk length sub def } 
    { * ( ) text * chunk text }
    ifelse
} bind def

/objstr 40 /b array def

/nullclass  { pop (null) ftext } bind def
/handleclass {pop (null) ftext } bind def
/numclass   { dup type mkact exec } bind def
/opclass    { objstr 0 * 4 -1 roll text 0 exch getinterval ftext
            } bind def
/nameclass  { /obj name
              objstr 0 /obj find active not { * (/) text } if
              * /obj find text 0 exch getinterval ftext
            } bind def

| arrayclass is alternately associated with:

/d_bnum { mkpass _arrayclass } bind def

/d_blit { mkpass dup
          type mkact d_blit_dict begin exec end mkact exec
} bind def

/d_blit_dict 6 dict dup begin
   /B /_stringclass def
   /W /_arrayclass def
   /L /_arrayclass def
   /X /_arrayclass def
   /S /_arrayclass def
   /D /_arrayclass def
end mkread def

/ps_blit { mkpass dup 
           type mkact ps_blit_dict begin exec end mkact exec
} bind def

/ps_blit_dict 6 dict dup begin
   /B /_stringclass def
   /W /listclass def
   /L /listclass def
   /X /listclass def
   /S /listclass def
   /D /listclass def
end mkread def

/listclass  { dup /obj name active
              { newline ({) ftext 2 indent 
                /obj find { inword } forall
                -2 indent (}) ftext
              }
              { newline ([) ftext 2 indent 
                obj { inword } forall
                -2 indent (]) ftext
              }
              ifelse
            } bind def
/dictclass  { mkpass /obj name
              obj type /Q ne {
                  newline
                  obj length 
                  objstr 0 * 4 -1 roll * number 0 exch getinterval
                  ftext (dict dup begin) ftext
                  2 indent
                  obj {
                      4 -2 roll newline
                      4 -1 roll inword 3 -1 roll inword (def) ftext
                  } forall
                  -2 indent (end) ftext
              } if
            } bind def
/boxclass   { pop (null) ftext} bind def | discard a box object
/markclass  { pop * ([) text } bind def
/boolclass  { {(true)} {(false)} ifelse ftext } bind def

/_stringclass { /obj name
                newline * (\() text * obj text * (\)) text } bind def
/_arrayclass { /obj name
               newline objstr 0 * (<) text * obj type text
               0 exch getinterval ftext 3 indent
               obj { dup type mkact exec } forall
               -3 indent (>) ftext
             } bind def

/B { objstr 0 4 4 -1 roll * number 0 exch getinterval ftext } bind def
/W { objstr 0 6 4 -1 roll * number 0 exch getinterval ftext } bind def
/L { objstr 0 11 4 -1 roll * number 0 exch getinterval ftext } bind def
/X { objstr 0 21 4 -1 roll * number 0 exch getinterval ftext } bind def
/S { objstr 0 13 4 -1 roll 6 number 0 exch getinterval ftext } bind def
/D { objstr 0 dprec 8 add 4 -1 roll dprec number
     0 exch getinterval ftext } bind def

/totext {find /arrayclass name find /obj name
   /indents 0 def newline
   /obj find inword
   newline
} bind def

end def  | of xtext_dict

|------------------------------ file <-> VM -----------------------------

| Two symmetrical procedures, 'tofiles' and 'fromfiles' transport any
| objects and collections thereof between files and VM. These objects
| may be organized in a tree, but do not have to.

| 'tofiles' collects objects layed down in text form by a generating
| procedure that uses operators such as 'text' or procedures such as 
| 'pstext', and saves the resulting string as a file.
| use:  dirname filename { object_generator } | --

/tofiles {
   save /tofilessave name
 { 
   vmstatus sub 5 div 4 mul /b array tofilessave capsave
   0 3 -1 roll exec
   0 exch getinterval 3 1 roll writefile
 } stopped pop tofilessave restore
} bind def

| 'fromfiles' performs the converse of 'tofiles', by reading a text file
| into a transient string object and executing that string.
| use: dirname filename | objects..  (and/or side effects)

/fromfiles { 
   save /fromfilessave name
 {
   vmstatus sub 3 div /b array fromfilessave capsave
   readfile mkact exec
 } stopped pop fromfilessave restore
} bind def

| fromxfiles does the same as fromfiles, but first checks that the file
| exists.

/FTYPEMASK 61440L def
/DIRTYPE 16384L def
/FUSERREAD 256 def

| dirname filename | 
|   if file exists: objects.. true
|   else:           false
/fromxfiles {
    2 copy findfile not {pop pop false} {
        3 1 roll pop pop
        dup FTYPEMASK and DIRTYPE eq {pop pop pop false} {
            FUSERREAD and 0 eq {pop pop false} {fromfiles true} ifelse
        } ifelse
    } ifelse
} bind def

|----------------- myname
| -- | (hostname)
| just allocate it on startup
/myname getmyname def

|---------------- socketdead
| socket | --
| default handler just throws away the socket and signals an error

| socket | -- <<error thrown>>
/socketdead {
  userdict /mpidata known {
    mpidata /socket known {
      mpidata begin {
        dup socket eq {
          (** rthreads socket dead\n) toconsole_
          kill
        } if
      } stopped end {stop} if
    } if
  } if
  pop myname getmyport (socketdead) ERRORS /SOCKET_DEAD get error
} bind def

@ENABLE_RTHREADS_START@
/mpidata 200 dict dup begin | [
  /cpawn -1 def
  /pawns 0 def
  /mpisize <x 100000 200 200 1000 200> def

  /winmade false def
  /pbuf 80 /b array def
  /mpiinfo [] def
  
  /updatet {
    winmade {{currentdict begin drawwindow} stopped pop} {
      pbuf 0 (pawn ) fax * cpawn * number (:\n) fax 0 exch getinterval
      toconsole_
    } ifelse
  } bind def

  /checkbusy {
    dup * eq {
      pop
      false pawnbusy {or} forall {(Pawn is busy!\n) toconsole_ stop} if
    } {
      pawnbusy exch get {(Pawn is busy!\n) toconsole_ stop} if
    } ifelse
  } bind def

  /makebusy {
    dup checkbusy
    dup * eq {pop 0 1 pawns 1 sub {true pawnbusy 3 -1 roll put} for} {
      true pawnbusy 3 -1 roll put
    } ifelse
    updatet
  } bind def

  /makeready {
    dup * eq {pop 0 1 pawns 1 sub {false pawnbusy 3 -1 roll put} for} {
      false pawnbusy 3 -1 roll put
    } ifelse
    updatet
  } bind def

  /makeready_dpawn {
    {makeready} stopped end {stop} if restore
  } bind def

  /setcurrent {/cpawn name
    updatet
  } bind def

  /kill {
    {null makerthreads} stopped
    {winmade ~deletewin if} stopped pop
    currentdict /save_ known {save_ restore} if
    -1 setcurrent
    /pawns 0 def
    {stop} if
  } bind def 

  Xwindows_ {
    /NORMALFONT {fontdict /NORMALFONT get} bind def
    /BOLDFONT {fontdict /BOLDFONT get} bind def
    
    /windowsize {
      { [ 3 1 roll | ]
        winmade not {stop} if
        wH ne exch wW ne or {
          wid wW wH resizewindow
        } if 
      } stopped end {cleartomark stop} if pop
    } bind def

    /drawwindow {
      { [ | ]
        winmade not {stop} if
        wid woutline BLACK drawline
        0 1 mpidata /pawns get 1 add 1 sub {drawnode} for
      } stopped end {cleartomark stop} if pop
    } bind def

    /drawnode {/kpawn name
      wid noderects kpawn get
      kpawn 0 eq ~BG {
        pawnbusy kpawn 1 sub get ~HBG ~BG ifelse
      } ifelse fillrectangle

      wid 
      nodelocs kpawn get exec      
      nodenames kpawn get
      cpawn dup * eq kpawn 0 ne and exch kpawn 1 sub eq or 
      ~HIGHTEXT ~NORMALTEXT ifelse
      drawtext pop pop pop
    } bind def

    /actions 3 dict dup begin | [
      /click {kpawn 1 sub setcurrent} bind def
      /cancel {kpawn 0 ne {kpawn 1 sub makeready} if} bind def
      /group {* setcurrent} bind def |]
    end def

    /mouseclick {
      { [ 4 1 roll | ]
        winmade not {stop} if
        /mS name /mY name /mX name
        /kpawn mY 1 sub 13 div def
        mS /default actions mouseaction pop
      } stopped end {cleartomark stop} if pop
    } bind def

    /newwin {
      {[ | ]
        Xwindows not {stop} if

        /BLACK <d 0 0 0 >      mapcolor def
        /GRAY  <d 0.2 0.2 0.2> mapcolor def
        /BLUE  <d 0 0 1 >      mapcolor def
        /RED   <d 1 0 0 >      mapcolor def
        /LBLUE <d 0.1 0.1 0.9> mapcolor def
        
        /BG <d 235 243 248 >  255 div mapcolor def
        /HBG <d 166 219 160 > 255 div mapcolor def
    
        /NORMALTEXT ~NORMALFONT [null BLACK -1 0] makefont def
        /HIGHTEXT ~BOLDFONT [null BLUE -1 0] makefont def
    
        screensize /scrH name /scrW name
        
        /wW 200 2 add def
        /wH mpidata /pawns get 1 add 13 mul 2 add def
        
        /woutline [ 0 0 wW 1 sub 0 wW 1 sub wH 1 sub 0 wH 1 sub 0 0 ] def
        
        /noderects [
          /x 1 def
          1 13 mpidata /pawns get 1 add 1 sub 13 mul 1 add { /y name
            /r 4 /w array def
            x r 0 put  y r 1 put wW 2 sub r 2 put 13 r 3 put
            r
          } for
        ] def

        /nodelocs [
          /x 5 def
          12 13 mpidata /pawns get 1 add 1 sub 13 mul 12 add { /y name
            ~[x y 6 sub]
          } for
        ] def

        /nodenames [
          255 /b array 0 dvtnodeid fax (:) fax * getmyport * number 
          0 exch getinterval

          /i 0 def
          0 2 mpiinfo length 1 sub {/j name
            mpiinfo j get {
              255 /b array 0 * i * number (: ) fax
              mpiinfo j 1 add get dup /host known {/host get fax} {pop} ifelse
              0 exch getinterval
              /i i 1 add def
            } repeat
          } for
        ] def

        /wid [scrW wW sub 10 sub scrH wH sub 10 sub wW wH ]
          (ThePawns) (Pawns) makewindow 
        def
        /winnamebuf 30 /b array def
        /winname 
          winnamebuf 0 (/w) fax * wid * number 0 exch getinterval mkact exec 
        def
        currentdict userdict winname put
        wid true mapwindow
        /winmade true def
      } stopped {cleartomark stop} if pop
    } bind def
    
    /deletewin {
      {[ |]
        /winmade false def
        wid deletewindow
      } stopped {cleartomark stop} if pop
    } bind def

    /delete_window {{deletewin} stopped end {stop} if} bind def
  } if

  | [[n /key val ...]...] | --
  /rthreads_multi_ {
    [exch {
      dup 0 get 1 index length 1 sub 2 div dict dup begin | [n /k v] n dict 
      3 -1 roll 1 1 index length 1 sub getinterval  | n dict [/k v..]
      0 2 2 index length 1 sub { | n dict [/k v..] i
        2 copy get 3 1 roll      | n dict /k [/k v..] i
        2 copy 1 add get         | n dict /k [/k v..] i v 
        3 1 roll pop 3 1 roll    | n dict [/k v..] /k v 
        def                      | n dict [/k v..]
      } for pop end
    } forall] /mpiinfo name
  } bind def


  | [n1 (host1) n2 (host2)... ] | --
  /rthreads_hosts_ {
    [exch
      0 2 2 index length 1 sub {
        [
          2 index 2 index get
          3 index 3 index 1 add get
          1 dict exch 1 index /host put
        ] 3 1 roll pop
      } for pop
    ] rthreads_multi_
  } bind def

  | n | --
  /rthreads_single_ {
    [exch 0 dict] /mpiinfo name
  } bind def

  | ~info-dict-setup | --
  /rthreads_start {
    {
      pawns 0 gt {(** Rthreads already exist!\n) toconsole_ halt} if
      save /save_ name {
        exec
        0 0 2 mpiinfo length 1 sub {mpiinfo exch get add} for /pawns name
        /pawnbusy [pawns {true} repeat] def
        mpiinfo makerthreads /socket name
        -1 setcurrent
        currentdict /newwin known ~newwin if
        
        socket ~[mpisize {exch pop vmresize} ~lock] send
        socket {
          {
            exch not {abort} if
            /fbuf vmstatus sub 10 div /b array def
            dup capsave
            getstartupdir (startup_dpawn.d) fbuf readfile mkact exec
            dnoderespond
            restore
          } lock
        } send
        save_ capsave
      } stopped {kill stop} if
    } lock
  } bind def |]
end def

/rthread_ops {
  /mpisize mpidata get 1 put
} bind def

/rthreads_dicts {
  /mpisize mpidata get 2 put
} bind def

/rthreads_execs {
  /mpisize mpidata get 3 put
} bind def

/rthread_memory {
  /mpisize mpidata get 4 put
} bind def

/rthreads_user {
  /mpisize mpidata get 5 put
} bind def

| [[n /key val ..]...] | --
/rthreads_multi {
  mpidata begin {
    ~rthreads_multi_ rthreads_start
  } stopped end {stop} if
} bind def

| n | --
/rthreads_single {
  mpidata begin {
    ~rthreads_single_ rthreads_start
  } stopped end {stop} if
} bind def

| [n1 (host1) n2 (host2)...]
/rthreads_hosts {
  mpidata begin {
    ~rthreads_hosts_ rthreads_start
  } stopped end {stop} if
} bind def
@ENABLE_RTHREADS_END@

| active | ??
| executes active on dnode if mpi hasn't been setup
|   or no rthread active (cpawn == -1)
| if all rthreads active (cpawn == *), executes on all rthreads,
|  otherwise executes on the chosen rthread (cpawn)
/rthreads_exec {unlock} bind def | Overridden immediately if ENABLE_RTHREADS
@ENABLE_RTHREADS_START@
/rthreads_exec {
  mpidata /cpawn get dup -1 eq {pop unlock} {
    mpidata begin {
      dup makebusy
      save exch ~[~[5 -1 roll ~dnodereceive] ~lock] rsend restore
    } stopped end {stop} if
  } ifelse
} bind def

| -- | --
/rthreads_stop {
  mpidata begin {
    checkrthreads not {(** Rthreads not running!\n) toconsole_ halt} {
      pawns 0 eq {(** No rthreads to stop!\n) toconsole_ halt} if
      -1 checkbusy
      kill
    } ifelse
  } stopped end {stop} if
} bind def

@ENABLE_RTHREADS_END@

|============================= command line interface for dvt =====

/linebuf2 8192 /b array def

| dvt... expect to be locked when called

|  ~exec save knode | ??
/dvtreceive_base {
  userdict /knode put
  dup capsave userdict /dvtsave put
  ~rthreads_exec stopped pop
  userdict /dvtsave get restore
  dvtrespond
} bind def

/dvtrespond {
  save
  console ~[userdict /knode get {dvt begin setready_dnode} ~exec] send 
  restore
} bind def

| save (line) knode | ??
/dvtreceive {
  exch mkact 3 1 roll dvtreceive_base
} bind def

| save (line) knode | ??
/dvtsystem {
  ~tosystem 4 -1 roll 3 -1 roll dvtreceive_base
} bind def

/dvtexecsystem {
  {
    {linebuf2 0 3 -1 roll mkact exec 0 exch getinterval tosystem}
    4 -1 roll 3 -1 roll 
    dvtreceive_base
  } lock
} bind def

|====================== Support for toolboxes and projects =====================
|
| Toolboxes, projects, and snapshots all are modules. A module is a tree of
| objects rooted in a module dictionary, which is referenced in 'userdict'.
| The procedures 'module', '_module', and 'forgetmodule' found in 'userdict'
| support the concept of discardable modules. They involve a 'save' object
| that is referenced under 'mySave' in the dictionary of the module; the name
| of the module is automatically referenced in that dictionary under 'myName'.
| These are the only book keeping devices of a module.
|
| Toolboxes, projects, and snapshots are different varieties of module but 
| there is no formal difference between these modules. The difference is 
| between their uses. 
|
| A toolbox holds a collection of procedures that can subserve a variety of
| projects. Toolboxes can be swapped on the fly, replacing older by newer
| versions without interrupting the continuity of the projects that they
| subserve. The VM space used by the toolbox is reclaimed in the swap.
| The tools 'module' and '_module' found in 'userdict' effect swaps
| transparently.
|
| Toolboxes are not responsible for information that belongs to clients. The
| client must provide the appropriate current dictionary when using a
| tool. The chosen current dictionary belongs to the client and receives
| the objects defined during the activity of tools. This rule is necessary if
| toolboxes are to be swappable, or are to be usable in arbitrary order in
| arbitrary projects.
|
| A project module is a tree of objects that model a reality. The module 
| dictionary is the root of that tree. The project may also comprise private
| tools. A project is typically built in layers that correspond to well-defined
| stages of completion. Thus, besides the organization as a tree of objects,
| there exists an organization of layers, each represented by a 'save' object
| that is referenced under a layer name in the project dictionary itself.
| Individual layers of growth can be built/discarded/rebuilt using the 
| 'layer' and '_layer' tools found in 'userdict'. Note that, unlike 
| removal of a layer of growth from a natural tree, removal of a layer of a
| project does not automatically remove the layers of more recent growth.  
|
| Sometimes it is desirable to store a snapshot of an entire project for later
| retrieval. This concept is supported by the 'savemodule' and
| 'restoremodule' tools found in 'userdict'. The restoration automatically
| discards an existing incarnation of the project by reclaiming the VM space 
| of the project module itself and of all layers of the old project tree.
| It then creates a project as a replica of the snapshot, preserving the
| snapshot itself for future uses. In order to discard a snapshot, apply
| the tool 'forgetmodule' found in userdict.
|
| A snapshot is suited for transfer/retrieval to/from an external VM (using
| 'tobox'/'frombox') or to/from  a text file (using 'tofiles'/'fromfiles').
|
| A subtlety of snapshots involves the reclaiming of VM space that is used
| by layers. When a snapshot is saved, the VM spaces of the project's 
| layers are merged with the VM space of the virgin project. New layers
| may be created and discarded after a project is restored from a snapshot,
| but the VM space taken by that snapshot, which includes all layers of the
| project existing at the time of the snapshot, is reclaimed only when the
| project itself is discarded or replaced by  another snapshot.

|---------------------------- forgetmodule
| /module_name | --
|
| discards the module 'module_name', reclaiming its VM space. 'forgetmodule'
| has to be used with no references to the module existing on stacks.
| It discards not only the module itself, but also all layers of a module 
| that constitutes a project.

/forgetmodule {
  userdict exch 2 copy known {
    get dup class /dictclass eq {
      dup {
        dup class /boxclass eq 3 -1 roll
        /mySave ne and {restore} {pop} ifelse
      } forall
      /mySave get dup class /boxclass eq {restore} {pop} ifelse 
    } {pop} ifelse
  } {pop pop} ifelse
} bind def

|---------------------------- module
| /module_name | /module_name savebox
|
| discards an existing former version of 'module_name', performs a 'save'
| operation.

/module { dup forgetmodule save } bind def

|---------------------------- _module
| /module_name savebox module_dict | --
|
| caps 'savebox', references it under 'mysave' in 'module_dict', references
| '/module_name' under 'myName' in 'module_dict', and references 'module_dict'
| under 'module_name' in 'userdict'.

/_module {
  begin dup capsave /mySave name dup /myName name currentdict end
  userdict 3 -1 roll put
} bind def

|----------------------------- layer
| /layer_name | --
|
| use with the project dictionary as the current dictionary. 'layer'
| discards an existing version of 'layer_name', performs a 'save' operation,
| and references the 'save' object under 'layer_name' in the project
| dictionary.

/layer {
  dup currentdict exch known { 
      dup find dup class /boxclass eq { restore } { pop } ifelse
    } if
  save def
} bind def
| The definitions of objects in the layer must be encapsulated in a 'stopped'
| context:
|
| { definition ... } stopped

|------------------------------ _layer
| boolean /layer_name | boolean
|
| use with the project dictionary as the current dictionary. '_layer'
| checks 'boolean'. If 'boolean' is true (signaling that a 'stop' operation
| has been executed somewhere inside the context of the layer), the 'save'
| object referenced by 'layer_name' is restored, thus discarding the 
| objects accrued in the layer. If 'boolean' is false (signaling that the
| definitions of the layer have been sucessfully executed), the 'save' object
| referenced under 'layer_name' is capped. '_layer' passes on the value of
| 'boolean' to its client.

/_layer {
  find exch { restore true } { capsave false } ifelse 
} bind def 

|------------------------------- savemodule
|  /project_name /snapshot_name | --
|
| Execute 'savemodule' with 'userdict' as the current dictionary. 
| 'savemodule' looks up the module dictionary referenced under
| 'project_name' in 'userdict'. Executes 'save', makes a replica of the module
| tree, caps the 'save' object, and references the 'save' object under
| 'mySave' in the replica. References the replica under 'snapshot_name' in
| 'userdict'. If 'projectname' does not exist or does not reference a
| dictionary, you are asked to Think. 

/savemodule {
  userdict 3 -1 roll 2 copy known
   { get dup class /dictclass eq
     { save exch transcribe exch dup capsave exch
       dup 3 1 roll /mySave put
       def true
     } { pop pop false } ifelse
   } { pop pop pop false } ifelse
  not { (Think!\n) toconsole_ } if
} bind def

|-------------------------------- restoremodule 
|  /snapshot_name | --
|
| Execute 'restoremodule' with 'userdict' as the current dictionary.  
| 'restoremodule' looks up the dictionary referenced under 'snapshot_name'
| in 'userdict'. Looks up the project name referenced under 'myName' in the
| snapshot dictionary. Discards a project existing under that name in 
| 'userdict'. Makes a replica 'snapshot_name' and references that replica
| under the project name in 'userdict'. 

/restoremodule {
  userdict exch get dup /myName get dup forgetmodule
  exch save exch transcribe exch dup capsave exch
  dup 3 1 roll /mySave put
  def
} bind def

|---------------------------- dstate_
| some debugging stuff of alex's, puts
| opstack in userdict->[d_opstack]
| dictstack in userdict->[d_dictstack]
| execstack in userdict->[d_execstack]
/reverse { | [ n1 .. nx ] | [ nx ... n1] 
  [exch dup length 1 sub -1 0 { | \[ [] i
    1 index exch get | \[ [] x
    exch | \[ x []   
  } for pop]
} bind def

/dstate_ {
  countexecstack list execstack dup length 1 sub 0 exch getinterval
    reverse
    userdict /d_execstack put

  [count 1 ne {count 1 roll} if] dup
    reverse
    userdict /d_opstack put
    {} forall
    
  countdictstack list dictstack dup length 2 sub 2 exch getinterval
    reverse
    userdict /d_dictstack put
} bind def

|-------------------------------------------- libs_
| Print out shared libraries in order
| that they wre loaded
/libs_ { | -->
  debug_dict begin
  null {dup nextlib not {exit} if} loop   | accumulate all libs
  {
    dup null eq {pop exit} if             | bottom out with null

    begin                                 | enter op lib
    debug_dict begin                      | put libdict over op
    
    line 0                                | get temp buf, index from 0
      2 libnum * number                   | stream output
      * ( : ) text
      hi
      * (\n) text
    0 exch getinterval toconsole_          | output used part
    
    end end                               | pop op lib, debug_dict
  } loop
  end                                     | pop debug_dict
} def

|----------------------- color loader and setup
| [/color_name ...] | -- <<redefines toconsole>>
/make_toconsole {
  userdict /color known not {
    getstartupdir (/color.d) fromfiles
  } if
  color /make_toconsole get exec
  whoami
} bind def

| mousestate /wintype actiondict | -- <<action exec'd>> 
/mouseaction {/actiondict name
  | bottom 8 bits are the modifier keys, bottom 8 of top 16 is mouse button
  | Why? No clear reason.
  exch dup -16 bitshift /mB name 255 and /mM name | /wintype
  false mousedict 3 -1 roll get {                 | false /event {}
    actiondict 2 index known not {pop pop} {
      exec {exch pop true exit} {pop} ifelse
    } ifelse
  } forall
  {actiondict exch get exec true} {false} ifelse
} bind def

| (base-dir) (file) | --
/convert_from_32 {
  save /cstate name {
    /filename name
    /dirname name
    
    /boxfile
      filename length 4 add /b array 0 filename fax (.box) fax pop
    def
    /olddirname
      dirname length 5 add /b array 0 dirname fax (/old/) fax pop
    def
    /newdirname
      dirname length 1 add /b array 0 dirname fax (/) fax pop
    def

    olddirname boxfile readf32 newdirname boxfile writeboxfile
  } stopped cstate restore {stop} if
} bind def

| (base-dir) | --
/convertdir_from_32 {
  save /cdstate name {
    dup length 1 add /b array 0 3 -1 roll fax (/) fax pop /basedirname name
    basedirname length 4 add /b array 0 basedirname fax (old/) fax pop
    /oldbasedirname name
    
    oldbasedirname findfiles {
      0 get (.box$) regex not {pop} {pop /basefilename name pop pop
        (Converting: ) toconsole
        basedirname toconsole basefilename toconsole (\n) toconsole
        basedirname basefilename convert_from_32
        (Done\n) toconsole
      } ifelse
    } forall
  } stopped cdstate restore {stop} if
} bind def

|------------------------------------------------ whoami
| prints name and port
| for use with make_toconsole to identify who looks like who
| -- | -- <<printout>>
|
/whoami ~[
  1024 /b array {
    0 
    myname fax
    (:) fax
    * getmyport * number
    (\n) fax
    0 exch getinterval toconsole_
  } ~exec
] bind def

Xwindows_ {
  /take_input_focus {
    {[
      console dup null eq {pop} {
        {Xwindows {userdict begin take_input_focus} if restore} send
      } ifelse |]
    } stopped cleartomark
    end
  } bind def

  /delete_window {end} bind def | default delete action is nothing.
} if

(Using startup_dnode.d $Id$ V@PACKAGE_VERSION@\n) toconsole
  
(Home:  ) toconsole gethomedir toconsole (\n) toconsole
(Startup: ) toconsole getstartupdir toconsole (\n) toconsole
(Plugins: ) toconsole getplugindir toconsole (\n) toconsole

getstartupdir (errors.d) fromfiles
getstartupdir (matrix.d) fromfiles

(Trying ) toconsole getconfdir toconsole (dnode.d...\n) toconsole
getconfdir (dnode.d) fromxfiles {
  (Read ) toconsole getconfdir toconsole (dnode.d\n) toconsole
} if
(Trying ~/.dnode ...\n) toconsole
gethomedir (.dnode) fromxfiles {(Read ~/.dnode\n) toconsole_} if
