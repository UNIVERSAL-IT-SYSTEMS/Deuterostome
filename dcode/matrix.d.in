/MATRIX module 200 dict dup begin

/userdef {
  ~[currentdict ~begin 4 -1 roll ~stopped ~end {stop} ~if] bind
  userdict 3 -1 roll put
} bind def

|======================= cuts
|
| Make a cut array in place:
| <l dim_s ... dim_f> | <l dim_f*..*dim_s ... dim_f>
|

/cuts {
  1 1 index length 1 sub -1 0 {/i name | <l> mul
    1 index i get mul                  | <l> mul*<l>_i
    dup 2 index i put                  | <l> mul*<l>_i
  } for
  pop
} bind userdef

|===================== cut
|
| Get a submatrix (row, plane...):
| matrix cuts i | submatrix cuts

/cut {
  /i name                             | matrix cuts_0n
  1 1 index length 1 sub getinterval  | matrix cuts_1n
  dup 0 get /sz name                  | matrix cuts_1n
  exch sz i mul sz getinterval        | cuts_1n submatrix
  exch | }                            | submatrix cuts_1n
} bind userdef

@ENABLE_ATLAS_START@

|========================== matmul_blas
|
| Generic form:
| C <cuts> beta A <cuts> trans B <cuts> trans alpha | C <cuts>
| alpha*A^t?*B^t? + beta*C -> C
| C may not be A or B, but A may be B.
|
| You should know the dimensionality of C:
| C ~ m x n, where m is rows of A^t? and n is columns of B^t?
|
| The following are some simplified forms


|--- matmul_simple
|
| C <cuts> A <cuts> B <cuts> | C <cuts>
| A*B -> C

/matmul_simple {
  0 5 1 roll
  false 3 1 roll
  false 1
  matmul_blas
} bind userdef

|---- matmul_trans
|
| C <cuts> A <cuts> transA B <cuts> transB | C <cuts>
| A^t?*B^t? -> C

/matmul_trans {
  0 7 1 roll 1 matmul_blas
} bind userdef

|----- matmul_sum
|
| C <cuts> beta A <cuts> B <cuts> alpha | C <cuts>
| alpha*A*B + beta*C -> C

/matmul_sum {
  false 4 1 roll false exch matmul_blas
} bind userdef

@ENABLE_ATLAS_END@

end _module
