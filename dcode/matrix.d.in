/MATRIX module 200 dict dup begin

|======================= cuts
|
| Make a cut array in place:
| <l dim_s ... dim_f> | <l dim_f*..*dim_s ... dim_f>
|

/cuts {
  MATRIX begin | {
    1 1 index length 1 sub -1 0 {/i name | <l> mul
      1 index i get mul                  | <l> mul*<l>_i
      dup 2 index i put                  | <l> mul*<l>_i
    } for
    pop | }
  end
} bind def

|===================== cut
|
| Get a submatrix (row, plane...):
| matrix cuts i | submatrix cuts

/cut {
  MATRIX begin | {
    /i name                             | matrix cuts_0n
    1 1 index length 1 sub getinterval  | matrix cuts_1n
    dup 0 get /sz name                  | matrix cuts_1n
    exch sz i mul sz getinterval        | cuts_1n submatrix
    exch | }                            | submatrix cuts_1n
  end
} bind def


@ENABLE_LAPACK_START@

|========================== matmul_blas
|
| Generic form:
| C <cuts> beta A <cuts> trans B <cuts> trans alpha | C <cuts>
| alpha*A^t?*B^t? + beta*C -> C
| C may not be A or B, but A may be B.
|
| You should know the dimensionality of C:
| C ~ m x n, where m is rows of A^t? and n is columns of B^t?
|
| The following are some simplified forms


|--- matmul_simple
|
| C <cuts> A <cuts> B <cuts> | C <cuts>
| A*B -> C

/matmul_simple {
  0 5 1 roll
  false 3 1 roll
  false 1
  matmul_blas
} bind def

|---- matmul_trans
|
| C <cuts> A <cuts> transA B <cuts> transB | C <cuts>
| A^t?*B^t? -> C

/matmul_trans {
  0 7 1 roll 1 matmul_blas
} bind def

|----- matmul_sum
|
| C <cuts> beta A <cuts> B <cuts> alpha | C <cuts>
| alpha*A*B + beta*C -> C

/matmul_sum {
  false 4 1 roll false exch matmul_blas
} bind def

@ENABLE_LAPACK_END@

end _module
