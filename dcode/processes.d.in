/PROCESSES 100 {
  | These need to be in the same order as
  |  flags struct array in dm-proc.c.
  /FFLAGS {
    /READ_ONLY
    /WRITE_TRUNCATE
    /WRITE_APPEND
  } makeenum def

  /STDIN  0 true  makefd def
  /STDOUT 1 false makefd def
  /STDERR 2 false makefd def
  /NULLR  3 true  makefd def
  /NULLW  4 false makefd def

  /fds ~[
    STDIN STDOUT STDERR
  ] bind def
  
  /nfds ~[
    NULLR NULLW NULLW
  ] bind def

  | oldfd newfd | --
  /stddup {
    1 index exch dupfd close
  } bind def

  | (dir) (file) | fd
  /wropen {
    2 copy () 3 1 roll writefile
    FFLAGS /WRITE_APPEND get openfd
  } bind def

  | fd | --
  /close {
    (close) dout
    dup unmakefd 5 lt ~pop ~closefd ifelse
  } bind def

  /closeifopen {
    dup closedfd ~pop ~close ifelse
  } bind def
  
  /pidsockets [
    /ll 1000 {{/pid null /socket null} makestruct} makelist
    {/s /p /pd} ~null forall

    /data {~data ll indict} bind

    | pid socket | --
    /prepend {
      ~new ll indict dup /p name data /pd name
      pd /socket put
      pd /pid    put
    } bind

    | list | --
    /del {~del ll indict} bind

    | socket | bool-was-found
    /delsock {/s name
      {dup /p name data /pd name
        pd /socket get dup s ne {pop false} {
          disconnect
          null pd /socket put
          pd /pid get null eq {p del} if
          true
        } ifelse
      } iter gc
    } bind

    | pid | bool-was-found
    /delpid {/s name
      {dup /p name data /pd name
        pd /pid get s ne ~false {
          null pd /pid put
          pd /socket get null eq {p del} if
          true
        } ifelse
      } iter gc
    } bind

    | -- | --
    /clean {
      {dup /p name data /pd name
        null pd /pid put
        pd /socket get dup null eq ~pop {
          disconnect
          null pd /socket put
        } ifelse
        p del true
      } iter pop gc
    } bind

    | pid# | --
    /piddead {/s name
      {dup /p name data /pd name
        pd /pid get dup null eq {pop false} {
          unpid s ne ~false {
            null pd /pid put
            pd /socket get dup null eq ~pop {
              disconnect
              null pd /socket put
            } ifelse
            p del true
          } ifelse
        } ifelse
      } iter pop gc
    } bind

    | pid# | --
    /piddisconnect {/s name
      {dup /p name data /pd name
        pd /pid get dup null eq {pop false} {
          unpid s ne ~false {
            pd /socket get dup null eq ~pop {
              disconnect
              null pd /socket put
            } ifelse
            true
          } ifelse
        } ifelse
      } iter pop gc
    } bind

    | n | pid
    /job {nth data /pid get} bind

    | ~active | bool
    /iter {~iter ll indict} bind

    | n | dict
    /nth {~nth ll indict} bind

    | -- | --
    /jobs {
      0 {
        data /pid get dup null ne {
          jobstr 0 * 4 index       * number (: ) fax
                   * 3 index unpid * number (\n) fax
          0 exch getinterval toconsole
        } if pop
        1 add false
      } iter pop pop
    } bind
    /jobstr 256 /b array

    /gc {
      {dup /p name data /pd name
        pd /pid get null eq {
          pd /socket get null eq {p del} if
        } if
        false
      } iter pop
    } bind
  ] makestruct def

  /debug 1024 /b array def
  | stream (string) | stream
  /dout ~pop bind def | {
    |   /tp name
    |   dup /fd name
    |   getpid unpid  /pid name
    |   fd readonlyfd /ro  name
    |   fd used       /us  name
    |   fd closedfd   /cl  name
    |   cl {-1} {fd unmakefd} ifelse /fd name

    |   debug 0 |{
      |     * pid * number (: ) fax tp fax (: ) fax
      |     (fd=) fax * fd                * number (, ) fax
      |     (cl=) fax * cl {1} {0} ifelse * number (, ) fax
      |     (ro=) fax * ro {1} {0} ifelse * number (, ) fax
      |     (us=) fax * us                * number (\n) fax |}
    |   0 exch getinterval tostderr
    | }


  | ~active fd-in fd-out fd-err | pid
  /bg {
    openlist bg_
  } bind def

  | ~active fd-in fd-out fd-err \[fd-chained... | pid
  /bg_ {
    {
      fork {
        setconsole {
        |       debug 0 (forked: ) fax * getpid unpid * number (\n) fax
        |       0 exch getinterval toconsole
          true PROCESSES /childproc put
          {
            /error {
              userdict begin
              /error ~error def
              console ~[
                2 rollerror getpid unpid {
                  (From child ) fax * 4 -1 roll * number (: ) fax
                  2 rollerror 1024 /b array errormessage fax 1 sub
                } ~warning ~restore
              ] send
              -1 ~die ~quitting PROCESSES indict
            } bind def
          } userdict indict

          {dup class /markclass eq ~exit if closeifopen} loop pop
          {STDERR STDOUT STDIN} {exec
            1 index exch dupfd 3 1 roll
          } forall
          3 ~closeifopen repeat

          ~exec unlock
          {0} {1} ifelse ~die ~quitting PROCESSES indict
        } aborted
        console {(child) /CHILD_FAILURE makeerror} send
        -1 ~die ~quitting PROCESSES indict
      } if | pid socket

      1 index 3 1 roll ~prepend pidsockets indict
      {exch dup class /markclass eq ~exit if pop} loop pop

      5 1 roll 4 ~pop repeat
    } lock
  } bind def

  /quitting {
    {
      console ~[
        ~[
          getpid unpid {~piddead pidsockets indict} ~PROCESSES ~indict
          ~restore
        ] ~lock
      ] send
      exec
    } lock
  } bind def

  | pid /SIGNAME | --
  /kill {
    SIGNALS exch get killpid
  } bind def

  | n | pid 
  /job {~job pidsockets ~indict lock} bind def

  | -- | --
  /jobs {~jobs pidsockets ~indict lock} bind def
  
  | pid | bool
  /wait {
    dup waitpid {0 eq} {pop false} ifelse
    exch unpid ~piddead pidsockets ~indict lock
  } bind def

  | pid (source) | --
  /wait_ {
    dup class /arrayclass ne {(wait)} if
    exch wait (Done\n) toconsole ~pop {/NOSYSTEM makeerror} ifelse
  } bind def

  | ... error-pending socket | -- <<error thrown>>
  /socketdead ~[~[
    /socketdead destruct_execn {                 | ... bool socket {}
      1 index ~delsock pidsockets ~indict lock { | ... bool socket {}
        pop pop ~error if
      } ~exec ifelse                             | --
    } currentdict ~indict
  ] ~lock] bind userdict 3 -1 roll put

  | ~active fd-in fd-out fd-err | true/false
  /fg_ {
    bg wait
  } bind def

  | ~active | --
  /fg {
    fds bg (fg) wait_
  } bind def

  /spawnsh {
    {
      console ~[
        ~[
          getpid unpid {~piddisconnect pidsockets indict} ~PROCESSES ~indict
          ~restore
        ] ~lock
      ] send
      closelist spawn
    } lock
  } bind def

  | \[ (exec) ... fd-in fd-out fd-err | pid
  /sh_ {
    ~spawnsh 4 1 roll bg
    counttomark 1 add 1 roll cleartomark
  } bind def

  | \[ (exec) ... | --
  /sh {
    fds sh_ (sh) wait_
  } bind def

  | \[ ~active ... fd-in fd-out fd-err | pid
  /pipe {
    {
      |  (master: ) toconsole getpid _ pop
      counttomark openlist exch 2 add 1 roll | \[ \[ ~active ...
      STDOUT {                   | \[pid socket... \[~active... out
        2 index class /markclass eq ~exit if

        pipefd 3 copy 7 3 roll   | ... out inr inw ~active out inr inw
        | must close inw in child to avoid file-descriptor loop
        3 1 roll exch STDERR     | ... out inr inw ~active inw inr out STDERR
        openlist 5 -1 roll bg_   | ... out inr inw pid
        counttomark 1 add 1 roll | ... out inr inw
        3 1 roll close close     | ... inw
      } loop                     | \[pid... \[ ~active fd-out

      exch STDIN 2 index STDERR bg   | \[pid ... \[fd-out pid
      3 1 roll close pop             | \[pid ... 
    
      true {                         | \[pid... bool
        exch wait and                | \[pid... bool
        1 index class /markclass eq ~exit if
      } loop                         | \[bool
      exch pop                       | bool
    } 4 1 roll bg                    | \[~active... fd-in fd-out fd-err pid
    counttomark 1 add 1 roll cleartomark | pid
  } bind def

  | \[ ~active ... | --
  /pipefg {
    fds pipe (pipefg) wait_
  } bind def

  | \[ ~active ... fd-in fd-out fd-err | bool
  /andp {
    {
      {
        counttomark dup 1 eq ~pop {-1 roll} ifelse
        fds fg_ not {cleartomark false exit} if
        dup class /markclass eq {pop true exit} if
      } loop
    } 4 1 roll bg
    counttomark 1 add 1 roll cleartomark
  } bind def

  | \[ ~active ... | --
  /andfg {
    fds andp (andfg) wait_
  } bind def

  | \[ ~active ... fd-in fd-out fd-err | bool
  /orp {
    {
      {
        counttomark dup 1 eq ~pop {-1 roll} ifelse
        fds fg_ {cleartomark true exit} if
        dup class /markclass eq {pop false exit} if
      } loop
    } 4 1 roll bg
    counttomark 1 add 1 roll cleartomark
  } bind def

  | \[ ~active ... | --
  /orfg {
    fds orp (orfg) wait_
  } bind def

  | (buffer) offset fd char | (buffer) offset fd true / (buffer) offset false
  /readtomark {
    4 copy pop pop  | (buffer) offset fd char (buffer) offset
    1 index length exch sub getinterval 3 -1 roll
    | (buffer) offset (subbuffer) fd char
    readtomarkfd    | (buffer) offset (subbuffer) /fd true/false/
    dup {4 -2 roll} {3 -1 roll} if
    | (buffer) /fd true/false/ offset (subbuffer)
    length add 1 index {3 -1 roll} ~exch ifelse
    | (buffer) offset /fd true/false/
  } bind def

  | (buffer) offset fd | (buffer) offset fd true / (buffer) offset false
  /readline {
    (\n) readtomark
  } bind def

  | \[(exec) ... | (string)
  /readresult {
    {
      pipefd 2 copy counttomark 1 add 2 roll | pr pw \[.. pr pw 
      exch pop STDIN exch STDERR             | \[.. STDIN pw STDERR
      sh_ wait not {                         | pr pw
        close close                          | --
        (readresult) /NOSYSTEM makeerror     | --
      } if                                   | pr pw
      close (\n) readtomarkfd_nb             | (buffer) pr true / (buffer) false
      ~close if                              | (buffer)
    } /readresult_ inlayer
    dup length /b array copy
  } bind def

  | (dir) (file) norecur-bool | --
  /_removepath {
    /norecur exch {{/DIR_NOTEMPTY makeerror}} {null mkact} ifelse def
    __removepath
  } bind def

  | (dir) (file) <</norecur defined>> | --
  /__removepath {
    2 copy fileisdir {
      2 copy finddir {
        norecur
        {1 index exch __removepath} forall pop
      } if
    } if
    rmpath
  } bind def

  | (dir) (file) | --
  /removefile {
    true ~_removepath /removepath_ ~inlayer PROCESSES indict
  } bind def

  | (dir) (file) bool | --
  /removedir {
    false ~_removepath /removepath_ ~inlayer PROCESSES indict
  } bind def

  | (dir) (subdir) | --
  /setwdirp {
    exch setwdir setwdir
  } bind def

  | linked list of error stream ouputs
  | [ readfd writefd [ readfd writefd [... null ]]]
  /estreamrd null def
  /estreamwt null def

  | -- | writefd
  /estreamopen {
    pipefd dup 3 1 roll
    /estreamwt name
    /estreamrd name
  } def

  | bool | bool
  | if true, output contents of estreams
  /estreamclose {
    estreamwt dup null eq ~pop {
      close estreamrd 1 index {suckfd toconsole} ~close ifelse
      /estreamwt null def /estreamrd null def
    } ifelse
  } bind def

  /estreamerror {
    ~error PROCESSES /childproc known ~exec {
      PROCESSES /estreamdict get /error put
      showerror
    } ifelse
    stop
  } bind def

  /estreamdict 1 dict def

  | ~active | ...
  /estreamwith {
    /estreamerror find {
      estreamopen exch
      /error ~name estreamdict indict
    } PROCESSES indict

    exch estreamdict ~swapdict stopped
    ~estreamclose PROCESSES indict 
    ~stop if
  } bind def

  /tosystem {
    {
      openlist (@ENABLE_BASH@) (-c) 4 -1 roll NULLR NULLW STDERR 
      sh_ wait not {(tosystem) /NOSYSTEM makeerror} if
    } PROCESSES indict
  } bind userdict 3 -1 roll put

  /fromsystem {
    ~pipefd {
      /wt name /rd name {
        openlist (@ENABLE_BASH@) (-c) 4 -1 roll NULLR wt STDERR 
        sh_ wait not {
          wt close rd close
          (fromsystem) /NOSYSTEM makeerror
        } if
        wt close rd suckfd
      } stopped {
        wt closeifopen rd closeifopen
        stop 
      } if
    } /fromsystem_ ~caplayer PROCESSES indict
  } bind userdict 3 -1 roll put
} moduledef
