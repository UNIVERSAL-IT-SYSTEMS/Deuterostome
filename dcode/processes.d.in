/PROCESSES 100 {
  | These need to be in the same order as
  |  flags struct array in dm-proc.c.
  /FFLAGS {
    /READ_ONLY
    /WRITE_TRUNCATE
    /WRITE_APPEND
  } makeenum def

  /STDIN  0 true  makefd def
  /STDOUT 1 false makefd def
  /STDERR 2 false makefd def
  /NULLR  3 true  makefd def
  /NULLW  4 false makefd def

  /fds ~[
    STDIN STDOUT STDERR
  ] bind def
  
  /nfds ~[
    NULLR NULLW NULLW
  ] bind def

  | oldfd newfd | --
  /stddup {
    1 index exch dupfd close
  } bind def

  | (dir) (file) | fd
  /wropen {
    2 copy () 3 1 roll writefile
    FFLAGS /WRITE_APPEND get openfd
  } bind def

  | fd | --
  /close {
    (close) dout
    dup unmakefd 5 lt ~pop ~closefd ifelse
  } bind def

  /closeifopen {
    dup closedfd ~pop ~close ifelse
  } bind def

  /pidsockets 20 dict {
    | n | --
    /makelist {
      {
        /alloc null def
        /free null 3 -1 roll {
          4 dict {
            1 index /next name
            1 index null eq {exch pop} {dup 3 -1 roll /prev put} ifelse
            /socket null def
            /pid null def
            /prev null def
          } 1 index indict
        } repeat def
      } /makefree_ inlayer
    } bind def

    1000 makelist

    | -- | dict
    /allocate {
      free 

      dup /next get
      dup null ne {null 1 index /prev put} if
      /free name

      alloc
      dup null ne {2 copy /prev put} if
      1 index /next put
      /alloc name
    } bind def

    | pid socket | --
    /prepend {
      allocate
      alloc /socket put
      alloc /pid    put
    } bind def
    
    | n | dict
    /nth {
      alloc 0 1 4 -1 roll 1 sub {pop /next get} for
    } bind def

    | dict | --
    /del {
      dup /socket get null ne ~pop {
        dup /pid get null ne ~pop {
          dup /next get null ne {
            dup /prev get 1 index /next get /prev put
          } if
          dup /prev get null ne {
            dup /next get 1 index /prev get /next put
          } {
            dup /next get /alloc name
          } ifelse
          free dup 2 index /next put
          dup null ne {2 copy /prev put} if pop
          /free name
        } ifelse
      } ifelse
    } bind def

    | socket | bool
    /delsock {/s name
      alloc {
        dup null eq {false exit} if
        dup /p name /next get

        p /socket get dup s ne ~pop {
          disconnect
          null p /socket put
          p del
          true exit
        } ifelse
      } loop exch pop
    } bind def

    | pid | bool
    /delpid {/s name
      alloc {
        dup null eq {false exit} if 
        dup /p name /next get

        p /pid get s eq {
          null p /pid put
          p del
          true exit
        } if
      } loop exch pop
    } bind def 

    | -- | --
    /clean {
      null alloc {
        dup null eq ~exit if exch pop
        dup /p name dup /next get
        p /socket get dup null eq ~pop {
          disconnect
          null p /socket put
        } ifelse
        null p /pid put
      } loop pop

      dup null eq ~pop {
        free dup 2 index /next put
        dup null eq {pop pop} {/prev put} ifelse
      
        /free alloc def
        /alloc null def
      } ifelse
    } bind def

    | pid# | --
    /piddead {/s name
      alloc {
        dup null eq ~exit if
        dup /p name /next get
        
        p /pid get dup null eq ~pop {
          unpid s eq {
            null p /pid put
            p /socket get dup null eq ~pop {
              disconnect
              null p /socket put
            } ifelse
            p del
            exit
          } if
        } ifelse
      } loop pop
    } bind def

    | ~active | --
    /iter {/ifunc name
      end currentdict PROCESSES /pidsockets get begin /prevdict name
      alloc {
        dup null eq ~exit if
        dup /next get /ip name
        /ifunc find end ~exec stopped 
        PROCESSES /pidsockets get begin ~stop if
        ip
      } loop pop
    } bind def
      
  } 1 index indict def

  /debug 1024 /b array def
  | stream (string) | stream
  /dout ~pop bind def | {
    |   /tp name
    |   dup /fd name
    |   getpid unpid  /pid name
    |   fd readonlyfd /ro  name
    |   fd used       /us  name
    |   fd closedfd   /cl  name
    |   cl {-1} {fd unmakefd} ifelse /fd name

    |   debug 0 |{
      |     * pid * number (: ) fax tp fax (: ) fax
      |     (fd=) fax * fd                * number (, ) fax
      |     (cl=) fax * cl {1} {0} ifelse * number (, ) fax
      |     (ro=) fax * ro {1} {0} ifelse * number (, ) fax
      |     (us=) fax * us                * number (\n) fax |}
    |   0 exch getinterval tostderr
    | }


  | ~active fd-in fd-out fd-err | pid
  /bg {
    openlist bg_
  } bind def

  | ~active fd-in fd-out fd-err \[fd-chained... | pid
  /bg_ {
    {
      fork {
        setconsole {
        |       debug 0 (forked: ) fax * getpid unpid * number (\n) fax
        |       0 exch getinterval toconsole
          true PROCESSES /childproc put
          {
            /error {
              userdict begin
              /error ~error def
              console ~[
                2 rollerror getpid unpid {
                  (From child ) fax * 4 -1 roll * number (: ) fax
                  2 rollerror 1024 /b array errormessage fax 1 sub
                } ~warning ~restore
              ] send
              -1 ~die ~quitting PROCESSES indict
            } bind def
          } userdict indict

          {dup class /markclass eq ~exit if closeifopen} loop pop
          {STDERR STDOUT STDIN} {exec
            1 index exch dupfd 3 1 roll
          } forall
          3 ~closeifopen repeat

          ~exec unlock
          {0} {1} ifelse ~die ~quitting PROCESSES indict
        } aborted
        console {(child) /CHILD_FAILURE makeerror} send
        -1 ~die ~quitting PROCESSES indict
      } if | pid socket

      1 index 3 1 roll ~prepend pidsockets indict
      {exch dup class /markclass eq ~exit if pop} loop pop

      5 1 roll 4 ~pop repeat
    } lock
  } bind def

  /quitting {
    {
      console ~[
        ~[
          getpid unpid {~piddead pidsockets indict} ~PROCESSES ~indict
          ~restore
        ] ~lock
      ] send
      exec
    } lock
  } bind def

  | pid /SIGNAME | --
  /kill {
    SIGNALS exch get killpid
  } bind def

  | n | pid 
  /job {
    ~nth pidsockets indict /pid get
  } bind def

  /jobstr 256 /b array def
  | -- | --
  /jobs {
    0 {
      /pid get dup null ne {
        jobstr 0 * 4 index       * number (: ) fax
                 * 3 index unpid * number (\n) fax
        0 exch getinterval toconsole
      } if pop
      1 add
    } ~iter pidsockets indict pop
  } bind def
  
  | pid | bool
  /wait {
    dup waitpid {0 eq} {pop false} ifelse
    exch unpid ~piddead pidsockets indict
  } bind def

  | pid (source) | --
  /wait_ {
    dup class /arrayclass ne {(wait)} if
    exch wait (Done\n) toconsole ~pop {/NOSYSTEM makeerror} ifelse
  } bind def

  | ... error-pending socket | -- <<error thrown>>
  /socketdead ~[~[
    /socketdead destruct_execn {           | ... bool socket {}
      1 index ~delsock pidsockets indict { | ... bool socket {}
        pop pop ~error if
      } ~exec ifelse                       | --
    } currentdict ~indict
  ] ~lock] bind userdict 3 -1 roll put

  | ~active fd-in fd-out fd-err | true/false
  /fg_ {
    bg wait
  } bind def

  | ~active | --
  /fg {
    fds bg (fg) wait_
  } bind def

  | \[ (exec) ... fd-in fd-out fd-err | pid
  /sh_ {
    {closelist spawn} 4 1 roll bg
    counttomark 1 add 1 roll cleartomark
  } bind def

  | \[ (exec) ... | --
  /sh {
    fds sh_ (sh) wait_
  } bind def

  | \[ ~active ... fd-in fd-out fd-err | pid
  /pipe {
    {
      |  (master: ) toconsole getpid _ pop
      counttomark openlist exch 2 add 1 roll | \[ \[ ~active ...
      STDOUT {                   | \[pid socket... \[~active... out
        2 index class /markclass eq ~exit if

        pipefd 3 copy 7 3 roll   | ... out inr inw ~active out inr inw
        | must close inw in child to avoid file-descriptor loop
        3 1 roll exch STDERR     | ... out inr inw ~active inw inr out STDERR
        openlist 5 -1 roll bg_   | ... out inr inw pid
        counttomark 1 add 1 roll | ... out inr inw
        3 1 roll close close     | ... inw
      } loop                     | \[pid... \[ ~active fd-out

      exch STDIN 2 index STDERR bg   | \[pid ... \[fd-out pid
      3 1 roll close pop             | \[pid ... 
    
      true {                         | \[pid... bool
        exch wait and                | \[pid... bool
        1 index class /markclass eq ~exit if
      } loop                         | \[bool
      exch pop                       | bool
    } 4 1 roll bg                    | \[~active... fd-in fd-out fd-err pid
    counttomark 1 add 1 roll cleartomark | pid
  } bind def

  | \[ ~active ... | --
  /pipefg {
    fds pipe (pipefg) wait_
  } bind def

  | \[ ~active ... fd-in fd-out fd-err | bool
  /andp {
    {
      {
        counttomark dup 1 eq ~pop {-1 roll} ifelse
        fds fg_ not {cleartomark false exit} if
        dup class /markclass eq {pop true exit} if
      } loop
    } 4 1 roll bg
    counttomark 1 add 1 roll cleartomark
  } bind def

  | \[ ~active ... | --
  /andfg {
    fds andp (andfg) wait_
  } bind def

  | \[ ~active ... fd-in fd-out fd-err | bool
  /orp {
    {
      {
        counttomark dup 1 eq ~pop {-1 roll} ifelse
        fds fg_ {cleartomark true exit} if
        dup class /markclass eq {pop false exit} if
      } loop
    } 4 1 roll bg
    counttomark 1 add 1 roll cleartomark
  } bind def

  | \[ ~active ... | --
  /orfg {
    fds orp (orfg) wait_
  } bind def

  | (buffer) offset fd char | (buffer) offset fd true / (buffer) offset false
  /readtomark {
    4 copy pop pop  | (buffer) offset fd char (buffer) offset
    1 index length exch sub getinterval 3 -1 roll
    | (buffer) offset (subbuffer) fd char
    readtomarkfd    | (buffer) offset (subbuffer) /fd true/false/
    dup {4 -2 roll} {3 -1 roll} if
    | (buffer) /fd true/false/ offset (subbuffer)
    length add 1 index {3 -1 roll} ~exch ifelse
    | (buffer) offset /fd true/false/
  } bind def

  | (buffer) offset fd | (buffer) offset fd true / (buffer) offset false
  /readline {
    (\n) readtomark
  } bind def

  | \[(exec) ... | (string)
  /readresult {
    {
      pipefd 2 copy counttomark 1 add 2 roll | pr pw \[.. pr pw 
      exch pop STDIN exch STDERR             | \[.. STDIN pw STDERR
      sh_ wait not {                         | pr pw
        close close                          | --
        (readresult) /NOSYSTEM makeerror     | --
      } if                                   | pr pw
      close (\n) readtomarkfd_nb             | (buffer) pr true / (buffer) false
      ~close if                              | (buffer)
    } /readresult_ inlayer
    dup length /b array copy
  } bind def

  | (dir) (file) norecur-bool | --
  /_removepath {
    /norecur exch {{/DIR_NOTEMPTY makeerror}} {null mkact} ifelse def
    __removepath
  } bind def

  | (dir) (file) <</norecur defined>> | --
  /__removepath {
    2 copy fileisdir {
      2 copy finddir {
        norecur
        {1 index exch __removepath} forall pop
      } if
    } if
    rmpath
  } bind def

  | (dir) (file) | --
  /removefile {
    true ~_removepath /removepath_ ~inlayer PROCESSES indict
  } bind def

  | (dir) (file) bool | --
  /removedir {
    false ~_removepath /removepath_ ~inlayer PROCESSES indict
  } bind def

  | (dir) (subdir) | --
  /setwdirp {
    exch setwdir setwdir
  } bind def

  | linked list of error stream ouputs
  | [ readfd writefd [ readfd writefd [... null ]]]
  /estreamrd null def
  /estreamwt null def

  | -- | writefd
  /estreamopen {
    pipefd dup 3 1 roll
    /estreamwt name
    /estreamrd name
  } def

  | bool | bool
  | if true, output contents of estreams
  /estreamclose {
    estreamwt dup null eq ~pop {
      close estreamrd 1 index {suckfd toconsole} ~close ifelse
      /estreamwt null def /estreamrd null def
    } ifelse
  } bind def

  /estreamerror {
    ~error PROCESSES /childproc known ~exec {
      PROCESSES /estreamdict get /error put
      showerror
    } ifelse
    stop
  } bind def

  /estreamdict 1 dict def

  | ~active | ...
  /estreamwith {
    /estreamerror find {
      estreamopen exch
      /error ~name estreamdict indict
    } PROCESSES indict

    exch estreamdict ~swapdict stopped
    ~estreamclose PROCESSES indict 
    ~stop if
  } bind def

  /tosystem {
    {
      openlist (@ENABLE_BASH@) (-c) 4 -1 roll NULLR NULLW STDERR 
      sh_ wait not {(tosystem) /NOSYSTEM makeerror} if
    } PROCESSES indict
  } bind userdict 3 -1 roll put

  /fromsystem {
    ~pipefd {
      /wt name /rd name {
        openlist (@ENABLE_BASH@) (-c) 4 -1 roll NULLR wt STDERR 
        sh_ wait not {
          wt close rd close
          (fromsystem) /NOSYSTEM makeerror
        } if
        wt close rd suckfd
      } stopped {
        wt closeifopen rd closeifopen
        stop 
      } if
    } /fromsystem_ ~caplayer PROCESSES indict
  } bind userdict 3 -1 roll put
} moduledef
