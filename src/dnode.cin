#line 2 "@srcdir@/dnode.cin"

#include "dm-config.h"
#include "dm-types.h"

#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <errno.h>
#include <spawn.h>

/*************************************** error handling *****************/

#include "dnode.h"

#define DM_IGNORE_RETURN(a) if (a);

__attribute__ ((unused, format (printf, 3, 4)))
static void error_local(int __status, 
			int __errnum, 
			const char* __format, ...)
{
  char* str;
  int s;

  va_list ap;
  va_start(ap, __format);
  if (vasprintf(&str, __format, ap) != -1) {
    DM_IGNORE_RETURN(write(1, str, strlen(str)));
    free(str);
  }
  if (__errnum) s = asprintf(&str, ": %s\n", strerror(__errnum));
  else s = asprintf(&str, "\n");
  if (s != -1) {
    DM_IGNORE_RETURN(write(1, str, strlen(str)));
    free(str);
  }
  if (__status) exit(__status);
}

#define err(fn, ...) do {						\
    if (fn(__VA_ARGS__) < 0) error_local(EXIT_FAILURE, errno, #fn);	\
  } while (0)

#define perr(fn, ...) do {						\
    int p;								\
    if ((p = posix_##fn(__VA_ARGS__)))					\
      error_local(EXIT_FAILURE, p, "posix_"#fn);			\
  } while (0)

/**********************************************************************/

static sigset_t block_all;
static sigset_t original_set;
static sigset_t alarm_set;

#define RESTART_WAIT (10)

extern char** environ;
static posix_spawnattr_t attrp;
static char** _argv;
static int _argc;
static pid_t pid = 0;

DM_INLINE_STATIC void dnode(void) {
  perr(spawn, &pid, "@dmrunnode@", NULL, &attrp, _argv, environ);
}

DM_INLINE_STATIC void makealarm(int s) {
  sigset_t p;
  alarm(0);
  while (1) {
    err(sigpending, &p);
    if (! sigismember(&p, SIGALRM)) break;

    err(sigemptyset, &p);
    err(sigaddset,   &p, SIGALRM);
    err(sigwaitinfo, &p, NULL);
  }
  alarm(s);
}

static void killterm(int sig) {
  err(kill, pid, SIGKILL);
}

static struct sigaction killterm_sa = {
  .sa_handler = killterm,
  .sa_flags = 0
};

static void die(void) {
  if (! pid) return;

  err(kill, pid, SIGTERM);
  err(sigaction, SIGALRM, &killterm_sa, NULL);
  makealarm(RESTART_WAIT);
  err(sigprocmask, SIG_UNBLOCK, &alarm_set, NULL);

  if (wait(NULL) < 0) err(wait, NULL);
}

DM_INLINE_STATIC int waitchild(int* status) {
  pid_t _pid = pid;
  pid = 0;
  return waitpid(_pid, status, 0);
}

enum SIGSTATE {
  SIGSTATE_NONE,
  SIGSTATE_PROP,
  SIGSTATE_RESTART,
  SIGSTATE_CHILD,
  SIGSTATE_ALARM,
};

DM_INLINE_STATIC enum SIGSTATE nextsig(const sigset_t* sigs, int* sig) {
  static int _sig;
  siginfo_t info;
  if (! sig) sig = &_sig;

  switch ((*sig = sigwaitinfo(sigs, &info))) {
    case -1: error_local(EXIT_FAILURE, errno, "sigwaitinfo");
    case SIGALRM:    return SIGSTATE_ALARM;
    case SIGCHLD:    return SIGSTATE_CHILD;
    case DM_RESTART:
      if (info.si_code == SI_QUEUE && info.si_value.sival_int == 1)
	return SIGSTATE_RESTART;
    // intentional fallthrough
    default: return SIGSTATE_PROP;
  }
}

int main(int argc, char *argv[]) {
  sigset_t main_set, restart_set;
  int status;
  int sig;

  err(sigfillset,  &block_all);
  err(sigemptyset, &original_set);
  err(sigprocmask, SIG_BLOCK, &block_all, &original_set);

  main_set = original_set;
  err(sigaddset,   &main_set, SIGCHLD);

  err(sigemptyset, &restart_set);
  err(sigaddset,   &restart_set, DM_RESTART);
  err(sigaddset,   &restart_set, SIGALRM);

  err(sigemptyset, &alarm_set);
  err(sigaddset,   &alarm_set, SIGALRM);
  err(sigfillset,  &killterm_sa.sa_mask);

  _argv = malloc(sizeof(char*)*(argc+1));
  _argc = argc;

  for (; argc > 0; argc--) _argv[argc] = argv[argc];
  _argv[0] = "@dmrunnode@";

  perr(spawnattr_init,       &attrp);
  perr(spawnattr_setflags,   &attrp, POSIX_SPAWN_SETSIGMASK);
  perr(spawnattr_setsigmask, &attrp, &original_set);

  atexit(die);

 restart:
  dnode();

  while (nextsig(&main_set, &sig) == SIGSTATE_PROP)
    err(kill, pid, sig);
  
  err(waitchild, &status);
  makealarm(RESTART_WAIT);
  if (nextsig(&restart_set, NULL) == SIGSTATE_RESTART)
    goto restart;

  if (WIFEXITED(status)) return WEXITSTATUS(status);
  return -1;
}
