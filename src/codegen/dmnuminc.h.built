#include "threads.h"

#if ENABLE_THREADS
typedef struct {
  B* df_start;
  B* sf_start;
  UL perthread;
  UL leftover;
  D in;
} thread_array_data;
#endif //ENABLE_THREADS

static void DBencode(D t, B *dp)
{
*((B *)dp) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
static void DWencode(D t, B *dp)
{
*((W *)dp) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
static void DLencode(D t, B *dp)
{
*((L *)dp) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
static void DSencode(D t, B *dp)
{
*((S *)dp) = t;
}
static void DDencode(D t, B *dp)
{
*((D *)dp) = t;
}
typedef void (*ENCODEfct)(D,B*);
static ENCODEfct ENCODElist[] = {
DBencode, 
DWencode, 
DLencode, 
DSencode, 
DDencode, 
};

static L BLvalue(B *sp)
{
D t; L tc;
if ((t = *((B *)sp)) == BINF) t = DINF;
*((L *)&tc) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L WLvalue(B *sp)
{
D t; L tc;
if ((t = *((W *)sp)) == WINF) t = DINF;
*((L *)&tc) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L LLvalue(B *sp)
{
D t; L tc;
if ((t = *((L *)sp)) == LINF) t = DINF;
*((L *)&tc) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L SLvalue(B *sp)
{
D t; L tc;
t = *((S *)sp);
*((L *)&tc) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L DLvalue(B *sp)
{
D t; L tc;
t = *((D *)sp);
*((L *)&tc) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
typedef L (*VALUEfct)(B*);
static VALUEfct VALUElist[] = {
BLvalue, 
WLvalue, 
LLvalue, 
SLvalue, 
DLvalue, 
};

static D BDtest(B *sp)
{
D t;
if ((t = *((B *)sp)) == BINF) t = DINF;
return(t);
}
static D WDtest(B *sp)
{
D t;
if ((t = *((W *)sp)) == WINF) t = DINF;
return(t);
}
static D LDtest(B *sp)
{
D t;
if ((t = *((L *)sp)) == LINF) t = DINF;
return(t);
}
static D SDtest(B *sp)
{
D t;
t = *((S *)sp);
return(t);
}
static D DDtest(B *sp)
{
D t;
t = *((D *)sp);
return(t);
}
typedef D (*TESTfct)(B*);
static TESTfct TESTlist[] = {
BDtest, 
WDtest, 
LDtest, 
SDtest, 
DDtest, 
};

static void BBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BBmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BBmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BBmoveSAs(sf, df);
#if ENABLE_THREADS
    else BBmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BBmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; B * d;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BBmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BBmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BBmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BBmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BBmoveAAs(sf,df);
#if ENABLE_THREADS
    else BBmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void BWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void BWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L BWmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void BWmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BWmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BWmoveSAs(sf, df);
#if ENABLE_THREADS
    else BWmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BWmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void BWmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; W * d;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L BWmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void BWmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BWmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BWmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BWmoveAAs(sf,df);
#if ENABLE_THREADS
    else BWmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void BLmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void BLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L BLmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void BLmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BLmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BLmoveSAs(sf, df);
#if ENABLE_THREADS
    else BLmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BLmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void BLmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; L * d;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L BLmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void BLmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BLmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BLmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BLmoveAAs(sf,df);
#if ENABLE_THREADS
    else BLmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void BSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((S *)NUM_VAL(df)) = t;
}

  static void BSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L BSmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = t;
}
  return OK;
  }

  static void BSmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BSmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BSmoveSAs(sf, df);
#if ENABLE_THREADS
    else BSmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BSmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((S *)NUM_VAL(df)) = t;
}

    static void BSmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; S * d;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L BSmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
  return OK;
    }

    static void BSmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BSmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BSmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BSmoveAAs(sf,df);
#if ENABLE_THREADS
    else BSmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void BDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((D *)NUM_VAL(df)) = t;
}

  static void BDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L BDmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = t;
}
  return OK;
  }

  static void BDmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BDmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BDmoveSAs(sf, df);
#if ENABLE_THREADS
    else BDmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BDmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((D *)NUM_VAL(df)) = t;
}

    static void BDmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; D * d;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L BDmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
  return OK;
    }

    static void BDmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BDmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BDmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BDmoveAAs(sf,df);
#if ENABLE_THREADS
    else BDmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void WBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L WBmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void WBmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WBmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WBmoveSAs(sf, df);
#if ENABLE_THREADS
    else WBmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WBmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void WBmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; B * d;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L WBmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void WBmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WBmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WBmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WBmoveAAs(sf,df);
#if ENABLE_THREADS
    else WBmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WWmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WWmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WWmoveSAs(sf, df);
#if ENABLE_THREADS
    else WWmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WWmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; W * d;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WWmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WWmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WWmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WWmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WWmoveAAs(sf,df);
#if ENABLE_THREADS
    else WWmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WLmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void WLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L WLmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void WLmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WLmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WLmoveSAs(sf, df);
#if ENABLE_THREADS
    else WLmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WLmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void WLmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; L * d;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L WLmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void WLmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WLmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WLmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WLmoveAAs(sf,df);
#if ENABLE_THREADS
    else WLmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((S *)NUM_VAL(df)) = t;
}

  static void WSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L WSmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = t;
}
  return OK;
  }

  static void WSmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WSmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WSmoveSAs(sf, df);
#if ENABLE_THREADS
    else WSmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WSmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((S *)NUM_VAL(df)) = t;
}

    static void WSmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; S * d;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L WSmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
  return OK;
    }

    static void WSmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WSmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WSmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WSmoveAAs(sf,df);
#if ENABLE_THREADS
    else WSmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((D *)NUM_VAL(df)) = t;
}

  static void WDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L WDmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = t;
}
  return OK;
  }

  static void WDmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WDmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WDmoveSAs(sf, df);
#if ENABLE_THREADS
    else WDmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WDmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((D *)NUM_VAL(df)) = t;
}

    static void WDmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; D * d;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L WDmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
  return OK;
    }

    static void WDmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WDmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WDmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WDmoveAAs(sf,df);
#if ENABLE_THREADS
    else WDmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void LBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void LBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L LBmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void LBmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LBmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      LBmoveSAs(sf, df);
#if ENABLE_THREADS
    else LBmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void LBmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void LBmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; B * d;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L LBmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void LBmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, LBmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void LBmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) LBmoveAAs(sf,df);
#if ENABLE_THREADS
    else LBmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void LWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void LWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L LWmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void LWmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LWmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      LWmoveSAs(sf, df);
#if ENABLE_THREADS
    else LWmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void LWmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void LWmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; W * d;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L LWmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void LWmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, LWmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void LWmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) LWmoveAAs(sf,df);
#if ENABLE_THREADS
    else LWmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void LLmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LLmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LLmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      LLmoveSAs(sf, df);
#if ENABLE_THREADS
    else LLmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void LLmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; L * d;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LLmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LLmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, LLmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void LLmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) LLmoveAAs(sf,df);
#if ENABLE_THREADS
    else LLmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void LSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((S *)NUM_VAL(df)) = t;
}

  static void LSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L LSmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = t;
}
  return OK;
  }

  static void LSmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LSmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      LSmoveSAs(sf, df);
#if ENABLE_THREADS
    else LSmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void LSmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((S *)NUM_VAL(df)) = t;
}

    static void LSmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; S * d;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L LSmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
  return OK;
    }

    static void LSmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, LSmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void LSmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) LSmoveAAs(sf,df);
#if ENABLE_THREADS
    else LSmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void LDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((D *)NUM_VAL(df)) = t;
}

  static void LDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L LDmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = t;
}
  return OK;
  }

  static void LDmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LDmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      LDmoveSAs(sf, df);
#if ENABLE_THREADS
    else LDmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void LDmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((D *)NUM_VAL(df)) = t;
}

    static void LDmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; D * d;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L LDmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
  return OK;
    }

    static void LDmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, LDmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void LDmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) LDmoveAAs(sf,df);
#if ENABLE_THREADS
    else LDmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SBmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void SBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * d;
    d = (B *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L SBmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void SBmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SBmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SBmoveSAs(sf, df);
#if ENABLE_THREADS
    else SBmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SBmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void SBmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; B * d;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L SBmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void SBmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SBmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SBmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SBmoveAAs(sf,df);
#if ENABLE_THREADS
    else SBmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SWmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void SWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * d;
    d = (W *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L SWmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void SWmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SWmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SWmoveSAs(sf, df);
#if ENABLE_THREADS
    else SWmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SWmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void SWmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; W * d;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L SWmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void SWmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SWmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SWmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SWmoveAAs(sf,df);
#if ENABLE_THREADS
    else SWmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SLmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void SLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * d;
    d = (L *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L SLmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void SLmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SLmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SLmoveSAs(sf, df);
#if ENABLE_THREADS
    else SLmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SLmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void SLmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; L * d;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L SLmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void SLmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SLmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SLmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SLmoveAAs(sf,df);
#if ENABLE_THREADS
    else SLmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SSmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((S *)NUM_VAL(df)) = t;
}

  static void SSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * d;
    d = (S *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = t;
}
  return OK;
  }

  static void SSmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SSmoveSAs(sf, df);
#if ENABLE_THREADS
    else SSmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SSmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((S *)NUM_VAL(df)) = t;
}

    static void SSmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; S * d;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SSmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
  return OK;
    }

    static void SSmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SSmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SSmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SSmoveAAs(sf,df);
#if ENABLE_THREADS
    else SSmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SDmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((D *)NUM_VAL(df)) = t;
}

  static void SDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * d;
    d = (D *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = t;
}
  return OK;
  }

  static void SDmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SDmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SDmoveSAs(sf, df);
#if ENABLE_THREADS
    else SDmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SDmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((D *)NUM_VAL(df)) = t;
}

    static void SDmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; D * d;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SDmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
  return OK;
    }

    static void SDmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SDmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SDmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SDmoveAAs(sf,df);
#if ENABLE_THREADS
    else SDmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DBmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void DBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * d;
    d = (B *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L DBmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void DBmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DBmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DBmoveSAs(sf, df);
#if ENABLE_THREADS
    else DBmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DBmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void DBmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; B * d;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L DBmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void DBmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DBmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DBmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DBmoveAAs(sf,df);
#if ENABLE_THREADS
    else DBmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DWmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void DWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * d;
    d = (W *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L DWmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void DWmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DWmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DWmoveSAs(sf, df);
#if ENABLE_THREADS
    else DWmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DWmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void DWmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; W * d;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L DWmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void DWmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DWmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DWmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DWmoveAAs(sf,df);
#if ENABLE_THREADS
    else DWmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DLmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void DLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * d;
    d = (L *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L DLmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void DLmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DLmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DLmoveSAs(sf, df);
#if ENABLE_THREADS
    else DLmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DLmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void DLmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; L * d;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L DLmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void DLmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DLmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DLmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DLmoveAAs(sf,df);
#if ENABLE_THREADS
    else DLmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DSmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((S *)NUM_VAL(df)) = t;
}

  static void DSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * d;
    d = (S *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = t;
}
  return OK;
  }

  static void DSmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DSmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DSmoveSAs(sf, df);
#if ENABLE_THREADS
    else DSmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DSmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((S *)NUM_VAL(df)) = t;
}

    static void DSmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; S * d;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DSmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
  return OK;
    }

    static void DSmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DSmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DSmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DSmoveAAs(sf,df);
#if ENABLE_THREADS
    else DSmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DDmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((D *)NUM_VAL(df)) = t;
}

  static void DDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * d;
    d = (D *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDmoveSAt(UL id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = t;
}
  return OK;
  }

  static void DDmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDmoveSAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DDmoveSAs(sf, df);
#if ENABLE_THREADS
    else DDmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DDmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((D *)NUM_VAL(df)) = t;
}

    static void DDmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; D * d;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DDmoveAAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
  return OK;
    }

    static void DDmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDmoveAAs(sf, df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DDmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DDmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DDmoveAAs(sf,df);
#if ENABLE_THREADS
    else DDmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

typedef void (*MOVEfct)(B*,B*);
static MOVEfct MOVElist[] = {
BBmoveSS, BBmoveSA, BBmoveAS, BBmoveAA, 
BWmoveSS, BWmoveSA, BWmoveAS, BWmoveAA, 
BLmoveSS, BLmoveSA, BLmoveAS, BLmoveAA, 
BSmoveSS, BSmoveSA, BSmoveAS, BSmoveAA, 
BDmoveSS, BDmoveSA, BDmoveAS, BDmoveAA, 
WBmoveSS, WBmoveSA, WBmoveAS, WBmoveAA, 
WWmoveSS, WWmoveSA, WWmoveAS, WWmoveAA, 
WLmoveSS, WLmoveSA, WLmoveAS, WLmoveAA, 
WSmoveSS, WSmoveSA, WSmoveAS, WSmoveAA, 
WDmoveSS, WDmoveSA, WDmoveAS, WDmoveAA, 
LBmoveSS, LBmoveSA, LBmoveAS, LBmoveAA, 
LWmoveSS, LWmoveSA, LWmoveAS, LWmoveAA, 
LLmoveSS, LLmoveSA, LLmoveAS, LLmoveAA, 
LSmoveSS, LSmoveSA, LSmoveAS, LSmoveAA, 
LDmoveSS, LDmoveSA, LDmoveAS, LDmoveAA, 
SBmoveSS, SBmoveSA, SBmoveAS, SBmoveAA, 
SWmoveSS, SWmoveSA, SWmoveAS, SWmoveAA, 
SLmoveSS, SLmoveSA, SLmoveAS, SLmoveAA, 
SSmoveSS, SSmoveSA, SSmoveAS, SSmoveAA, 
SDmoveSS, SDmoveSA, SDmoveAS, SDmoveAA, 
DBmoveSS, DBmoveSA, DBmoveAS, DBmoveAA, 
DWmoveSS, DWmoveSA, DWmoveAS, DWmoveAA, 
DLmoveSS, DLmoveSA, DLmoveAS, DLmoveAA, 
DSmoveSS, DSmoveSA, DSmoveAS, DSmoveAA, 
DDmoveSS, DDmoveSA, DDmoveAS, DDmoveAA, 

};

static void BBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BBdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BBdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyADDASs(df, sf);
#if ENABLE_THREADS
    else BBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BBdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BBdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BBdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BBdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BBdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BBdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BBdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdySUBASs(df, sf);
#if ENABLE_THREADS
    else BBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BBdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BBdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BBdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BBdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BBdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BBdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BBdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyMULASs(df, sf);
#if ENABLE_THREADS
    else BBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BBdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BBdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BBdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BBdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BBdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BBdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BBdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BBdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BBdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BBdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BBdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BBdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BBdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BBdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BBdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BBdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BBdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BBdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BBdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BBdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BBdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BBdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyMODASs(df, sf);
#if ENABLE_THREADS
    else BBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BBdyMODSA(B* df, B *sf)
  {
    BBdyMODSAs(df, sf);
  }

    static void BBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BBdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BBdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BBdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BBdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, BBdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BBdyTHEARCSA(B* df, B *sf)
  {
    BBdyTHEARCSAs(df, sf);
  }

    static void BBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BBdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BBdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BBdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BWdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, BWdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyADDASs(df, sf);
#if ENABLE_THREADS
    else BWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BWdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BWdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BWdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BWdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BWdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BWdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, BWdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdySUBASs(df, sf);
#if ENABLE_THREADS
    else BWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BWdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BWdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BWdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BWdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BWdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BWdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, BWdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyMULASs(df, sf);
#if ENABLE_THREADS
    else BWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BWdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BWdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BWdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BWdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BWdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BWdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, BWdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BWdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BWdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BWdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BWdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BWdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BWdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, BWdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BWdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BWdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BWdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BWdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BWdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BWdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BWdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, BWdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyMODASs(df, sf);
#if ENABLE_THREADS
    else BWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BWdyMODSA(B* df, B *sf)
  {
    BWdyMODSAs(df, sf);
  }

    static void BWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BWdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BWdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BWdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BWdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, BWdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BWdyTHEARCSA(B* df, B *sf)
  {
    BWdyTHEARCSAs(df, sf);
  }

    static void BWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BWdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BWdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BWdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BLdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BLdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, BLdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BLdyADDASs(df, sf);
#if ENABLE_THREADS
    else BLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BLdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BLdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BLdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BLdyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BLdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BLdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BLdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BLdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BLdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BLdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BLdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, BLdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BLdySUBASs(df, sf);
#if ENABLE_THREADS
    else BLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BLdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BLdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BLdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BLdySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BLdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BLdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BLdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BLdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BLdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BLdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BLdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, BLdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BLdyMULASs(df, sf);
#if ENABLE_THREADS
    else BLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BLdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BLdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BLdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BLdyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BLdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BLdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BLdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BLdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BLdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BLdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BLdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, BLdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BLdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BLdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BLdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BLdyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BLdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BLdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BLdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BLdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BLdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BLdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BLdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, BLdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BLdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BLdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BLdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BLdyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BLdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BLdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BLdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BLdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BLdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BLdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BLdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BLdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BLdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, BLdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BLdyMODASs(df, sf);
#if ENABLE_THREADS
    else BLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BLdyMODSA(B* df, B *sf)
  {
    BLdyMODSAs(df, sf);
  }

    static void BLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BLdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BLdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BLdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BLdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BLdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BLdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, BLdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BLdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BLdyTHEARCSA(B* df, B *sf)
  {
    BLdyTHEARCSAs(df, sf);
  }

    static void BLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BLdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BLdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BLdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BLdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BLdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BSdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyADDASs(df, sf);
#if ENABLE_THREADS
    else BSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BSdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BSdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BSdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BSdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BSdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BSdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdySUBASs(df, sf);
#if ENABLE_THREADS
    else BSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BSdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BSdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BSdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BSdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BSdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BSdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyMULASs(df, sf);
#if ENABLE_THREADS
    else BSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BSdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BSdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BSdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BSdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BSdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BSdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BSdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BSdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BSdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BSdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BSdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BSdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BSdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BSdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BSdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BSdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BSdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BSdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BSdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyMODASs(df, sf);
#if ENABLE_THREADS
    else BSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BSdyMODSA(B* df, B *sf)
  {
    BSdyMODSAs(df, sf);
  }

    static void BSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BSdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BSdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BSdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BSdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BSdyTHEARCSA(B* df, B *sf)
  {
    BSdyTHEARCSAs(df, sf);
  }

    static void BSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BSdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BSdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BSdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BDdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyADDASs(df, sf);
#if ENABLE_THREADS
    else BDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BDdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BDdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BDdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BDdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BDdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BDdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdySUBASs(df, sf);
#if ENABLE_THREADS
    else BDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BDdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void BDdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BDdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BDdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BDdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BDdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyMULASs(df, sf);
#if ENABLE_THREADS
    else BDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BDdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BDdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BDdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BDdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BDdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BDdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BDdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BDdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BDdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BDdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BDdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BDdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BDdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void BDdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BDdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BDdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BDdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BDdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BDdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyMODASs(df, sf);
#if ENABLE_THREADS
    else BDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BDdyMODSA(B* df, B *sf)
  {
    BDdyMODSAs(df, sf);
  }

    static void BDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BDdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BDdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BDdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }

  static void BDdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BDdyTHEARCSA(B* df, B *sf)
  {
    BDdyTHEARCSAs(df, sf);
  }

    static void BDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BDdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
    }

    static void BDdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BDdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WBdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, WBdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyADDASs(df, sf);
#if ENABLE_THREADS
    else WBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WBdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WBdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WBdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WBdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WBdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WBdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, WBdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdySUBASs(df, sf);
#if ENABLE_THREADS
    else WBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WBdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WBdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WBdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WBdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WBdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WBdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, WBdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyMULASs(df, sf);
#if ENABLE_THREADS
    else WBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WBdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WBdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WBdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WBdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WBdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WBdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, WBdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WBdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WBdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WBdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WBdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WBdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WBdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, WBdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WBdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WBdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WBdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WBdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WBdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WBdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WBdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, WBdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyMODASs(df, sf);
#if ENABLE_THREADS
    else WBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WBdyMODSA(B* df, B *sf)
  {
    WBdyMODSAs(df, sf);
  }

    static void WBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WBdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WBdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WBdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WBdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, WBdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WBdyTHEARCSA(B* df, B *sf)
  {
    WBdyTHEARCSAs(df, sf);
  }

    static void WBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WBdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WBdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WBdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WWdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WWdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyADDASs(df, sf);
#if ENABLE_THREADS
    else WWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WWdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WWdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WWdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WWdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WWdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WWdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WWdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdySUBASs(df, sf);
#if ENABLE_THREADS
    else WWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WWdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WWdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WWdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WWdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WWdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WWdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WWdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyMULASs(df, sf);
#if ENABLE_THREADS
    else WWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WWdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WWdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WWdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WWdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WWdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WWdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WWdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WWdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WWdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WWdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WWdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WWdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WWdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WWdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WWdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WWdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WWdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WWdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WWdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WWdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WWdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WWdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyMODASs(df, sf);
#if ENABLE_THREADS
    else WWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WWdyMODSA(B* df, B *sf)
  {
    WWdyMODSAs(df, sf);
  }

    static void WWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WWdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WWdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WWdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WWdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, WWdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WWdyTHEARCSA(B* df, B *sf)
  {
    WWdyTHEARCSAs(df, sf);
  }

    static void WWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WWdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WWdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WWdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WLdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WLdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, WLdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WLdyADDASs(df, sf);
#if ENABLE_THREADS
    else WLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WLdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WLdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WLdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WLdyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WLdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WLdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WLdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WLdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WLdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WLdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WLdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, WLdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WLdySUBASs(df, sf);
#if ENABLE_THREADS
    else WLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WLdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WLdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WLdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WLdySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WLdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WLdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WLdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WLdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WLdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WLdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WLdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, WLdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WLdyMULASs(df, sf);
#if ENABLE_THREADS
    else WLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WLdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WLdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WLdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WLdyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WLdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WLdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WLdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WLdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WLdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WLdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WLdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, WLdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WLdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WLdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WLdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WLdyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WLdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WLdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WLdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WLdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WLdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WLdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WLdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, WLdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WLdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WLdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WLdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WLdyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WLdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WLdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WLdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WLdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WLdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WLdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WLdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WLdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WLdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, WLdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WLdyMODASs(df, sf);
#if ENABLE_THREADS
    else WLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WLdyMODSA(B* df, B *sf)
  {
    WLdyMODSAs(df, sf);
  }

    static void WLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WLdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WLdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WLdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WLdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WLdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WLdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, WLdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WLdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WLdyTHEARCSA(B* df, B *sf)
  {
    WLdyTHEARCSAs(df, sf);
  }

    static void WLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WLdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WLdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WLdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WLdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WLdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WSdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyADDASs(df, sf);
#if ENABLE_THREADS
    else WSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WSdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WSdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WSdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WSdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WSdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WSdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdySUBASs(df, sf);
#if ENABLE_THREADS
    else WSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WSdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WSdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WSdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WSdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WSdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WSdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyMULASs(df, sf);
#if ENABLE_THREADS
    else WSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WSdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WSdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WSdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WSdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WSdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WSdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WSdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WSdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WSdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WSdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WSdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WSdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WSdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WSdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WSdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WSdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WSdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WSdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WSdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyMODASs(df, sf);
#if ENABLE_THREADS
    else WSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WSdyMODSA(B* df, B *sf)
  {
    WSdyMODSAs(df, sf);
  }

    static void WSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WSdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WSdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WSdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WSdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WSdyTHEARCSA(B* df, B *sf)
  {
    WSdyTHEARCSAs(df, sf);
  }

    static void WSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WSdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WSdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WSdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WDdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyADDASs(df, sf);
#if ENABLE_THREADS
    else WDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WDdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WDdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WDdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WDdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WDdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WDdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdySUBASs(df, sf);
#if ENABLE_THREADS
    else WDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WDdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void WDdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WDdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WDdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WDdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WDdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyMULASs(df, sf);
#if ENABLE_THREADS
    else WDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WDdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WDdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WDdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WDdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WDdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WDdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WDdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WDdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WDdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WDdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WDdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WDdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WDdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void WDdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WDdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WDdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WDdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WDdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WDdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyMODASs(df, sf);
#if ENABLE_THREADS
    else WDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WDdyMODSA(B* df, B *sf)
  {
    WDdyMODSAs(df, sf);
  }

    static void WDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WDdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WDdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WDdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }

  static void WDdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WDdyTHEARCSA(B* df, B *sf)
  {
    WDdyTHEARCSAs(df, sf);
  }

    static void WDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WDdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
    }

    static void WDdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WDdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LBdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, LBdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LBdyADDASs(df, sf);
#if ENABLE_THREADS
    else LBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LBdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LBdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LBdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LBdyADDSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LBdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LBdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LBdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LBdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LBdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LBdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, LBdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LBdySUBASs(df, sf);
#if ENABLE_THREADS
    else LBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LBdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LBdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LBdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LBdySUBSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LBdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LBdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LBdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LBdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LBdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LBdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, LBdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LBdyMULASs(df, sf);
#if ENABLE_THREADS
    else LBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LBdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LBdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LBdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LBdyMULSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LBdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LBdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LBdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LBdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LBdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LBdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, LBdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LBdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LBdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LBdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LBdyDIVSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LBdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LBdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LBdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LBdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LBdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LBdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, LBdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LBdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LBdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LBdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LBdyPWRSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LBdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else LBdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LBdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LBdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LBdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LBdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LBdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LBdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, LBdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LBdyMODASs(df, sf);
#if ENABLE_THREADS
    else LBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LBdyMODSA(B* df, B *sf)
  {
    LBdyMODSAs(df, sf);
  }

    static void LBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LBdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LBdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LBdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LBdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LBdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LBdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, LBdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LBdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LBdyTHEARCSA(B* df, B *sf)
  {
    LBdyTHEARCSAs(df, sf);
  }

    static void LBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LBdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LBdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LBdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LBdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LBdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LWdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, LWdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LWdyADDASs(df, sf);
#if ENABLE_THREADS
    else LWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LWdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LWdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LWdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LWdyADDSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LWdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LWdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LWdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LWdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LWdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LWdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, LWdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LWdySUBASs(df, sf);
#if ENABLE_THREADS
    else LWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LWdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LWdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LWdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LWdySUBSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LWdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LWdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LWdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LWdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LWdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LWdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, LWdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LWdyMULASs(df, sf);
#if ENABLE_THREADS
    else LWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LWdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LWdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LWdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LWdyMULSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LWdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LWdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LWdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LWdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LWdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LWdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, LWdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LWdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LWdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LWdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LWdyDIVSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LWdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LWdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LWdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LWdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LWdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LWdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, LWdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LWdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LWdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LWdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LWdyPWRSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LWdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else LWdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LWdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LWdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LWdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LWdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LWdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LWdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, LWdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LWdyMODASs(df, sf);
#if ENABLE_THREADS
    else LWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LWdyMODSA(B* df, B *sf)
  {
    LWdyMODSAs(df, sf);
  }

    static void LWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LWdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LWdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LWdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LWdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LWdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LWdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, LWdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LWdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LWdyTHEARCSA(B* df, B *sf)
  {
    LWdyTHEARCSAs(df, sf);
  }

    static void LWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LWdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LWdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LWdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LWdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LWdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LLdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LLdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LLdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LLdyADDASs(df, sf);
#if ENABLE_THREADS
    else LLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LLdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LLdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LLdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LLdyADDSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LLdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LLdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LLdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LLdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LLdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LLdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LLdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LLdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LLdySUBASs(df, sf);
#if ENABLE_THREADS
    else LLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LLdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LLdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LLdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LLdySUBSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LLdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LLdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LLdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LLdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LLdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LLdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LLdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LLdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LLdyMULASs(df, sf);
#if ENABLE_THREADS
    else LLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LLdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LLdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LLdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LLdyMULSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LLdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LLdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LLdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LLdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LLdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LLdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LLdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LLdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LLdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LLdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LLdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LLdyDIVSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LLdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LLdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LLdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LLdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LLdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LLdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LLdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LLdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LLdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LLdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LLdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LLdyPWRSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LLdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else LLdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LLdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LLdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LLdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LLdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LLdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LLdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LLdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LLdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LLdyMODASs(df, sf);
#if ENABLE_THREADS
    else LLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LLdyMODSA(B* df, B *sf)
  {
    LLdyMODSAs(df, sf);
  }

    static void LLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LLdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LLdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LLdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LLdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LLdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LLdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, LLdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LLdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LLdyTHEARCSA(B* df, B *sf)
  {
    LLdyTHEARCSAs(df, sf);
  }

    static void LLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LLdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LLdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LLdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LLdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LLdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LSdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, LSdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LSdyADDASs(df, sf);
#if ENABLE_THREADS
    else LSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LSdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LSdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LSdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LSdyADDSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LSdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LSdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LSdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LSdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LSdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LSdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, LSdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LSdySUBASs(df, sf);
#if ENABLE_THREADS
    else LSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LSdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LSdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LSdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LSdySUBSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LSdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LSdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LSdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LSdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LSdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LSdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, LSdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LSdyMULASs(df, sf);
#if ENABLE_THREADS
    else LSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LSdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LSdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LSdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LSdyMULSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LSdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LSdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LSdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LSdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LSdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LSdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, LSdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LSdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LSdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LSdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LSdyDIVSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LSdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LSdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LSdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LSdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LSdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LSdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, LSdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LSdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LSdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LSdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LSdyPWRSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LSdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else LSdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LSdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LSdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LSdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LSdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LSdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LSdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, LSdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LSdyMODASs(df, sf);
#if ENABLE_THREADS
    else LSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LSdyMODSA(B* df, B *sf)
  {
    LSdyMODSAs(df, sf);
  }

    static void LSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LSdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LSdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LSdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LSdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LSdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LSdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, LSdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LSdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LSdyTHEARCSA(B* df, B *sf)
  {
    LSdyTHEARCSAs(df, sf);
  }

    static void LSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LSdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LSdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LSdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LSdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LSdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LDdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, LDdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LDdyADDASs(df, sf);
#if ENABLE_THREADS
    else LDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LDdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LDdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LDdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LDdyADDSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LDdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LDdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LDdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LDdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LDdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LDdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, LDdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LDdySUBASs(df, sf);
#if ENABLE_THREADS
    else LDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LDdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void LDdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LDdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LDdySUBSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LDdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LDdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LDdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LDdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LDdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LDdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, LDdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LDdyMULASs(df, sf);
#if ENABLE_THREADS
    else LDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LDdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LDdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LDdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LDdyMULSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LDdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LDdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LDdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LDdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LDdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LDdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, LDdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LDdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LDdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LDdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LDdyDIVSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LDdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LDdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LDdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LDdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LDdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LDdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, LDdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LDdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void LDdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    LDdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, LDdyPWRSAt, &data, ret);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      LDdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else LDdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LDdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LDdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LDdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LDdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LDdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LDdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, LDdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LDdyMODASs(df, sf);
#if ENABLE_THREADS
    else LDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LDdyMODSA(B* df, B *sf)
  {
    LDdyMODSAs(df, sf);
  }

    static void LDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LDdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LDdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LDdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LDdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LDdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void LDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }

  static void LDdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, LDdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LDdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    LDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LDdyTHEARCSA(B* df, B *sf)
  {
    LDdyTHEARCSAs(df, sf);
  }

    static void LDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LDdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
    }

    static void LDdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LDdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, LDdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void LDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) LDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LDdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SBdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, SBdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyADDASs(df, sf);
#if ENABLE_THREADS
    else SBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SBdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SBdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SBdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SBdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SBdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SBdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, SBdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdySUBASs(df, sf);
#if ENABLE_THREADS
    else SBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SBdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SBdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SBdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SBdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SBdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SBdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, SBdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyMULASs(df, sf);
#if ENABLE_THREADS
    else SBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SBdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SBdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SBdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SBdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SBdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SBdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, SBdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SBdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SBdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SBdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SBdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SBdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SBdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, SBdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SBdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SBdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SBdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SBdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SBdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SBdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SBdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, SBdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyMODASs(df, sf);
#if ENABLE_THREADS
    else SBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SBdyMODSA(B* df, B *sf)
  {
    SBdyMODSAs(df, sf);
  }

    static void SBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SBdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SBdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SBdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SBdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, SBdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SBdyTHEARCSA(B* df, B *sf)
  {
    SBdyTHEARCSAs(df, sf);
  }

    static void SBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SBdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SBdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SBdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SWdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, SWdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyADDASs(df, sf);
#if ENABLE_THREADS
    else SWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SWdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SWdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SWdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SWdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SWdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SWdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, SWdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdySUBASs(df, sf);
#if ENABLE_THREADS
    else SWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SWdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SWdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SWdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SWdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SWdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SWdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, SWdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyMULASs(df, sf);
#if ENABLE_THREADS
    else SWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SWdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SWdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SWdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SWdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SWdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SWdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, SWdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SWdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SWdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SWdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SWdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SWdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SWdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, SWdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SWdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SWdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SWdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SWdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SWdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SWdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SWdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, SWdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyMODASs(df, sf);
#if ENABLE_THREADS
    else SWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SWdyMODSA(B* df, B *sf)
  {
    SWdyMODSAs(df, sf);
  }

    static void SWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SWdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SWdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SWdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SWdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, SWdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SWdyTHEARCSA(B* df, B *sf)
  {
    SWdyTHEARCSAs(df, sf);
  }

    static void SWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SWdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SWdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SWdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SLdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SLdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, SLdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SLdyADDASs(df, sf);
#if ENABLE_THREADS
    else SLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SLdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SLdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SLdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SLdyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SLdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SLdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SLdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SLdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SLdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SLdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SLdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, SLdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SLdySUBASs(df, sf);
#if ENABLE_THREADS
    else SLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SLdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SLdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SLdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SLdySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SLdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SLdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SLdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SLdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SLdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SLdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SLdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, SLdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SLdyMULASs(df, sf);
#if ENABLE_THREADS
    else SLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SLdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SLdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SLdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SLdyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SLdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SLdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SLdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SLdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SLdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SLdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SLdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, SLdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SLdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SLdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SLdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SLdyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SLdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SLdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SLdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SLdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SLdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SLdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SLdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, SLdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SLdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SLdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SLdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SLdyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SLdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SLdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SLdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SLdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SLdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SLdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SLdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SLdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SLdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, SLdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SLdyMODASs(df, sf);
#if ENABLE_THREADS
    else SLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SLdyMODSA(B* df, B *sf)
  {
    SLdyMODSAs(df, sf);
  }

    static void SLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SLdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SLdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SLdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SLdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SLdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SLdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, SLdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SLdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SLdyTHEARCSA(B* df, B *sf)
  {
    SLdyTHEARCSAs(df, sf);
  }

    static void SLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SLdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SLdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SLdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SLdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SLdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SSdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyADDASs(df, sf);
#if ENABLE_THREADS
    else SSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SSdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SSdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SSdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SSdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SSdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SSdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdySUBASs(df, sf);
#if ENABLE_THREADS
    else SSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SSdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SSdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SSdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SSdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SSdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SSdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyMULASs(df, sf);
#if ENABLE_THREADS
    else SSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SSdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SSdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SSdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SSdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SSdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SSdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SSdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SSdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SSdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SSdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SSdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SSdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SSdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SSdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SSdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SSdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SSdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SSdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SSdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyMODASs(df, sf);
#if ENABLE_THREADS
    else SSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SSdyMODSA(B* df, B *sf)
  {
    SSdyMODSAs(df, sf);
  }

    static void SSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SSdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SSdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SSdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SSdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SSdyTHEARCSA(B* df, B *sf)
  {
    SSdyTHEARCSAs(df, sf);
  }

    static void SSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SSdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SSdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SSdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SDdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyADDASs(df, sf);
#if ENABLE_THREADS
    else SDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SDdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SDdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SDdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SDdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SDdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SDdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdySUBASs(df, sf);
#if ENABLE_THREADS
    else SDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SDdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void SDdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SDdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SDdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SDdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SDdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyMULASs(df, sf);
#if ENABLE_THREADS
    else SDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SDdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SDdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SDdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SDdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SDdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
  }

  static void SDdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SDdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SDdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SDdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  return OK;
    }

    static void SDdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SDdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SDdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SDdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void SDdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SDdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SDdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SDdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SDdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SDdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyMODASs(df, sf);
#if ENABLE_THREADS
    else SDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SDdyMODSA(B* df, B *sf)
  {
    SDdyMODSAs(df, sf);
  }

    static void SDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SDdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SDdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SDdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
  }

  static void SDdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SDdyTHEARCSA(B* df, B *sf)
  {
    SDdyTHEARCSAs(df, sf);
  }

    static void SDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SDdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  return OK;
    }

    static void SDdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SDdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DBdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, DBdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyADDASs(df, sf);
#if ENABLE_THREADS
    else DBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DBdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DBdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DBdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DBdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DBdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DBdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, DBdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdySUBASs(df, sf);
#if ENABLE_THREADS
    else DBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DBdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DBdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DBdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DBdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DBdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DBdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, DBdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyMULASs(df, sf);
#if ENABLE_THREADS
    else DBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DBdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DBdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DBdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DBdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DBdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DBdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, DBdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DBdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DBdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DBdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DBdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DBdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DBdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, DBdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DBdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DBdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DBdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DBdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DBdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DBdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DBdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, DBdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyMODASs(df, sf);
#if ENABLE_THREADS
    else DBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DBdyMODSA(B* df, B *sf)
  {
    DBdyMODSAs(df, sf);
  }

    static void DBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DBdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DBdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DBdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DBdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      threads_do(nways, DBdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DBdyTHEARCSA(B* df, B *sf)
  {
    DBdyTHEARCSAs(df, sf);
  }

    static void DBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DBdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DBdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DBdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DWdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, DWdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyADDASs(df, sf);
#if ENABLE_THREADS
    else DWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DWdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DWdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DWdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DWdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DWdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DWdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, DWdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdySUBASs(df, sf);
#if ENABLE_THREADS
    else DWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DWdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DWdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DWdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DWdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DWdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DWdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, DWdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyMULASs(df, sf);
#if ENABLE_THREADS
    else DWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DWdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DWdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DWdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DWdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DWdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DWdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, DWdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DWdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DWdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DWdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DWdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DWdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DWdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, DWdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DWdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DWdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DWdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DWdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DWdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DWdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DWdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, DWdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyMODASs(df, sf);
#if ENABLE_THREADS
    else DWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DWdyMODSA(B* df, B *sf)
  {
    DWdyMODSAs(df, sf);
  }

    static void DWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DWdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DWdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DWdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DWdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      threads_do(nways, DWdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DWdyTHEARCSA(B* df, B *sf)
  {
    DWdyTHEARCSAs(df, sf);
  }

    static void DWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DWdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DWdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DWdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DLdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DLdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, DLdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DLdyADDASs(df, sf);
#if ENABLE_THREADS
    else DLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DLdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DLdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DLdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DLdyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DLdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DLdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DLdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DLdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DLdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DLdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DLdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, DLdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DLdySUBASs(df, sf);
#if ENABLE_THREADS
    else DLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DLdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DLdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DLdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DLdySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DLdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DLdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DLdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DLdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DLdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DLdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DLdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, DLdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DLdyMULASs(df, sf);
#if ENABLE_THREADS
    else DLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DLdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DLdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DLdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DLdyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DLdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DLdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DLdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DLdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DLdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DLdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DLdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, DLdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DLdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DLdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DLdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DLdyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DLdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DLdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DLdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DLdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DLdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DLdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DLdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, DLdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DLdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * s = ((L *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DLdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DLdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DLdyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DLdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DLdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DLdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DLdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DLdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DLdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DLdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DLdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DLdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, DLdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DLdyMODASs(df, sf);
#if ENABLE_THREADS
    else DLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DLdyMODSA(B* df, B *sf)
  {
    DLdyMODSAs(df, sf);
  }

    static void DLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DLdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DLdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DLdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DLdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DLdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DLdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      threads_do(nways, DLdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DLdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DLdyTHEARCSA(B* df, B *sf)
  {
    DLdyTHEARCSAs(df, sf);
  }

    static void DLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DLdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L * s = ((L *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DLdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DLdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DLdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DLdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DSdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyADDASs(df, sf);
#if ENABLE_THREADS
    else DSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DSdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DSdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DSdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DSdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DSdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DSdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdySUBASs(df, sf);
#if ENABLE_THREADS
    else DSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DSdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DSdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DSdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DSdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DSdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DSdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyMULASs(df, sf);
#if ENABLE_THREADS
    else DSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DSdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DSdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DSdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DSdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DSdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DSdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DSdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DSdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DSdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DSdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DSdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DSdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DSdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DSdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DSdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DSdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DSdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DSdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DSdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyMODASs(df, sf);
#if ENABLE_THREADS
    else DSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DSdyMODSA(B* df, B *sf)
  {
    DSdyMODSAs(df, sf);
  }

    static void DSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DSdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DSdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DSdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DSdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DSdyTHEARCSA(B* df, B *sf)
  {
    DSdyTHEARCSAs(df, sf);
  }

    static void DSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DSdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DSdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DSdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyADDASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DDdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyADDASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyADDASs(df, sf);
#if ENABLE_THREADS
    else DDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DDdyADDSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DDdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DDdyADDAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DDdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DDdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdySUBASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DDdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdySUBASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdySUBASs(df, sf);
#if ENABLE_THREADS
    else DDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DDdySUBSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
     *ret = t;
  return OK;
  }
    
  static void DDdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DDdySUBAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DDdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DDdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyMULASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DDdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyMULASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyMULASs(df, sf);
#if ENABLE_THREADS
    else DDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DDdyMULSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DDdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DDdyMULAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DDdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DDdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyDIVASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
  }

  static void DDdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DDdyDIVSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DDdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DDdyDIVAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  return OK;
    }

    static void DDdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DDdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyPWRASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DDdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DDdyPWRSAt(UL id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
     *ret = t;
  return OK;
  }
    
  static void DDdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UL n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
for (n = (n_ >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = (n_ & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DDdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DDdyPWRAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DDdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DDdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyMODASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DDdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyMODASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyMODASs(df, sf);
#if ENABLE_THREADS
    else DDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DDdyMODSA(B* df, B *sf)
  {
    DDdyMODSAs(df, sf);
  }

    static void DDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DDdyMODAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DDdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DDdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyTHEARCASt(UL id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
  }

  static void DDdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DDdyTHEARCSA(B* df, B *sf)
  {
    DDdyTHEARCSAs(df, sf);
  }

    static void DDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DDdyTHEARCAAt(UL id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  return OK;
    }

    static void DDdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DDdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

typedef void (*dyadic_fct)(B*,B*);
static dyadic_fct ADDlist[] = {
BBdyADDSS, BBdyADDAS, BBdyADDSA, BBdyADDAA, 
BWdyADDSS, BWdyADDAS, BWdyADDSA, BWdyADDAA, 
BLdyADDSS, BLdyADDAS, BLdyADDSA, BLdyADDAA, 
BSdyADDSS, BSdyADDAS, BSdyADDSA, BSdyADDAA, 
BDdyADDSS, BDdyADDAS, BDdyADDSA, BDdyADDAA, 
WBdyADDSS, WBdyADDAS, WBdyADDSA, WBdyADDAA, 
WWdyADDSS, WWdyADDAS, WWdyADDSA, WWdyADDAA, 
WLdyADDSS, WLdyADDAS, WLdyADDSA, WLdyADDAA, 
WSdyADDSS, WSdyADDAS, WSdyADDSA, WSdyADDAA, 
WDdyADDSS, WDdyADDAS, WDdyADDSA, WDdyADDAA, 
LBdyADDSS, LBdyADDAS, LBdyADDSA, LBdyADDAA, 
LWdyADDSS, LWdyADDAS, LWdyADDSA, LWdyADDAA, 
LLdyADDSS, LLdyADDAS, LLdyADDSA, LLdyADDAA, 
LSdyADDSS, LSdyADDAS, LSdyADDSA, LSdyADDAA, 
LDdyADDSS, LDdyADDAS, LDdyADDSA, LDdyADDAA, 
SBdyADDSS, SBdyADDAS, SBdyADDSA, SBdyADDAA, 
SWdyADDSS, SWdyADDAS, SWdyADDSA, SWdyADDAA, 
SLdyADDSS, SLdyADDAS, SLdyADDSA, SLdyADDAA, 
SSdyADDSS, SSdyADDAS, SSdyADDSA, SSdyADDAA, 
SDdyADDSS, SDdyADDAS, SDdyADDSA, SDdyADDAA, 
DBdyADDSS, DBdyADDAS, DBdyADDSA, DBdyADDAA, 
DWdyADDSS, DWdyADDAS, DWdyADDSA, DWdyADDAA, 
DLdyADDSS, DLdyADDAS, DLdyADDSA, DLdyADDAA, 
DSdyADDSS, DSdyADDAS, DSdyADDSA, DSdyADDAA, 
DDdyADDSS, DDdyADDAS, DDdyADDSA, DDdyADDAA, 

};
static dyadic_fct SUBlist[] = {
BBdySUBSS, BBdySUBAS, BBdySUBSA, BBdySUBAA, 
BWdySUBSS, BWdySUBAS, BWdySUBSA, BWdySUBAA, 
BLdySUBSS, BLdySUBAS, BLdySUBSA, BLdySUBAA, 
BSdySUBSS, BSdySUBAS, BSdySUBSA, BSdySUBAA, 
BDdySUBSS, BDdySUBAS, BDdySUBSA, BDdySUBAA, 
WBdySUBSS, WBdySUBAS, WBdySUBSA, WBdySUBAA, 
WWdySUBSS, WWdySUBAS, WWdySUBSA, WWdySUBAA, 
WLdySUBSS, WLdySUBAS, WLdySUBSA, WLdySUBAA, 
WSdySUBSS, WSdySUBAS, WSdySUBSA, WSdySUBAA, 
WDdySUBSS, WDdySUBAS, WDdySUBSA, WDdySUBAA, 
LBdySUBSS, LBdySUBAS, LBdySUBSA, LBdySUBAA, 
LWdySUBSS, LWdySUBAS, LWdySUBSA, LWdySUBAA, 
LLdySUBSS, LLdySUBAS, LLdySUBSA, LLdySUBAA, 
LSdySUBSS, LSdySUBAS, LSdySUBSA, LSdySUBAA, 
LDdySUBSS, LDdySUBAS, LDdySUBSA, LDdySUBAA, 
SBdySUBSS, SBdySUBAS, SBdySUBSA, SBdySUBAA, 
SWdySUBSS, SWdySUBAS, SWdySUBSA, SWdySUBAA, 
SLdySUBSS, SLdySUBAS, SLdySUBSA, SLdySUBAA, 
SSdySUBSS, SSdySUBAS, SSdySUBSA, SSdySUBAA, 
SDdySUBSS, SDdySUBAS, SDdySUBSA, SDdySUBAA, 
DBdySUBSS, DBdySUBAS, DBdySUBSA, DBdySUBAA, 
DWdySUBSS, DWdySUBAS, DWdySUBSA, DWdySUBAA, 
DLdySUBSS, DLdySUBAS, DLdySUBSA, DLdySUBAA, 
DSdySUBSS, DSdySUBAS, DSdySUBSA, DSdySUBAA, 
DDdySUBSS, DDdySUBAS, DDdySUBSA, DDdySUBAA, 

};
static dyadic_fct MULlist[] = {
BBdyMULSS, BBdyMULAS, BBdyMULSA, BBdyMULAA, 
BWdyMULSS, BWdyMULAS, BWdyMULSA, BWdyMULAA, 
BLdyMULSS, BLdyMULAS, BLdyMULSA, BLdyMULAA, 
BSdyMULSS, BSdyMULAS, BSdyMULSA, BSdyMULAA, 
BDdyMULSS, BDdyMULAS, BDdyMULSA, BDdyMULAA, 
WBdyMULSS, WBdyMULAS, WBdyMULSA, WBdyMULAA, 
WWdyMULSS, WWdyMULAS, WWdyMULSA, WWdyMULAA, 
WLdyMULSS, WLdyMULAS, WLdyMULSA, WLdyMULAA, 
WSdyMULSS, WSdyMULAS, WSdyMULSA, WSdyMULAA, 
WDdyMULSS, WDdyMULAS, WDdyMULSA, WDdyMULAA, 
LBdyMULSS, LBdyMULAS, LBdyMULSA, LBdyMULAA, 
LWdyMULSS, LWdyMULAS, LWdyMULSA, LWdyMULAA, 
LLdyMULSS, LLdyMULAS, LLdyMULSA, LLdyMULAA, 
LSdyMULSS, LSdyMULAS, LSdyMULSA, LSdyMULAA, 
LDdyMULSS, LDdyMULAS, LDdyMULSA, LDdyMULAA, 
SBdyMULSS, SBdyMULAS, SBdyMULSA, SBdyMULAA, 
SWdyMULSS, SWdyMULAS, SWdyMULSA, SWdyMULAA, 
SLdyMULSS, SLdyMULAS, SLdyMULSA, SLdyMULAA, 
SSdyMULSS, SSdyMULAS, SSdyMULSA, SSdyMULAA, 
SDdyMULSS, SDdyMULAS, SDdyMULSA, SDdyMULAA, 
DBdyMULSS, DBdyMULAS, DBdyMULSA, DBdyMULAA, 
DWdyMULSS, DWdyMULAS, DWdyMULSA, DWdyMULAA, 
DLdyMULSS, DLdyMULAS, DLdyMULSA, DLdyMULAA, 
DSdyMULSS, DSdyMULAS, DSdyMULSA, DSdyMULAA, 
DDdyMULSS, DDdyMULAS, DDdyMULSA, DDdyMULAA, 

};
static dyadic_fct DIVlist[] = {
BBdyDIVSS, BBdyDIVAS, BBdyDIVSA, BBdyDIVAA, 
BWdyDIVSS, BWdyDIVAS, BWdyDIVSA, BWdyDIVAA, 
BLdyDIVSS, BLdyDIVAS, BLdyDIVSA, BLdyDIVAA, 
BSdyDIVSS, BSdyDIVAS, BSdyDIVSA, BSdyDIVAA, 
BDdyDIVSS, BDdyDIVAS, BDdyDIVSA, BDdyDIVAA, 
WBdyDIVSS, WBdyDIVAS, WBdyDIVSA, WBdyDIVAA, 
WWdyDIVSS, WWdyDIVAS, WWdyDIVSA, WWdyDIVAA, 
WLdyDIVSS, WLdyDIVAS, WLdyDIVSA, WLdyDIVAA, 
WSdyDIVSS, WSdyDIVAS, WSdyDIVSA, WSdyDIVAA, 
WDdyDIVSS, WDdyDIVAS, WDdyDIVSA, WDdyDIVAA, 
LBdyDIVSS, LBdyDIVAS, LBdyDIVSA, LBdyDIVAA, 
LWdyDIVSS, LWdyDIVAS, LWdyDIVSA, LWdyDIVAA, 
LLdyDIVSS, LLdyDIVAS, LLdyDIVSA, LLdyDIVAA, 
LSdyDIVSS, LSdyDIVAS, LSdyDIVSA, LSdyDIVAA, 
LDdyDIVSS, LDdyDIVAS, LDdyDIVSA, LDdyDIVAA, 
SBdyDIVSS, SBdyDIVAS, SBdyDIVSA, SBdyDIVAA, 
SWdyDIVSS, SWdyDIVAS, SWdyDIVSA, SWdyDIVAA, 
SLdyDIVSS, SLdyDIVAS, SLdyDIVSA, SLdyDIVAA, 
SSdyDIVSS, SSdyDIVAS, SSdyDIVSA, SSdyDIVAA, 
SDdyDIVSS, SDdyDIVAS, SDdyDIVSA, SDdyDIVAA, 
DBdyDIVSS, DBdyDIVAS, DBdyDIVSA, DBdyDIVAA, 
DWdyDIVSS, DWdyDIVAS, DWdyDIVSA, DWdyDIVAA, 
DLdyDIVSS, DLdyDIVAS, DLdyDIVSA, DLdyDIVAA, 
DSdyDIVSS, DSdyDIVAS, DSdyDIVSA, DSdyDIVAA, 
DDdyDIVSS, DDdyDIVAS, DDdyDIVSA, DDdyDIVAA, 

};
static dyadic_fct PWRlist[] = {
BBdyPWRSS, BBdyPWRAS, BBdyPWRSA, BBdyPWRAA, 
BWdyPWRSS, BWdyPWRAS, BWdyPWRSA, BWdyPWRAA, 
BLdyPWRSS, BLdyPWRAS, BLdyPWRSA, BLdyPWRAA, 
BSdyPWRSS, BSdyPWRAS, BSdyPWRSA, BSdyPWRAA, 
BDdyPWRSS, BDdyPWRAS, BDdyPWRSA, BDdyPWRAA, 
WBdyPWRSS, WBdyPWRAS, WBdyPWRSA, WBdyPWRAA, 
WWdyPWRSS, WWdyPWRAS, WWdyPWRSA, WWdyPWRAA, 
WLdyPWRSS, WLdyPWRAS, WLdyPWRSA, WLdyPWRAA, 
WSdyPWRSS, WSdyPWRAS, WSdyPWRSA, WSdyPWRAA, 
WDdyPWRSS, WDdyPWRAS, WDdyPWRSA, WDdyPWRAA, 
LBdyPWRSS, LBdyPWRAS, LBdyPWRSA, LBdyPWRAA, 
LWdyPWRSS, LWdyPWRAS, LWdyPWRSA, LWdyPWRAA, 
LLdyPWRSS, LLdyPWRAS, LLdyPWRSA, LLdyPWRAA, 
LSdyPWRSS, LSdyPWRAS, LSdyPWRSA, LSdyPWRAA, 
LDdyPWRSS, LDdyPWRAS, LDdyPWRSA, LDdyPWRAA, 
SBdyPWRSS, SBdyPWRAS, SBdyPWRSA, SBdyPWRAA, 
SWdyPWRSS, SWdyPWRAS, SWdyPWRSA, SWdyPWRAA, 
SLdyPWRSS, SLdyPWRAS, SLdyPWRSA, SLdyPWRAA, 
SSdyPWRSS, SSdyPWRAS, SSdyPWRSA, SSdyPWRAA, 
SDdyPWRSS, SDdyPWRAS, SDdyPWRSA, SDdyPWRAA, 
DBdyPWRSS, DBdyPWRAS, DBdyPWRSA, DBdyPWRAA, 
DWdyPWRSS, DWdyPWRAS, DWdyPWRSA, DWdyPWRAA, 
DLdyPWRSS, DLdyPWRAS, DLdyPWRSA, DLdyPWRAA, 
DSdyPWRSS, DSdyPWRAS, DSdyPWRSA, DSdyPWRAA, 
DDdyPWRSS, DDdyPWRAS, DDdyPWRSA, DDdyPWRAA, 

};
static dyadic_fct MODlist[] = {
BBdyMODSS, BBdyMODAS, BBdyMODSA, BBdyMODAA, 
BWdyMODSS, BWdyMODAS, BWdyMODSA, BWdyMODAA, 
BLdyMODSS, BLdyMODAS, BLdyMODSA, BLdyMODAA, 
BSdyMODSS, BSdyMODAS, BSdyMODSA, BSdyMODAA, 
BDdyMODSS, BDdyMODAS, BDdyMODSA, BDdyMODAA, 
WBdyMODSS, WBdyMODAS, WBdyMODSA, WBdyMODAA, 
WWdyMODSS, WWdyMODAS, WWdyMODSA, WWdyMODAA, 
WLdyMODSS, WLdyMODAS, WLdyMODSA, WLdyMODAA, 
WSdyMODSS, WSdyMODAS, WSdyMODSA, WSdyMODAA, 
WDdyMODSS, WDdyMODAS, WDdyMODSA, WDdyMODAA, 
LBdyMODSS, LBdyMODAS, LBdyMODSA, LBdyMODAA, 
LWdyMODSS, LWdyMODAS, LWdyMODSA, LWdyMODAA, 
LLdyMODSS, LLdyMODAS, LLdyMODSA, LLdyMODAA, 
LSdyMODSS, LSdyMODAS, LSdyMODSA, LSdyMODAA, 
LDdyMODSS, LDdyMODAS, LDdyMODSA, LDdyMODAA, 
SBdyMODSS, SBdyMODAS, SBdyMODSA, SBdyMODAA, 
SWdyMODSS, SWdyMODAS, SWdyMODSA, SWdyMODAA, 
SLdyMODSS, SLdyMODAS, SLdyMODSA, SLdyMODAA, 
SSdyMODSS, SSdyMODAS, SSdyMODSA, SSdyMODAA, 
SDdyMODSS, SDdyMODAS, SDdyMODSA, SDdyMODAA, 
DBdyMODSS, DBdyMODAS, DBdyMODSA, DBdyMODAA, 
DWdyMODSS, DWdyMODAS, DWdyMODSA, DWdyMODAA, 
DLdyMODSS, DLdyMODAS, DLdyMODSA, DLdyMODAA, 
DSdyMODSS, DSdyMODAS, DSdyMODSA, DSdyMODAA, 
DDdyMODSS, DDdyMODAS, DDdyMODSA, DDdyMODAA, 

};
static dyadic_fct THEARClist[] = {
BBdyTHEARCSS, BBdyTHEARCAS, BBdyTHEARCSA, BBdyTHEARCAA, 
BWdyTHEARCSS, BWdyTHEARCAS, BWdyTHEARCSA, BWdyTHEARCAA, 
BLdyTHEARCSS, BLdyTHEARCAS, BLdyTHEARCSA, BLdyTHEARCAA, 
BSdyTHEARCSS, BSdyTHEARCAS, BSdyTHEARCSA, BSdyTHEARCAA, 
BDdyTHEARCSS, BDdyTHEARCAS, BDdyTHEARCSA, BDdyTHEARCAA, 
WBdyTHEARCSS, WBdyTHEARCAS, WBdyTHEARCSA, WBdyTHEARCAA, 
WWdyTHEARCSS, WWdyTHEARCAS, WWdyTHEARCSA, WWdyTHEARCAA, 
WLdyTHEARCSS, WLdyTHEARCAS, WLdyTHEARCSA, WLdyTHEARCAA, 
WSdyTHEARCSS, WSdyTHEARCAS, WSdyTHEARCSA, WSdyTHEARCAA, 
WDdyTHEARCSS, WDdyTHEARCAS, WDdyTHEARCSA, WDdyTHEARCAA, 
LBdyTHEARCSS, LBdyTHEARCAS, LBdyTHEARCSA, LBdyTHEARCAA, 
LWdyTHEARCSS, LWdyTHEARCAS, LWdyTHEARCSA, LWdyTHEARCAA, 
LLdyTHEARCSS, LLdyTHEARCAS, LLdyTHEARCSA, LLdyTHEARCAA, 
LSdyTHEARCSS, LSdyTHEARCAS, LSdyTHEARCSA, LSdyTHEARCAA, 
LDdyTHEARCSS, LDdyTHEARCAS, LDdyTHEARCSA, LDdyTHEARCAA, 
SBdyTHEARCSS, SBdyTHEARCAS, SBdyTHEARCSA, SBdyTHEARCAA, 
SWdyTHEARCSS, SWdyTHEARCAS, SWdyTHEARCSA, SWdyTHEARCAA, 
SLdyTHEARCSS, SLdyTHEARCAS, SLdyTHEARCSA, SLdyTHEARCAA, 
SSdyTHEARCSS, SSdyTHEARCAS, SSdyTHEARCSA, SSdyTHEARCAA, 
SDdyTHEARCSS, SDdyTHEARCAS, SDdyTHEARCSA, SDdyTHEARCAA, 
DBdyTHEARCSS, DBdyTHEARCAS, DBdyTHEARCSA, DBdyTHEARCAA, 
DWdyTHEARCSS, DWdyTHEARCAS, DWdyTHEARCSA, DWdyTHEARCAA, 
DLdyTHEARCSS, DLdyTHEARCAS, DLdyTHEARCSA, DLdyTHEARCAA, 
DSdyTHEARCSS, DSdyTHEARCAS, DSdyTHEARCSA, DSdyTHEARCAA, 
DDdyTHEARCSS, DDdyTHEARCAS, DDdyTHEARCSA, DDdyTHEARCAA, 

};

static void BmoNEGS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = -t;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoNEGAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoNEGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoNEGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoNEGA(B *df)
  {
    if (thread_num() == 1) BmoNEGAs(df);
#if ENABLE_THREADS
    else BmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void BmoABSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = fabs(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoABSAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoABSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoABSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoABSA(B *df)
  {
    if (thread_num() == 1) BmoABSAs(df);
#if ENABLE_THREADS
    else BmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void BmoSQRTS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = sqrt(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoSQRTAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoSQRTAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoSQRTAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoSQRTA(B *df)
  {
    if (thread_num() == 1) BmoSQRTAs(df);
#if ENABLE_THREADS
    else BmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void BmoEXPS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = exp(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoEXPAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoEXPAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoEXPAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoEXPA(B *df)
  {
    if (thread_num() == 1) BmoEXPAs(df);
#if ENABLE_THREADS
    else BmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void BmoLNS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = log(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoLNAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoLNAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoLNAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoLNA(B *df)
  {
    if (thread_num() == 1) BmoLNAs(df);
#if ENABLE_THREADS
    else BmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void BmoLGS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = log10(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoLGAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoLGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoLGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoLGA(B *df)
  {
    if (thread_num() == 1) BmoLGAs(df);
#if ENABLE_THREADS
    else BmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void BmoFLOORS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = floor(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoFLOORAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoFLOORAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoFLOORAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoFLOORA(B *df)
  {
    if (thread_num() == 1) BmoFLOORAs(df);
#if ENABLE_THREADS
    else BmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void BmoCEILS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = ceil(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoCEILAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoCEILAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoCEILAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoCEILA(B *df)
  {
    if (thread_num() == 1) BmoCEILAs(df);
#if ENABLE_THREADS
    else BmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void BmoSINS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = sin(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoSINAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoSINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoSINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoSINA(B *df)
  {
    if (thread_num() == 1) BmoSINAs(df);
#if ENABLE_THREADS
    else BmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void BmoCOSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = cos(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoCOSAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoCOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoCOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoCOSA(B *df)
  {
    if (thread_num() == 1) BmoCOSAs(df);
#if ENABLE_THREADS
    else BmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void BmoTANS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = tan(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoTANAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoTANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoTANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoTANA(B *df)
  {
    if (thread_num() == 1) BmoTANAs(df);
#if ENABLE_THREADS
    else BmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void BmoASINS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = asin(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoASINAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoASINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoASINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoASINA(B *df)
  {
    if (thread_num() == 1) BmoASINAs(df);
#if ENABLE_THREADS
    else BmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void BmoACOSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = acos(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoACOSAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoACOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoACOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoACOSA(B *df)
  {
    if (thread_num() == 1) BmoACOSAs(df);
#if ENABLE_THREADS
    else BmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void BmoATANS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = atan(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoATANAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoATANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}
  return OK;
  }
    
  static void BmoATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoATANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoATANA(B *df)
  {
    if (thread_num() == 1) BmoATANAs(df);
#if ENABLE_THREADS
    else BmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void WmoNEGS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = -t;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoNEGAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoNEGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoNEGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoNEGA(B *df)
  {
    if (thread_num() == 1) WmoNEGAs(df);
#if ENABLE_THREADS
    else WmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void WmoABSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = fabs(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoABSAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoABSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoABSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoABSA(B *df)
  {
    if (thread_num() == 1) WmoABSAs(df);
#if ENABLE_THREADS
    else WmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void WmoSQRTS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = sqrt(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoSQRTAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoSQRTAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoSQRTAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoSQRTA(B *df)
  {
    if (thread_num() == 1) WmoSQRTAs(df);
#if ENABLE_THREADS
    else WmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void WmoEXPS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = exp(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoEXPAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoEXPAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoEXPAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoEXPA(B *df)
  {
    if (thread_num() == 1) WmoEXPAs(df);
#if ENABLE_THREADS
    else WmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void WmoLNS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = log(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoLNAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoLNAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoLNAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoLNA(B *df)
  {
    if (thread_num() == 1) WmoLNAs(df);
#if ENABLE_THREADS
    else WmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void WmoLGS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = log10(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoLGAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoLGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoLGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoLGA(B *df)
  {
    if (thread_num() == 1) WmoLGAs(df);
#if ENABLE_THREADS
    else WmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void WmoFLOORS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = floor(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoFLOORAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoFLOORAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoFLOORAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoFLOORA(B *df)
  {
    if (thread_num() == 1) WmoFLOORAs(df);
#if ENABLE_THREADS
    else WmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void WmoCEILS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = ceil(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoCEILAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoCEILAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoCEILAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoCEILA(B *df)
  {
    if (thread_num() == 1) WmoCEILAs(df);
#if ENABLE_THREADS
    else WmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void WmoSINS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = sin(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoSINAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoSINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoSINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoSINA(B *df)
  {
    if (thread_num() == 1) WmoSINAs(df);
#if ENABLE_THREADS
    else WmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void WmoCOSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = cos(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoCOSAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoCOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoCOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoCOSA(B *df)
  {
    if (thread_num() == 1) WmoCOSAs(df);
#if ENABLE_THREADS
    else WmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void WmoTANS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = tan(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoTANAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoTANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoTANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoTANA(B *df)
  {
    if (thread_num() == 1) WmoTANAs(df);
#if ENABLE_THREADS
    else WmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void WmoASINS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = asin(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoASINAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoASINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoASINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoASINA(B *df)
  {
    if (thread_num() == 1) WmoASINAs(df);
#if ENABLE_THREADS
    else WmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void WmoACOSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = acos(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoACOSAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoACOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoACOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoACOSA(B *df)
  {
    if (thread_num() == 1) WmoACOSAs(df);
#if ENABLE_THREADS
    else WmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void WmoATANS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = atan(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoATANAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoATANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}
  return OK;
  }
    
  static void WmoATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoATANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoATANA(B *df)
  {
    if (thread_num() == 1) WmoATANAs(df);
#if ENABLE_THREADS
    else WmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void LmoNEGS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = -t;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoNEGAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoNEGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoNEGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoNEGA(B *df)
  {
    if (thread_num() == 1) LmoNEGAs(df);
#if ENABLE_THREADS
    else LmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void LmoABSS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = fabs(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoABSAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoABSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoABSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoABSA(B *df)
  {
    if (thread_num() == 1) LmoABSAs(df);
#if ENABLE_THREADS
    else LmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void LmoSQRTS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = sqrt(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoSQRTAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoSQRTAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoSQRTAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoSQRTA(B *df)
  {
    if (thread_num() == 1) LmoSQRTAs(df);
#if ENABLE_THREADS
    else LmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void LmoEXPS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = exp(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoEXPAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoEXPAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoEXPAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoEXPA(B *df)
  {
    if (thread_num() == 1) LmoEXPAs(df);
#if ENABLE_THREADS
    else LmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void LmoLNS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = log(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoLNAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoLNAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoLNAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoLNA(B *df)
  {
    if (thread_num() == 1) LmoLNAs(df);
#if ENABLE_THREADS
    else LmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void LmoLGS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = log10(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoLGAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoLGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoLGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoLGA(B *df)
  {
    if (thread_num() == 1) LmoLGAs(df);
#if ENABLE_THREADS
    else LmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void LmoFLOORS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = floor(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoFLOORAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoFLOORAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoFLOORAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoFLOORA(B *df)
  {
    if (thread_num() == 1) LmoFLOORAs(df);
#if ENABLE_THREADS
    else LmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void LmoCEILS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = ceil(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoCEILAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoCEILAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoCEILAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoCEILA(B *df)
  {
    if (thread_num() == 1) LmoCEILAs(df);
#if ENABLE_THREADS
    else LmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void LmoSINS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = sin(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoSINAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoSINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoSINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoSINA(B *df)
  {
    if (thread_num() == 1) LmoSINAs(df);
#if ENABLE_THREADS
    else LmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void LmoCOSS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = cos(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoCOSAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoCOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoCOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoCOSA(B *df)
  {
    if (thread_num() == 1) LmoCOSAs(df);
#if ENABLE_THREADS
    else LmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void LmoTANS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = tan(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoTANAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoTANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoTANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoTANA(B *df)
  {
    if (thread_num() == 1) LmoTANAs(df);
#if ENABLE_THREADS
    else LmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void LmoASINS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = asin(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoASINAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoASINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoASINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoASINA(B *df)
  {
    if (thread_num() == 1) LmoASINAs(df);
#if ENABLE_THREADS
    else LmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void LmoACOSS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = acos(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoACOSAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoACOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoACOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoACOSA(B *df)
  {
    if (thread_num() == 1) LmoACOSAs(df);
#if ENABLE_THREADS
    else LmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void LmoATANS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = atan(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoATANAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoATANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L * d = ((L *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}
  return OK;
  }
    
  static void LmoATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    LmoATANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, LmoATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void LmoATANA(B *df)
  {
    if (thread_num() == 1) LmoATANAs(df);
#if ENABLE_THREADS
    else LmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void SmoNEGS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = -t;
*((S *)NUM_VAL(df)) = t;
}

   static void SmoNEGAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoNEGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoNEGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoNEGA(B *df)
  {
    if (thread_num() == 1) SmoNEGAs(df);
#if ENABLE_THREADS
    else SmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void SmoABSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = fabs(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoABSAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoABSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoABSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoABSA(B *df)
  {
    if (thread_num() == 1) SmoABSAs(df);
#if ENABLE_THREADS
    else SmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void SmoSQRTS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = sqrt(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoSQRTAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoSQRTAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoSQRTAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoSQRTA(B *df)
  {
    if (thread_num() == 1) SmoSQRTAs(df);
#if ENABLE_THREADS
    else SmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void SmoEXPS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = exp(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoEXPAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoEXPAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoEXPAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoEXPA(B *df)
  {
    if (thread_num() == 1) SmoEXPAs(df);
#if ENABLE_THREADS
    else SmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void SmoLNS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = log(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoLNAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoLNAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoLNAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoLNA(B *df)
  {
    if (thread_num() == 1) SmoLNAs(df);
#if ENABLE_THREADS
    else SmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void SmoLGS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = log10(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoLGAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoLGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoLGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoLGA(B *df)
  {
    if (thread_num() == 1) SmoLGAs(df);
#if ENABLE_THREADS
    else SmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void SmoFLOORS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = floor(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoFLOORAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoFLOORAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoFLOORAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoFLOORA(B *df)
  {
    if (thread_num() == 1) SmoFLOORAs(df);
#if ENABLE_THREADS
    else SmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void SmoCEILS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = ceil(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoCEILAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoCEILAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoCEILAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoCEILA(B *df)
  {
    if (thread_num() == 1) SmoCEILAs(df);
#if ENABLE_THREADS
    else SmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void SmoSINS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = sin(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoSINAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoSINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoSINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoSINA(B *df)
  {
    if (thread_num() == 1) SmoSINAs(df);
#if ENABLE_THREADS
    else SmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void SmoCOSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = cos(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoCOSAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoCOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoCOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoCOSA(B *df)
  {
    if (thread_num() == 1) SmoCOSAs(df);
#if ENABLE_THREADS
    else SmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void SmoTANS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = tan(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoTANAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoTANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoTANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoTANA(B *df)
  {
    if (thread_num() == 1) SmoTANAs(df);
#if ENABLE_THREADS
    else SmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void SmoASINS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = asin(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoASINAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoASINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoASINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoASINA(B *df)
  {
    if (thread_num() == 1) SmoASINAs(df);
#if ENABLE_THREADS
    else SmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void SmoACOSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = acos(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoACOSAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoACOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoACOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoACOSA(B *df)
  {
    if (thread_num() == 1) SmoACOSAs(df);
#if ENABLE_THREADS
    else SmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void SmoATANS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = atan(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoATANAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoATANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
  return OK;
  }
    
  static void SmoATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoATANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoATANA(B *df)
  {
    if (thread_num() == 1) SmoATANAs(df);
#if ENABLE_THREADS
    else SmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void DmoNEGS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = -t;
*((D *)NUM_VAL(df)) = t;
}

   static void DmoNEGAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoNEGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoNEGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoNEGA(B *df)
  {
    if (thread_num() == 1) DmoNEGAs(df);
#if ENABLE_THREADS
    else DmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void DmoABSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = fabs(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoABSAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoABSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoABSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoABSA(B *df)
  {
    if (thread_num() == 1) DmoABSAs(df);
#if ENABLE_THREADS
    else DmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void DmoSQRTS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = sqrt(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoSQRTAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoSQRTAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoSQRTAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoSQRTA(B *df)
  {
    if (thread_num() == 1) DmoSQRTAs(df);
#if ENABLE_THREADS
    else DmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void DmoEXPS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = exp(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoEXPAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoEXPAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoEXPAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoEXPA(B *df)
  {
    if (thread_num() == 1) DmoEXPAs(df);
#if ENABLE_THREADS
    else DmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void DmoLNS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = log(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoLNAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoLNAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoLNAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoLNA(B *df)
  {
    if (thread_num() == 1) DmoLNAs(df);
#if ENABLE_THREADS
    else DmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void DmoLGS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = log10(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoLGAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoLGAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoLGAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoLGA(B *df)
  {
    if (thread_num() == 1) DmoLGAs(df);
#if ENABLE_THREADS
    else DmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void DmoFLOORS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = floor(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoFLOORAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoFLOORAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoFLOORAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoFLOORA(B *df)
  {
    if (thread_num() == 1) DmoFLOORAs(df);
#if ENABLE_THREADS
    else DmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void DmoCEILS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = ceil(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoCEILAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoCEILAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoCEILAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoCEILA(B *df)
  {
    if (thread_num() == 1) DmoCEILAs(df);
#if ENABLE_THREADS
    else DmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void DmoSINS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = sin(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoSINAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoSINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoSINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoSINA(B *df)
  {
    if (thread_num() == 1) DmoSINAs(df);
#if ENABLE_THREADS
    else DmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void DmoCOSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = cos(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoCOSAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoCOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoCOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoCOSA(B *df)
  {
    if (thread_num() == 1) DmoCOSAs(df);
#if ENABLE_THREADS
    else DmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void DmoTANS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = tan(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoTANAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoTANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoTANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoTANA(B *df)
  {
    if (thread_num() == 1) DmoTANAs(df);
#if ENABLE_THREADS
    else DmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void DmoASINS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = asin(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoASINAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoASINAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoASINAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoASINA(B *df)
  {
    if (thread_num() == 1) DmoASINAs(df);
#if ENABLE_THREADS
    else DmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void DmoACOSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = acos(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoACOSAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoACOSAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoACOSAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoACOSA(B *df)
  {
    if (thread_num() == 1) DmoACOSAs(df);
#if ENABLE_THREADS
    else DmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void DmoATANS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = atan(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoATANAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoATANAt(UL id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UL n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
  return OK;
  }
    
  static void DmoATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoATANAs(df);
  else {
    thread_array_data data;
    UL nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoATANA(B *df)
  {
    if (thread_num() == 1) DmoATANAs(df);
#if ENABLE_THREADS
    else DmoATANAc(df);
#endif //ENABLE_THREADS
  }

typedef void (*monadic_fct)(B*);
static monadic_fct NEGlist[] = {
BmoNEGS, BmoNEGA, 
WmoNEGS, WmoNEGA, 
LmoNEGS, LmoNEGA, 
SmoNEGS, SmoNEGA, 
DmoNEGS, DmoNEGA, 

};
static monadic_fct ABSlist[] = {
BmoABSS, BmoABSA, 
WmoABSS, WmoABSA, 
LmoABSS, LmoABSA, 
SmoABSS, SmoABSA, 
DmoABSS, DmoABSA, 

};
static monadic_fct SQRTlist[] = {
BmoSQRTS, BmoSQRTA, 
WmoSQRTS, WmoSQRTA, 
LmoSQRTS, LmoSQRTA, 
SmoSQRTS, SmoSQRTA, 
DmoSQRTS, DmoSQRTA, 

};
static monadic_fct EXPlist[] = {
BmoEXPS, BmoEXPA, 
WmoEXPS, WmoEXPA, 
LmoEXPS, LmoEXPA, 
SmoEXPS, SmoEXPA, 
DmoEXPS, DmoEXPA, 

};
static monadic_fct LNlist[] = {
BmoLNS, BmoLNA, 
WmoLNS, WmoLNA, 
LmoLNS, LmoLNA, 
SmoLNS, SmoLNA, 
DmoLNS, DmoLNA, 

};
static monadic_fct LGlist[] = {
BmoLGS, BmoLGA, 
WmoLGS, WmoLGA, 
LmoLGS, LmoLGA, 
SmoLGS, SmoLGA, 
DmoLGS, DmoLGA, 

};
static monadic_fct FLOORlist[] = {
BmoFLOORS, BmoFLOORA, 
WmoFLOORS, WmoFLOORA, 
LmoFLOORS, LmoFLOORA, 
SmoFLOORS, SmoFLOORA, 
DmoFLOORS, DmoFLOORA, 

};
static monadic_fct CEILlist[] = {
BmoCEILS, BmoCEILA, 
WmoCEILS, WmoCEILA, 
LmoCEILS, LmoCEILA, 
SmoCEILS, SmoCEILA, 
DmoCEILS, DmoCEILA, 

};
static monadic_fct SINlist[] = {
BmoSINS, BmoSINA, 
WmoSINS, WmoSINA, 
LmoSINS, LmoSINA, 
SmoSINS, SmoSINA, 
DmoSINS, DmoSINA, 

};
static monadic_fct COSlist[] = {
BmoCOSS, BmoCOSA, 
WmoCOSS, WmoCOSA, 
LmoCOSS, LmoCOSA, 
SmoCOSS, SmoCOSA, 
DmoCOSS, DmoCOSA, 

};
static monadic_fct TANlist[] = {
BmoTANS, BmoTANA, 
WmoTANS, WmoTANA, 
LmoTANS, LmoTANA, 
SmoTANS, SmoTANA, 
DmoTANS, DmoTANA, 

};
static monadic_fct ASINlist[] = {
BmoASINS, BmoASINA, 
WmoASINS, WmoASINA, 
LmoASINS, LmoASINA, 
SmoASINS, SmoASINA, 
DmoASINS, DmoASINA, 

};
static monadic_fct ACOSlist[] = {
BmoACOSS, BmoACOSA, 
WmoACOSS, WmoACOSA, 
LmoACOSS, LmoACOSA, 
SmoACOSS, SmoACOSA, 
DmoACOSS, DmoACOSA, 

};
static monadic_fct ATANlist[] = {
BmoATANS, BmoATANA, 
WmoATANS, WmoATANA, 
LmoATANS, LmoATANA, 
SmoATANS, SmoATANA, 
DmoATANS, DmoATANA, 

};
static void Bdecr(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t -= 1.0;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || (t == DINF))? BINF : t;
}

static void Wdecr(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t -= 1.0;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || (t == DINF))? WINF : t;
}

static void Ldecr(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t -= 1.0;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((t) < -LMAX) || (t == DINF))? LINF : t;
}

static void Sdecr(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t -= 1.0;
*((S *)NUM_VAL(df)) = t;
}

static void Ddecr(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t -= 1.0;
*((D *)NUM_VAL(df)) = t;
}

typedef void (*DECR_fct)(B*);
static DECR_fct DECRlist[] = {
Bdecr, Wdecr, Ldecr, Sdecr, Ddecr, 
};
