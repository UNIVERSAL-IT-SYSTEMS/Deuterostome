#include "threads.h"

#if ENABLE_THREADS
typedef struct {
  B* df_start;
  B* sf_start;
  UP perthread;
  UP leftover;
  D in;
} thread_array_data;
#endif //ENABLE_THREADS

#ifdef DEBUG_DMNUM
#undef DEBUG_DMNUM
#define DEBUG_DMNUM 1
void handleerr(void) {
  makename("dmnumincerror", x1); ATTR(x1) = ACTIVE;
  FREEexecs = x2;
}
#else
#define DEBUG_DMNUM 0
#define handleerr()
#endif

static void DBencode(D t, B *dp)
{
*((B *)dp) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
static void DWencode(D t, B *dp)
{
*((W *)dp) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
static void DL32encode(D t, B *dp)
{
*((L32 *)dp) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
static void DL64encode(D t, B *dp)
{
*((L64 *)dp) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
static void DSencode(D t, B *dp)
{
*((S *)dp) = t;
}
static void DDencode(D t, B *dp)
{
*((D *)dp) = t;
}
typedef void (*ENCODEfct)(D,B*);
static ENCODEfct ENCODElist[] = {
DBencode, 
DWencode, 
DL32encode, 
DL64encode, 
DSencode, 
DDencode, 
};

static LBIG BLvalue(B *sp)
{
D t; LBIG tc;
if ((t = *((B *)sp)) == BINF) t = HUGE_VAL;
*((LBIG *)&tc) = (((t) > LBIGMAX) || ((t) < -LBIGMAX) || ISUNDEF(t))? LBIGINF : t;
return(tc);
}
static LBIG WLvalue(B *sp)
{
D t; LBIG tc;
if ((t = *((W *)sp)) == WINF) t = HUGE_VAL;
*((LBIG *)&tc) = (((t) > LBIGMAX) || ((t) < -LBIGMAX) || ISUNDEF(t))? LBIGINF : t;
return(tc);
}
static LBIG L32Lvalue(B *sp)
{
D t; LBIG tc;
if ((t = *((L32 *)sp)) == L32INF) t = HUGE_VAL;
*((LBIG *)&tc) = (((t) > LBIGMAX) || ((t) < -LBIGMAX) || ISUNDEF(t))? LBIGINF : t;
return(tc);
}
static LBIG L64Lvalue(B *sp)
{
D t; LBIG tc;
if ((t = *((L64 *)sp)) == L64INF) t = HUGE_VAL;
*((LBIG *)&tc) = (((t) > LBIGMAX) || ((t) < -LBIGMAX) || ISUNDEF(t))? LBIGINF : t;
return(tc);
}
static LBIG SLvalue(B *sp)
{
D t; LBIG tc;
t = *((S *)sp);
*((LBIG *)&tc) = (((t) > LBIGMAX) || ((t) < -LBIGMAX) || ISUNDEF(t))? LBIGINF : t;
return(tc);
}
static LBIG DLvalue(B *sp)
{
D t; LBIG tc;
t = *((D *)sp);
*((LBIG *)&tc) = (((t) > LBIGMAX) || ((t) < -LBIGMAX) || ISUNDEF(t))? LBIGINF : t;
return(tc);
}
typedef LBIG (*VALUEfct)(B*);
static VALUEfct VALUElist[] = {
BLvalue, 
WLvalue, 
L32Lvalue, 
L64Lvalue, 
SLvalue, 
DLvalue, 
};

static D BDtest(B *sp)
{
D t;
if ((t = *((B *)sp)) == BINF) t = HUGE_VAL;
return(t);
}
static D WDtest(B *sp)
{
D t;
if ((t = *((W *)sp)) == WINF) t = HUGE_VAL;
return(t);
}
static D L32Dtest(B *sp)
{
D t;
if ((t = *((L32 *)sp)) == L32INF) t = HUGE_VAL;
return(t);
}
static D L64Dtest(B *sp)
{
D t;
if ((t = *((L64 *)sp)) == L64INF) t = HUGE_VAL;
return(t);
}
static D SDtest(B *sp)
{
D t;
t = *((S *)sp);
return(t);
}
static D DDtest(B *sp)
{
D t;
t = *((D *)sp);
return(t);
}
typedef D (*TESTfct)(B*);
static TESTfct TESTlist[] = {
BDtest, 
WDtest, 
L32Dtest, 
L64Dtest, 
SDtest, 
DDtest, 
};

static void BBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BBmoveSAs(B *sf, B *df)
  {
    D t; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BBmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BBmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BBmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BBmoveSAs(sf, df);
#if ENABLE_THREADS
    else BBmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BBmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = HUGE_VAL;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

    static void BBmoveAAs(B *sf, B *df)
    {
       D t; P n; B * s; B * d;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BBmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BBmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BBmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BBmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BBmoveAAs(sf,df);
#if ENABLE_THREADS
    else BBmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void BWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void BWmoveSAs(B *sf, B *df)
  {
    D t; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P BWmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void BWmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BWmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BWmoveSAs(sf, df);
#if ENABLE_THREADS
    else BWmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BWmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = HUGE_VAL;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

    static void BWmoveAAs(B *sf, B *df)
    {
       D t; P n; B * s; W * d;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P BWmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void BWmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BWmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BWmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BWmoveAAs(sf,df);
#if ENABLE_THREADS
    else BWmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void BL32moveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void BL32moveSAs(B *sf, B *df)
  {
    D t; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P BL32moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void BL32moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BL32moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BL32moveSAs(sf, df);
#if ENABLE_THREADS
    else BL32moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BL32moveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = HUGE_VAL;

*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

    static void BL32moveAAs(B *sf, B *df)
    {
       D t; P n; B * s; L32 * d;
       s = (B *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P BL32moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void BL32moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BL32moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BL32moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BL32moveAAs(sf,df);
#if ENABLE_THREADS
    else BL32moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void BL64moveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void BL64moveSAs(B *sf, B *df)
  {
    D t; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P BL64moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void BL64moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BL64moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BL64moveSAs(sf, df);
#if ENABLE_THREADS
    else BL64moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BL64moveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = HUGE_VAL;

*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

    static void BL64moveAAs(B *sf, B *df)
    {
       D t; P n; B * s; L64 * d;
       s = (B *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P BL64moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void BL64moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BL64moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BL64moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BL64moveAAs(sf,df);
#if ENABLE_THREADS
    else BL64moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void BSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
*((S *)NUM_VAL(df)) = t;
}

  static void BSmoveSAs(B *sf, B *df)
  {
    D t; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P BSmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((S *)d++) = t;
}}
  return OK;
  }

  static void BSmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BSmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BSmoveSAs(sf, df);
#if ENABLE_THREADS
    else BSmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BSmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = HUGE_VAL;

*((S *)NUM_VAL(df)) = t;
}

    static void BSmoveAAs(B *sf, B *df)
    {
       D t; P n; B * s; S * d;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P BSmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((S *)d++) = t;
}}
  return OK;
    }

    static void BSmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BSmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BSmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BSmoveAAs(sf,df);
#if ENABLE_THREADS
    else BSmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void BDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
*((D *)NUM_VAL(df)) = t;
}

  static void BDmoveSAs(B *sf, B *df)
  {
    D t; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P BDmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((D *)d++) = t;
}}
  return OK;
  }

  static void BDmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BDmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      BDmoveSAs(sf, df);
#if ENABLE_THREADS
    else BDmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void BDmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = HUGE_VAL;

*((D *)NUM_VAL(df)) = t;
}

    static void BDmoveAAs(B *sf, B *df)
    {
       D t; P n; B * s; D * d;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P BDmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = HUGE_VAL;
*((D *)d++) = t;
}}
  return OK;
    }

    static void BDmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, BDmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void BDmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) BDmoveAAs(sf,df);
#if ENABLE_THREADS
    else BDmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void WBmoveSAs(B *sf, B *df)
  {
    D t; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P WBmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void WBmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WBmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WBmoveSAs(sf, df);
#if ENABLE_THREADS
    else WBmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WBmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = HUGE_VAL;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

    static void WBmoveAAs(B *sf, B *df)
    {
       D t; P n; W * s; B * d;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P WBmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void WBmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WBmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WBmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WBmoveAAs(sf,df);
#if ENABLE_THREADS
    else WBmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WWmoveSAs(B *sf, B *df)
  {
    D t; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WWmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WWmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WWmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WWmoveSAs(sf, df);
#if ENABLE_THREADS
    else WWmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WWmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = HUGE_VAL;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

    static void WWmoveAAs(B *sf, B *df)
    {
       D t; P n; W * s; W * d;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WWmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WWmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WWmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WWmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WWmoveAAs(sf,df);
#if ENABLE_THREADS
    else WWmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WL32moveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void WL32moveSAs(B *sf, B *df)
  {
    D t; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P WL32moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void WL32moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WL32moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WL32moveSAs(sf, df);
#if ENABLE_THREADS
    else WL32moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WL32moveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = HUGE_VAL;

*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

    static void WL32moveAAs(B *sf, B *df)
    {
       D t; P n; W * s; L32 * d;
       s = (W *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P WL32moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void WL32moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WL32moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WL32moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WL32moveAAs(sf,df);
#if ENABLE_THREADS
    else WL32moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WL64moveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void WL64moveSAs(B *sf, B *df)
  {
    D t; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P WL64moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void WL64moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WL64moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WL64moveSAs(sf, df);
#if ENABLE_THREADS
    else WL64moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WL64moveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = HUGE_VAL;

*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

    static void WL64moveAAs(B *sf, B *df)
    {
       D t; P n; W * s; L64 * d;
       s = (W *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P WL64moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void WL64moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WL64moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WL64moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WL64moveAAs(sf,df);
#if ENABLE_THREADS
    else WL64moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
*((S *)NUM_VAL(df)) = t;
}

  static void WSmoveSAs(B *sf, B *df)
  {
    D t; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P WSmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((S *)d++) = t;
}}
  return OK;
  }

  static void WSmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WSmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WSmoveSAs(sf, df);
#if ENABLE_THREADS
    else WSmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WSmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = HUGE_VAL;

*((S *)NUM_VAL(df)) = t;
}

    static void WSmoveAAs(B *sf, B *df)
    {
       D t; P n; W * s; S * d;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P WSmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((S *)d++) = t;
}}
  return OK;
    }

    static void WSmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WSmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WSmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WSmoveAAs(sf,df);
#if ENABLE_THREADS
    else WSmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void WDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
*((D *)NUM_VAL(df)) = t;
}

  static void WDmoveSAs(B *sf, B *df)
  {
    D t; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P WDmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((D *)d++) = t;
}}
  return OK;
  }

  static void WDmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WDmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      WDmoveSAs(sf, df);
#if ENABLE_THREADS
    else WDmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void WDmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = HUGE_VAL;

*((D *)NUM_VAL(df)) = t;
}

    static void WDmoveAAs(B *sf, B *df)
    {
       D t; P n; W * s; D * d;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P WDmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = HUGE_VAL;
*((D *)d++) = t;
}}
  return OK;
    }

    static void WDmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, WDmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void WDmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) WDmoveAAs(sf,df);
#if ENABLE_THREADS
    else WDmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L32BmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void L32BmoveSAs(B *sf, B *df)
  {
    D t; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P L32BmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void L32BmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32BmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L32BmoveSAs(sf, df);
#if ENABLE_THREADS
    else L32BmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L32BmoveAS(B *sf, B *df)
{
D t; L32 *s; 
s = (L32 *)VALUE_BASE(sf);

if ((t = *((L32 *)s)) == L32INF) t = HUGE_VAL;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

    static void L32BmoveAAs(B *sf, B *df)
    {
       D t; P n; L32 * s; B * d;
       s = (L32 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P L32BmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void L32BmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L32BmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L32BmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L32BmoveAAs(sf,df);
#if ENABLE_THREADS
    else L32BmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L32WmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void L32WmoveSAs(B *sf, B *df)
  {
    D t; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P L32WmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void L32WmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32WmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L32WmoveSAs(sf, df);
#if ENABLE_THREADS
    else L32WmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L32WmoveAS(B *sf, B *df)
{
D t; L32 *s; 
s = (L32 *)VALUE_BASE(sf);

if ((t = *((L32 *)s)) == L32INF) t = HUGE_VAL;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

    static void L32WmoveAAs(B *sf, B *df)
    {
       D t; P n; L32 * s; W * d;
       s = (L32 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P L32WmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void L32WmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L32WmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L32WmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L32WmoveAAs(sf,df);
#if ENABLE_THREADS
    else L32WmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L32L32moveSS(B *sf, B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L32moveSAs(B *sf, B *df)
  {
    D t; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L32moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L32moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32L32moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L32L32moveSAs(sf, df);
#if ENABLE_THREADS
    else L32L32moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L32L32moveAS(B *sf, B *df)
{
D t; L32 *s; 
s = (L32 *)VALUE_BASE(sf);

if ((t = *((L32 *)s)) == L32INF) t = HUGE_VAL;

*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

    static void L32L32moveAAs(B *sf, B *df)
    {
       D t; P n; L32 * s; L32 * d;
       s = (L32 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L32moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L32moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L32L32moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L32L32moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L32L32moveAAs(sf,df);
#if ENABLE_THREADS
    else L32L32moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L32L64moveSS(B *sf, B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L32L64moveSAs(B *sf, B *df)
  {
    D t; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L64moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L32L64moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32L64moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L32L64moveSAs(sf, df);
#if ENABLE_THREADS
    else L32L64moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L32L64moveAS(B *sf, B *df)
{
D t; L32 *s; 
s = (L32 *)VALUE_BASE(sf);

if ((t = *((L32 *)s)) == L32INF) t = HUGE_VAL;

*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

    static void L32L64moveAAs(B *sf, B *df)
    {
       D t; P n; L32 * s; L64 * d;
       s = (L32 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L64moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L32L64moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L32L64moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L32L64moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L32L64moveAAs(sf,df);
#if ENABLE_THREADS
    else L32L64moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L32SmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
*((S *)NUM_VAL(df)) = t;
}

  static void L32SmoveSAs(B *sf, B *df)
  {
    D t; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P L32SmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((S *)d++) = t;
}}
  return OK;
  }

  static void L32SmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32SmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L32SmoveSAs(sf, df);
#if ENABLE_THREADS
    else L32SmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L32SmoveAS(B *sf, B *df)
{
D t; L32 *s; 
s = (L32 *)VALUE_BASE(sf);

if ((t = *((L32 *)s)) == L32INF) t = HUGE_VAL;

*((S *)NUM_VAL(df)) = t;
}

    static void L32SmoveAAs(B *sf, B *df)
    {
       D t; P n; L32 * s; S * d;
       s = (L32 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P L32SmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((S *)d++) = t;
}}
  return OK;
    }

    static void L32SmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L32SmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L32SmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L32SmoveAAs(sf,df);
#if ENABLE_THREADS
    else L32SmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L32DmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
*((D *)NUM_VAL(df)) = t;
}

  static void L32DmoveSAs(B *sf, B *df)
  {
    D t; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((t = *((L32 *)NUM_VAL(sf))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P L32DmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((D *)d++) = t;
}}
  return OK;
  }

  static void L32DmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32DmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L32DmoveSAs(sf, df);
#if ENABLE_THREADS
    else L32DmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L32DmoveAS(B *sf, B *df)
{
D t; L32 *s; 
s = (L32 *)VALUE_BASE(sf);

if ((t = *((L32 *)s)) == L32INF) t = HUGE_VAL;

*((D *)NUM_VAL(df)) = t;
}

    static void L32DmoveAAs(B *sf, B *df)
    {
       D t; P n; L32 * s; D * d;
       s = (L32 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P L32DmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)s++)) == L32INF) t = HUGE_VAL;
*((D *)d++) = t;
}}
  return OK;
    }

    static void L32DmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L32DmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L32DmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L32DmoveAAs(sf,df);
#if ENABLE_THREADS
    else L32DmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L64BmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void L64BmoveSAs(B *sf, B *df)
  {
    D t; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P L64BmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void L64BmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64BmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L64BmoveSAs(sf, df);
#if ENABLE_THREADS
    else L64BmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L64BmoveAS(B *sf, B *df)
{
D t; L64 *s; 
s = (L64 *)VALUE_BASE(sf);

if ((t = *((L64 *)s)) == L64INF) t = HUGE_VAL;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

    static void L64BmoveAAs(B *sf, B *df)
    {
       D t; P n; L64 * s; B * d;
       s = (L64 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P L64BmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void L64BmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L64BmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L64BmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L64BmoveAAs(sf,df);
#if ENABLE_THREADS
    else L64BmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L64WmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void L64WmoveSAs(B *sf, B *df)
  {
    D t; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P L64WmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void L64WmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64WmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L64WmoveSAs(sf, df);
#if ENABLE_THREADS
    else L64WmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L64WmoveAS(B *sf, B *df)
{
D t; L64 *s; 
s = (L64 *)VALUE_BASE(sf);

if ((t = *((L64 *)s)) == L64INF) t = HUGE_VAL;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

    static void L64WmoveAAs(B *sf, B *df)
    {
       D t; P n; L64 * s; W * d;
       s = (L64 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P L64WmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void L64WmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L64WmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L64WmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L64WmoveAAs(sf,df);
#if ENABLE_THREADS
    else L64WmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L64L32moveSS(B *sf, B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L64L32moveSAs(B *sf, B *df)
  {
    D t; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L32moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L64L32moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64L32moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L64L32moveSAs(sf, df);
#if ENABLE_THREADS
    else L64L32moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L64L32moveAS(B *sf, B *df)
{
D t; L64 *s; 
s = (L64 *)VALUE_BASE(sf);

if ((t = *((L64 *)s)) == L64INF) t = HUGE_VAL;

*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

    static void L64L32moveAAs(B *sf, B *df)
    {
       D t; P n; L64 * s; L32 * d;
       s = (L64 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L32moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L64L32moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L64L32moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L64L32moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L64L32moveAAs(sf,df);
#if ENABLE_THREADS
    else L64L32moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L64L64moveSS(B *sf, B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L64moveSAs(B *sf, B *df)
  {
    D t; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L64moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L64moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64L64moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L64L64moveSAs(sf, df);
#if ENABLE_THREADS
    else L64L64moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L64L64moveAS(B *sf, B *df)
{
D t; L64 *s; 
s = (L64 *)VALUE_BASE(sf);

if ((t = *((L64 *)s)) == L64INF) t = HUGE_VAL;

*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

    static void L64L64moveAAs(B *sf, B *df)
    {
       D t; P n; L64 * s; L64 * d;
       s = (L64 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L64moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L64moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L64L64moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L64L64moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L64L64moveAAs(sf,df);
#if ENABLE_THREADS
    else L64L64moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L64SmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
*((S *)NUM_VAL(df)) = t;
}

  static void L64SmoveSAs(B *sf, B *df)
  {
    D t; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P L64SmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((S *)d++) = t;
}}
  return OK;
  }

  static void L64SmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64SmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L64SmoveSAs(sf, df);
#if ENABLE_THREADS
    else L64SmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L64SmoveAS(B *sf, B *df)
{
D t; L64 *s; 
s = (L64 *)VALUE_BASE(sf);

if ((t = *((L64 *)s)) == L64INF) t = HUGE_VAL;

*((S *)NUM_VAL(df)) = t;
}

    static void L64SmoveAAs(B *sf, B *df)
    {
       D t; P n; L64 * s; S * d;
       s = (L64 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P L64SmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((S *)d++) = t;
}}
  return OK;
    }

    static void L64SmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L64SmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L64SmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L64SmoveAAs(sf,df);
#if ENABLE_THREADS
    else L64SmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void L64DmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
*((D *)NUM_VAL(df)) = t;
}

  static void L64DmoveSAs(B *sf, B *df)
  {
    D t; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((t = *((L64 *)NUM_VAL(sf))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P L64DmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((D *)d++) = t;
}}
  return OK;
  }

  static void L64DmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64DmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      L64DmoveSAs(sf, df);
#if ENABLE_THREADS
    else L64DmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void L64DmoveAS(B *sf, B *df)
{
D t; L64 *s; 
s = (L64 *)VALUE_BASE(sf);

if ((t = *((L64 *)s)) == L64INF) t = HUGE_VAL;

*((D *)NUM_VAL(df)) = t;
}

    static void L64DmoveAAs(B *sf, B *df)
    {
       D t; P n; L64 * s; D * d;
       s = (L64 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P L64DmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)s++)) == L64INF) t = HUGE_VAL;
*((D *)d++) = t;
}}
  return OK;
    }

    static void L64DmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, L64DmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void L64DmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) L64DmoveAAs(sf,df);
#if ENABLE_THREADS
    else L64DmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SBmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void SBmoveSAs(B *sf, B *df)
  {
    D t; P n; B * d;
    d = (B *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P SBmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void SBmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SBmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SBmoveSAs(sf, df);
#if ENABLE_THREADS
    else SBmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SBmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

    static void SBmoveAAs(B *sf, B *df)
    {
       D t; P n; S * s; B * d;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P SBmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void SBmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SBmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SBmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SBmoveAAs(sf,df);
#if ENABLE_THREADS
    else SBmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SWmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void SWmoveSAs(B *sf, B *df)
  {
    D t; P n; W * d;
    d = (W *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P SWmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void SWmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SWmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SWmoveSAs(sf, df);
#if ENABLE_THREADS
    else SWmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SWmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

    static void SWmoveAAs(B *sf, B *df)
    {
       D t; P n; S * s; W * d;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P SWmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void SWmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SWmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SWmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SWmoveAAs(sf,df);
#if ENABLE_THREADS
    else SWmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SL32moveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void SL32moveSAs(B *sf, B *df)
  {
    D t; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P SL32moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void SL32moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SL32moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SL32moveSAs(sf, df);
#if ENABLE_THREADS
    else SL32moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SL32moveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

    static void SL32moveAAs(B *sf, B *df)
    {
       D t; P n; S * s; L32 * d;
       s = (S *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P SL32moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void SL32moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SL32moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SL32moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SL32moveAAs(sf,df);
#if ENABLE_THREADS
    else SL32moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SL64moveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void SL64moveSAs(B *sf, B *df)
  {
    D t; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P SL64moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void SL64moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SL64moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SL64moveSAs(sf, df);
#if ENABLE_THREADS
    else SL64moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SL64moveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

    static void SL64moveAAs(B *sf, B *df)
    {
       D t; P n; S * s; L64 * d;
       s = (S *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P SL64moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void SL64moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SL64moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SL64moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SL64moveAAs(sf,df);
#if ENABLE_THREADS
    else SL64moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SSmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((S *)NUM_VAL(df)) = t;
}

  static void SSmoveSAs(B *sf, B *df)
  {
    D t; P n; S * d;
    d = (S *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SSmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((S *)d++) = t;
}}
  return OK;
  }

  static void SSmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SSmoveSAs(sf, df);
#if ENABLE_THREADS
    else SSmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SSmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((S *)NUM_VAL(df)) = t;
}

    static void SSmoveAAs(B *sf, B *df)
    {
       D t; P n; S * s; S * d;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SSmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SSmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SSmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SSmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SSmoveAAs(sf,df);
#if ENABLE_THREADS
    else SSmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void SDmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((D *)NUM_VAL(df)) = t;
}

  static void SDmoveSAs(B *sf, B *df)
  {
    D t; P n; D * d;
    d = (D *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SDmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((D *)d++) = t;
}}
  return OK;
  }

  static void SDmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SDmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      SDmoveSAs(sf, df);
#if ENABLE_THREADS
    else SDmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void SDmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((D *)NUM_VAL(df)) = t;
}

    static void SDmoveAAs(B *sf, B *df)
    {
       D t; P n; S * s; D * d;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SDmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}}
  return OK;
    }

    static void SDmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, SDmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void SDmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) SDmoveAAs(sf,df);
#if ENABLE_THREADS
    else SDmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DBmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void DBmoveSAs(B *sf, B *df)
  {
    D t; P n; B * d;
    d = (B *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P DBmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void DBmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DBmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DBmoveSAs(sf, df);
#if ENABLE_THREADS
    else DBmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DBmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

    static void DBmoveAAs(B *sf, B *df)
    {
       D t; P n; D * s; B * d;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P DBmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void DBmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DBmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DBmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DBmoveAAs(sf,df);
#if ENABLE_THREADS
    else DBmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DWmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void DWmoveSAs(B *sf, B *df)
  {
    D t; P n; W * d;
    d = (W *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P DWmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void DWmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DWmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DWmoveSAs(sf, df);
#if ENABLE_THREADS
    else DWmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DWmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

    static void DWmoveAAs(B *sf, B *df)
    {
       D t; P n; D * s; W * d;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P DWmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void DWmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DWmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DWmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DWmoveAAs(sf,df);
#if ENABLE_THREADS
    else DWmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DL32moveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void DL32moveSAs(B *sf, B *df)
  {
    D t; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P DL32moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void DL32moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DL32moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DL32moveSAs(sf, df);
#if ENABLE_THREADS
    else DL32moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DL32moveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

    static void DL32moveAAs(B *sf, B *df)
    {
       D t; P n; D * s; L32 * d;
       s = (D *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P DL32moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)s++);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void DL32moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DL32moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DL32moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DL32moveAAs(sf,df);
#if ENABLE_THREADS
    else DL32moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DL64moveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void DL64moveSAs(B *sf, B *df)
  {
    D t; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P DL64moveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void DL64moveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64moveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DL64moveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64moveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DL64moveSAs(sf, df);
#if ENABLE_THREADS
    else DL64moveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DL64moveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

    static void DL64moveAAs(B *sf, B *df)
    {
       D t; P n; D * s; L64 * d;
       s = (D *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P DL64moveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)s++);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void DL64moveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64moveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DL64moveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DL64moveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DL64moveAAs(sf,df);
#if ENABLE_THREADS
    else DL64moveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DSmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((S *)NUM_VAL(df)) = t;
}

  static void DSmoveSAs(B *sf, B *df)
  {
    D t; P n; S * d;
    d = (S *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DSmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((S *)d++) = t;
}}
  return OK;
  }

  static void DSmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DSmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DSmoveSAs(sf, df);
#if ENABLE_THREADS
    else DSmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DSmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((S *)NUM_VAL(df)) = t;
}

    static void DSmoveAAs(B *sf, B *df)
    {
       D t; P n; D * s; S * d;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DSmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}}
  return OK;
    }

    static void DSmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DSmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DSmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DSmoveAAs(sf,df);
#if ENABLE_THREADS
    else DSmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

static void DDmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((D *)NUM_VAL(df)) = t;
}

  static void DDmoveSAs(B *sf, B *df)
  {
    D t; P n; D * d;
    d = (D *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DDmoveSAt(UP id, const void* indata,
                                   void* ignore
                                   __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t = data->in;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
*((D *)d++) = t;
}}
  return OK;
  }

  static void DDmoveSAc(B* sf, B* df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDmoveSAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDmoveSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDmoveSA(B* sf, B* df)
  {
    if (thread_num() == 1)
      DDmoveSAs(sf, df);
#if ENABLE_THREADS
    else DDmoveSAc(sf,df);
#endif //ENABLE_THREADS
  }

static void DDmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((D *)NUM_VAL(df)) = t;
}

    static void DDmoveAAs(B *sf, B *df)
    {
       D t; P n; D * s; D * d;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DDmoveAAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
       D t;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DDmoveAAc(B *sf, B *df)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDmoveAAs(sf, df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
        threads_do(nways, DDmoveAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

   static void DDmoveAA(B *sf, B *df)
   {
    if (serialized || thread_num() == 1) DDmoveAAs(sf,df);
#if ENABLE_THREADS
    else DDmoveAAc(sf, df);
#endif //ENABLE_THREADS
   }

typedef void (*MOVEfct)(B*,B*);
static MOVEfct MOVElist[] = {
BBmoveSS, BBmoveSA, BBmoveAS, BBmoveAA, 
BWmoveSS, BWmoveSA, BWmoveAS, BWmoveAA, 
BL32moveSS, BL32moveSA, BL32moveAS, BL32moveAA, 
BL64moveSS, BL64moveSA, BL64moveAS, BL64moveAA, 
BSmoveSS, BSmoveSA, BSmoveAS, BSmoveAA, 
BDmoveSS, BDmoveSA, BDmoveAS, BDmoveAA, 
WBmoveSS, WBmoveSA, WBmoveAS, WBmoveAA, 
WWmoveSS, WWmoveSA, WWmoveAS, WWmoveAA, 
WL32moveSS, WL32moveSA, WL32moveAS, WL32moveAA, 
WL64moveSS, WL64moveSA, WL64moveAS, WL64moveAA, 
WSmoveSS, WSmoveSA, WSmoveAS, WSmoveAA, 
WDmoveSS, WDmoveSA, WDmoveAS, WDmoveAA, 
L32BmoveSS, L32BmoveSA, L32BmoveAS, L32BmoveAA, 
L32WmoveSS, L32WmoveSA, L32WmoveAS, L32WmoveAA, 
L32L32moveSS, L32L32moveSA, L32L32moveAS, L32L32moveAA, 
L32L64moveSS, L32L64moveSA, L32L64moveAS, L32L64moveAA, 
L32SmoveSS, L32SmoveSA, L32SmoveAS, L32SmoveAA, 
L32DmoveSS, L32DmoveSA, L32DmoveAS, L32DmoveAA, 
L64BmoveSS, L64BmoveSA, L64BmoveAS, L64BmoveAA, 
L64WmoveSS, L64WmoveSA, L64WmoveAS, L64WmoveAA, 
L64L32moveSS, L64L32moveSA, L64L32moveAS, L64L32moveAA, 
L64L64moveSS, L64L64moveSA, L64L64moveAS, L64L64moveAA, 
L64SmoveSS, L64SmoveSA, L64SmoveAS, L64SmoveAA, 
L64DmoveSS, L64DmoveSA, L64DmoveAS, L64DmoveAA, 
SBmoveSS, SBmoveSA, SBmoveAS, SBmoveAA, 
SWmoveSS, SWmoveSA, SWmoveAS, SWmoveAA, 
SL32moveSS, SL32moveSA, SL32moveAS, SL32moveAA, 
SL64moveSS, SL64moveSA, SL64moveAS, SL64moveAA, 
SSmoveSS, SSmoveSA, SSmoveAS, SSmoveAA, 
SDmoveSS, SDmoveSA, SDmoveAS, SDmoveAA, 
DBmoveSS, DBmoveSA, DBmoveAS, DBmoveAA, 
DWmoveSS, DWmoveSA, DWmoveAS, DWmoveAA, 
DL32moveSS, DL32moveSA, DL32moveAS, DL32moveAA, 
DL64moveSS, DL64moveSA, DL64moveAS, DL64moveAA, 
DSmoveSS, DSmoveSA, DSmoveAS, DSmoveAA, 
DDmoveSS, DDmoveSA, DDmoveAS, DDmoveAA, 

};

static void BBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BBdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BBdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BBdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BBdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyADDASs(df, sf);
#if ENABLE_THREADS
    else BBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BBdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BBdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyADDAAs(B * df, B * sf)
    {
       P n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BBdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BBdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BBdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BBdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BBdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BBdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BBdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdySUBASs(df, sf);
#if ENABLE_THREADS
    else BBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BBdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BBdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdySUBAAs(B * df, B * sf)
    {
       P n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BBdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BBdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BBdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BBdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BBdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BBdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BBdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyMULASs(df, sf);
#if ENABLE_THREADS
    else BBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BBdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BBdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyMULAAs(B * df, B * sf)
    {
       P n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BBdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BBdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BBdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BBdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BBdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BBdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BBdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BBdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BBdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyDIVAAs(B * df, B * sf)
    {
       P n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BBdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BBdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BBdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BBdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BBdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BBdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BBdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BBdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BBdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BBdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BBdyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BBdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BBdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyPWRAAs(B * df, B * sf)
    {
       P n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BBdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BBdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BBdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BBdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BBdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BBdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BBdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyMODASs(df, sf);
#if ENABLE_THREADS
    else BBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BBdyMODSA(B* df, B *sf)
  {
    BBdyMODSAs(df, sf);
  }

    static void BBdyMODAAs(B * df, B * sf)
    {
       P n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BBdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BBdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BBdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BBdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BBdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, BBdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BBdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BBdyTHEARCSA(B* df, B *sf)
  {
    BBdyTHEARCSAs(df, sf);
  }

    static void BBdyTHEARCAAs(B * df, B * sf)
    {
       P n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BBdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BBdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BBdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BBdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BBdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BWdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BWdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BWdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, BWdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyADDASs(df, sf);
#if ENABLE_THREADS
    else BWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BWdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BWdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyADDAAs(B * df, B * sf)
    {
       P n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BWdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BWdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BWdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BWdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BWdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BWdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, BWdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdySUBASs(df, sf);
#if ENABLE_THREADS
    else BWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BWdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BWdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdySUBAAs(B * df, B * sf)
    {
       P n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BWdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BWdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BWdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BWdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BWdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BWdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, BWdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyMULASs(df, sf);
#if ENABLE_THREADS
    else BWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BWdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BWdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyMULAAs(B * df, B * sf)
    {
       P n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BWdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BWdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BWdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BWdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BWdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BWdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, BWdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BWdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BWdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyDIVAAs(B * df, B * sf)
    {
       P n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BWdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BWdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BWdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BWdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BWdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BWdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, BWdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BWdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BWdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BWdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BWdyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BWdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BWdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyPWRAAs(B * df, B * sf)
    {
       P n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BWdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BWdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BWdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BWdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BWdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BWdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, BWdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyMODASs(df, sf);
#if ENABLE_THREADS
    else BWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BWdyMODSA(B* df, B *sf)
  {
    BWdyMODSAs(df, sf);
  }

    static void BWdyMODAAs(B * df, B * sf)
    {
       P n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BWdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BWdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BWdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BWdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BWdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, BWdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BWdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BWdyTHEARCSA(B* df, B *sf)
  {
    BWdyTHEARCSAs(df, sf);
  }

    static void BWdyTHEARCAAs(B * df, B * sf)
    {
       P n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BWdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BWdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BWdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BWdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BWdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL32dyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL32dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL32dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL32dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, BL32dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL32dyADDASs(df, sf);
#if ENABLE_THREADS
    else BL32dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL32dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL32dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL32dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL32dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL32dyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL32dyADDSAs(df, sf);
#if ENABLE_THREADS
    else BL32dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL32dyADDAAs(B * df, B * sf)
    {
       P n; L32 * s; B * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL32dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL32dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL32dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL32dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL32dyADDAAs(df,sf);
#if ENABLE_THREADS
      else BL32dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL32dySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL32dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL32dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL32dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, BL32dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL32dySUBASs(df, sf);
#if ENABLE_THREADS
    else BL32dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL32dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL32dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL32dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL32dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL32dySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL32dySUBSAs(df, sf);
#if ENABLE_THREADS
    else BL32dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL32dySUBAAs(B * df, B * sf)
    {
       P n; L32 * s; B * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL32dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL32dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL32dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL32dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL32dySUBAAs(df,sf);
#if ENABLE_THREADS
      else BL32dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL32dyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL32dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL32dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL32dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, BL32dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL32dyMULASs(df, sf);
#if ENABLE_THREADS
    else BL32dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL32dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL32dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL32dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL32dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL32dyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL32dyMULSAs(df, sf);
#if ENABLE_THREADS
    else BL32dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL32dyMULAAs(B * df, B * sf)
    {
       P n; L32 * s; B * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL32dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL32dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL32dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL32dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL32dyMULAAs(df,sf);
#if ENABLE_THREADS
      else BL32dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL32dyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL32dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL32dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL32dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, BL32dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL32dyDIVASs(df, sf);
#if ENABLE_THREADS
    else BL32dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL32dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL32dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL32dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL32dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL32dyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL32dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BL32dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL32dyDIVAAs(B * df, B * sf)
    {
       P n; L32 * s; B * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL32dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL32dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL32dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL32dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL32dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BL32dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL32dyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL32dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL32dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL32dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, BL32dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL32dyPWRASs(df, sf);
#if ENABLE_THREADS
    else BL32dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL32dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL32dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL32dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL32dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL32dyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL32dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BL32dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL32dyPWRAAs(B * df, B * sf)
    {
       P n; L32 * s; B * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL32dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL32dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL32dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL32dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL32dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BL32dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL32dyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL32dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL32dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL32dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, BL32dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL32dyMODASs(df, sf);
#if ENABLE_THREADS
    else BL32dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL32dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BL32dyMODSA(B* df, B *sf)
  {
    BL32dyMODSAs(df, sf);
  }

    static void BL32dyMODAAs(B * df, B * sf)
    {
       P n; L32 * s; B * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL32dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL32dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL32dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL32dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL32dyMODAAs(df,sf);
#if ENABLE_THREADS
      else BL32dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL32dyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL32dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL32dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL32dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, BL32dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL32dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL32dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BL32dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL32dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BL32dyTHEARCSA(B* df, B *sf)
  {
    BL32dyTHEARCSAs(df, sf);
  }

    static void BL32dyTHEARCAAs(B * df, B * sf)
    {
       P n; L32 * s; B * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL32dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL32dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL32dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL32dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL32dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL32dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BL32dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL64dyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL64dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL64dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL64dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, BL64dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL64dyADDASs(df, sf);
#if ENABLE_THREADS
    else BL64dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL64dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL64dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL64dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL64dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL64dyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL64dyADDSAs(df, sf);
#if ENABLE_THREADS
    else BL64dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL64dyADDAAs(B * df, B * sf)
    {
       P n; L64 * s; B * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL64dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL64dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL64dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL64dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL64dyADDAAs(df,sf);
#if ENABLE_THREADS
      else BL64dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL64dySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL64dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL64dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL64dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, BL64dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL64dySUBASs(df, sf);
#if ENABLE_THREADS
    else BL64dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL64dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL64dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL64dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL64dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL64dySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL64dySUBSAs(df, sf);
#if ENABLE_THREADS
    else BL64dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL64dySUBAAs(B * df, B * sf)
    {
       P n; L64 * s; B * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL64dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL64dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL64dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL64dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL64dySUBAAs(df,sf);
#if ENABLE_THREADS
      else BL64dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL64dyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL64dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL64dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL64dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, BL64dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL64dyMULASs(df, sf);
#if ENABLE_THREADS
    else BL64dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL64dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL64dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL64dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL64dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL64dyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL64dyMULSAs(df, sf);
#if ENABLE_THREADS
    else BL64dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL64dyMULAAs(B * df, B * sf)
    {
       P n; L64 * s; B * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL64dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL64dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL64dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL64dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL64dyMULAAs(df,sf);
#if ENABLE_THREADS
      else BL64dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL64dyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL64dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL64dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL64dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, BL64dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL64dyDIVASs(df, sf);
#if ENABLE_THREADS
    else BL64dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL64dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL64dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL64dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL64dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL64dyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL64dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BL64dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL64dyDIVAAs(B * df, B * sf)
    {
       P n; L64 * s; B * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL64dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL64dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL64dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL64dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL64dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BL64dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL64dyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL64dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL64dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL64dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, BL64dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL64dyPWRASs(df, sf);
#if ENABLE_THREADS
    else BL64dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL64dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BL64dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BL64dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BL64dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BL64dyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BL64dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BL64dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BL64dyPWRAAs(B * df, B * sf)
    {
       P n; L64 * s; B * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL64dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL64dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL64dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL64dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL64dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BL64dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL64dyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL64dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL64dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL64dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, BL64dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL64dyMODASs(df, sf);
#if ENABLE_THREADS
    else BL64dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL64dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BL64dyMODSA(B* df, B *sf)
  {
    BL64dyMODSAs(df, sf);
  }

    static void BL64dyMODAAs(B * df, B * sf)
    {
       P n; L64 * s; B * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL64dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL64dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL64dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL64dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL64dyMODAAs(df,sf);
#if ENABLE_THREADS
      else BL64dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BL64dyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BL64dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BL64dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BL64dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, BL64dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BL64dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BL64dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BL64dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BL64dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BL64dyTHEARCSA(B* df, B *sf)
  {
    BL64dyTHEARCSAs(df, sf);
  }

    static void BL64dyTHEARCAAs(B * df, B * sf)
    {
       P n; L64 * s; B * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BL64dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BL64dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BL64dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BL64dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BL64dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BL64dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BL64dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BSdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BSdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BSdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyADDASs(df, sf);
#if ENABLE_THREADS
    else BSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BSdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BSdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyADDAAs(B * df, B * sf)
    {
       P n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BSdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BSdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BSdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BSdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BSdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BSdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdySUBASs(df, sf);
#if ENABLE_THREADS
    else BSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BSdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BSdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdySUBAAs(B * df, B * sf)
    {
       P n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BSdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BSdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BSdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BSdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BSdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BSdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyMULASs(df, sf);
#if ENABLE_THREADS
    else BSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BSdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BSdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyMULAAs(B * df, B * sf)
    {
       P n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BSdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BSdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BSdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BSdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BSdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BSdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BSdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BSdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyDIVAAs(B * df, B * sf)
    {
       P n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BSdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BSdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BSdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BSdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BSdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BSdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BSdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BSdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BSdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BSdyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BSdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BSdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyPWRAAs(B * df, B * sf)
    {
       P n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BSdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BSdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BSdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BSdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BSdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BSdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyMODASs(df, sf);
#if ENABLE_THREADS
    else BSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BSdyMODSA(B* df, B *sf)
  {
    BSdyMODSAs(df, sf);
  }

    static void BSdyMODAAs(B * df, B * sf)
    {
       P n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BSdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BSdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BSdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BSdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BSdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, BSdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BSdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BSdyTHEARCSA(B* df, B *sf)
  {
    BSdyTHEARCSAs(df, sf);
  }

    static void BSdyTHEARCAAs(B * df, B * sf)
    {
       P n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BSdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BSdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BSdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BSdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BSdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BDdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BDdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BDdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyADDASs(df, sf);
#if ENABLE_THREADS
    else BDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BDdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BDdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdyADDSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyADDAAs(B * df, B * sf)
    {
       P n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BDdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BDdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BDdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BDdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BDdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BDdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdySUBASs(df, sf);
#if ENABLE_THREADS
    else BDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BDdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BDdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdySUBSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdySUBAAs(B * df, B * sf)
    {
       P n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BDdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BDdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BDdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BDdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BDdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BDdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyMULASs(df, sf);
#if ENABLE_THREADS
    else BDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BDdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BDdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdyMULSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyMULAAs(B * df, B * sf)
    {
       P n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BDdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BDdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BDdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BDdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BDdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BDdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BDdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BDdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdyDIVSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyDIVAAs(B * df, B * sf)
    {
       P n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BDdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BDdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BDdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BDdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BDdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BDdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

#if ENABLE_THREADS
 static P BDdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void BDdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    BDdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, BDdyPWRSAt, &data, ret);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      BDdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else BDdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyPWRAAs(B * df, B * sf)
    {
       P n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BDdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BDdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BDdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BDdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BDdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BDdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyMODASs(df, sf);
#if ENABLE_THREADS
    else BDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BDdyMODSA(B* df, B *sf)
  {
    BDdyMODSAs(df, sf);
  }

    static void BDdyMODAAs(B * df, B * sf)
    {
       P n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BDdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BDdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BDdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void BDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

  static void BDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; B * d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  }

#if ENABLE_THREADS
  static P BDdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }

  static void BDdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, BDdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BDdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    BDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
   }

  static void BDdyTHEARCSA(B* df, B *sf)
  {
    BDdyTHEARCSAs(df, sf);
  }

    static void BDdyTHEARCAAs(B * df, B * sf)
    {
       P n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
    }


#if ENABLE_THREADS
    static P BDdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
    }

    static void BDdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BDdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, BDdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void BDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) BDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BDdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WBdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WBdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WBdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, WBdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyADDASs(df, sf);
#if ENABLE_THREADS
    else WBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WBdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WBdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyADDAAs(B * df, B * sf)
    {
       P n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WBdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WBdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WBdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WBdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WBdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WBdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, WBdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdySUBASs(df, sf);
#if ENABLE_THREADS
    else WBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WBdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WBdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdySUBAAs(B * df, B * sf)
    {
       P n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WBdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WBdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WBdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WBdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WBdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WBdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, WBdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyMULASs(df, sf);
#if ENABLE_THREADS
    else WBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WBdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WBdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyMULAAs(B * df, B * sf)
    {
       P n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WBdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WBdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WBdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WBdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WBdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WBdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, WBdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WBdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WBdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyDIVAAs(B * df, B * sf)
    {
       P n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WBdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WBdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WBdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WBdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WBdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WBdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, WBdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WBdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WBdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WBdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WBdyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WBdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WBdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyPWRAAs(B * df, B * sf)
    {
       P n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WBdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WBdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WBdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WBdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WBdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WBdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, WBdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyMODASs(df, sf);
#if ENABLE_THREADS
    else WBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WBdyMODSA(B* df, B *sf)
  {
    WBdyMODSAs(df, sf);
  }

    static void WBdyMODAAs(B * df, B * sf)
    {
       P n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WBdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WBdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WBdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WBdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WBdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, WBdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WBdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WBdyTHEARCSA(B* df, B *sf)
  {
    WBdyTHEARCSAs(df, sf);
  }

    static void WBdyTHEARCAAs(B * df, B * sf)
    {
       P n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WBdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WBdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WBdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WBdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WBdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WWdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WWdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WWdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WWdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyADDASs(df, sf);
#if ENABLE_THREADS
    else WWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WWdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WWdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyADDAAs(B * df, B * sf)
    {
       P n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WWdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WWdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WWdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WWdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WWdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WWdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WWdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdySUBASs(df, sf);
#if ENABLE_THREADS
    else WWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WWdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WWdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdySUBAAs(B * df, B * sf)
    {
       P n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WWdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WWdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WWdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WWdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WWdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WWdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WWdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyMULASs(df, sf);
#if ENABLE_THREADS
    else WWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WWdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WWdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyMULAAs(B * df, B * sf)
    {
       P n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WWdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WWdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WWdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WWdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WWdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WWdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WWdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WWdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WWdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyDIVAAs(B * df, B * sf)
    {
       P n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WWdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WWdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WWdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WWdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WWdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WWdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WWdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WWdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WWdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WWdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WWdyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WWdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WWdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyPWRAAs(B * df, B * sf)
    {
       P n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WWdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WWdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WWdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WWdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WWdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WWdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WWdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyMODASs(df, sf);
#if ENABLE_THREADS
    else WWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WWdyMODSA(B* df, B *sf)
  {
    WWdyMODSAs(df, sf);
  }

    static void WWdyMODAAs(B * df, B * sf)
    {
       P n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WWdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WWdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WWdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WWdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WWdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, WWdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WWdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WWdyTHEARCSA(B* df, B *sf)
  {
    WWdyTHEARCSAs(df, sf);
  }

    static void WWdyTHEARCAAs(B * df, B * sf)
    {
       P n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WWdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WWdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WWdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WWdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WWdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL32dyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL32dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL32dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL32dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, WL32dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL32dyADDASs(df, sf);
#if ENABLE_THREADS
    else WL32dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL32dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL32dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL32dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL32dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL32dyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL32dyADDSAs(df, sf);
#if ENABLE_THREADS
    else WL32dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL32dyADDAAs(B * df, B * sf)
    {
       P n; L32 * s; W * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL32dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL32dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL32dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL32dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL32dyADDAAs(df,sf);
#if ENABLE_THREADS
      else WL32dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL32dySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL32dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL32dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL32dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, WL32dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL32dySUBASs(df, sf);
#if ENABLE_THREADS
    else WL32dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL32dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL32dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL32dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL32dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL32dySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL32dySUBSAs(df, sf);
#if ENABLE_THREADS
    else WL32dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL32dySUBAAs(B * df, B * sf)
    {
       P n; L32 * s; W * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL32dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL32dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL32dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL32dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL32dySUBAAs(df,sf);
#if ENABLE_THREADS
      else WL32dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL32dyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL32dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL32dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL32dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, WL32dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL32dyMULASs(df, sf);
#if ENABLE_THREADS
    else WL32dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL32dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL32dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL32dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL32dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL32dyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL32dyMULSAs(df, sf);
#if ENABLE_THREADS
    else WL32dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL32dyMULAAs(B * df, B * sf)
    {
       P n; L32 * s; W * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL32dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL32dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL32dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL32dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL32dyMULAAs(df,sf);
#if ENABLE_THREADS
      else WL32dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL32dyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL32dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL32dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL32dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, WL32dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL32dyDIVASs(df, sf);
#if ENABLE_THREADS
    else WL32dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL32dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL32dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL32dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL32dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL32dyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL32dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WL32dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL32dyDIVAAs(B * df, B * sf)
    {
       P n; L32 * s; W * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL32dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL32dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL32dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL32dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL32dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WL32dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL32dyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL32dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL32dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL32dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, WL32dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL32dyPWRASs(df, sf);
#if ENABLE_THREADS
    else WL32dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL32dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL32dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL32dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL32dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL32dyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL32dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WL32dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL32dyPWRAAs(B * df, B * sf)
    {
       P n; L32 * s; W * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL32dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL32dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL32dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL32dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL32dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WL32dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL32dyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL32dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL32dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL32dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, WL32dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL32dyMODASs(df, sf);
#if ENABLE_THREADS
    else WL32dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL32dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WL32dyMODSA(B* df, B *sf)
  {
    WL32dyMODSAs(df, sf);
  }

    static void WL32dyMODAAs(B * df, B * sf)
    {
       P n; L32 * s; W * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL32dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL32dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL32dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL32dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL32dyMODAAs(df,sf);
#if ENABLE_THREADS
      else WL32dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL32dyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL32dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL32dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL32dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, WL32dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL32dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL32dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WL32dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL32dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WL32dyTHEARCSA(B* df, B *sf)
  {
    WL32dyTHEARCSAs(df, sf);
  }

    static void WL32dyTHEARCAAs(B * df, B * sf)
    {
       P n; L32 * s; W * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL32dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL32dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL32dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL32dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL32dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL32dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WL32dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL64dyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL64dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL64dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL64dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, WL64dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL64dyADDASs(df, sf);
#if ENABLE_THREADS
    else WL64dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL64dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL64dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL64dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL64dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL64dyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL64dyADDSAs(df, sf);
#if ENABLE_THREADS
    else WL64dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL64dyADDAAs(B * df, B * sf)
    {
       P n; L64 * s; W * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL64dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL64dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL64dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL64dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL64dyADDAAs(df,sf);
#if ENABLE_THREADS
      else WL64dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL64dySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL64dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL64dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL64dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, WL64dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL64dySUBASs(df, sf);
#if ENABLE_THREADS
    else WL64dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL64dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL64dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL64dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL64dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL64dySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL64dySUBSAs(df, sf);
#if ENABLE_THREADS
    else WL64dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL64dySUBAAs(B * df, B * sf)
    {
       P n; L64 * s; W * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL64dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL64dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL64dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL64dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL64dySUBAAs(df,sf);
#if ENABLE_THREADS
      else WL64dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL64dyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL64dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL64dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL64dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, WL64dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL64dyMULASs(df, sf);
#if ENABLE_THREADS
    else WL64dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL64dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL64dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL64dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL64dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL64dyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL64dyMULSAs(df, sf);
#if ENABLE_THREADS
    else WL64dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL64dyMULAAs(B * df, B * sf)
    {
       P n; L64 * s; W * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL64dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL64dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL64dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL64dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL64dyMULAAs(df,sf);
#if ENABLE_THREADS
      else WL64dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL64dyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL64dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL64dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL64dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, WL64dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL64dyDIVASs(df, sf);
#if ENABLE_THREADS
    else WL64dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL64dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL64dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL64dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL64dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL64dyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL64dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WL64dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL64dyDIVAAs(B * df, B * sf)
    {
       P n; L64 * s; W * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL64dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL64dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL64dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL64dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL64dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WL64dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL64dyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL64dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL64dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL64dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, WL64dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL64dyPWRASs(df, sf);
#if ENABLE_THREADS
    else WL64dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL64dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WL64dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WL64dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WL64dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WL64dyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WL64dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WL64dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WL64dyPWRAAs(B * df, B * sf)
    {
       P n; L64 * s; W * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL64dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL64dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL64dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL64dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL64dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WL64dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL64dyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL64dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL64dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL64dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, WL64dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL64dyMODASs(df, sf);
#if ENABLE_THREADS
    else WL64dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL64dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WL64dyMODSA(B* df, B *sf)
  {
    WL64dyMODSAs(df, sf);
  }

    static void WL64dyMODAAs(B * df, B * sf)
    {
       P n; L64 * s; W * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL64dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL64dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL64dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL64dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL64dyMODAAs(df,sf);
#if ENABLE_THREADS
      else WL64dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WL64dyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WL64dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WL64dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WL64dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, WL64dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WL64dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WL64dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WL64dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WL64dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WL64dyTHEARCSA(B* df, B *sf)
  {
    WL64dyTHEARCSAs(df, sf);
  }

    static void WL64dyTHEARCAAs(B * df, B * sf)
    {
       P n; L64 * s; W * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WL64dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WL64dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WL64dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WL64dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WL64dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WL64dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WL64dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WSdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WSdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WSdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyADDASs(df, sf);
#if ENABLE_THREADS
    else WSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WSdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WSdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyADDAAs(B * df, B * sf)
    {
       P n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WSdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WSdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WSdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WSdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WSdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WSdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdySUBASs(df, sf);
#if ENABLE_THREADS
    else WSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WSdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WSdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdySUBAAs(B * df, B * sf)
    {
       P n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WSdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WSdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WSdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WSdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WSdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WSdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyMULASs(df, sf);
#if ENABLE_THREADS
    else WSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WSdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WSdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyMULAAs(B * df, B * sf)
    {
       P n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WSdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WSdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WSdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WSdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WSdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WSdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WSdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WSdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyDIVAAs(B * df, B * sf)
    {
       P n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WSdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WSdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WSdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WSdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WSdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WSdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WSdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WSdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WSdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WSdyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WSdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WSdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyPWRAAs(B * df, B * sf)
    {
       P n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WSdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WSdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WSdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WSdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WSdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WSdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyMODASs(df, sf);
#if ENABLE_THREADS
    else WSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WSdyMODSA(B* df, B *sf)
  {
    WSdyMODSAs(df, sf);
  }

    static void WSdyMODAAs(B * df, B * sf)
    {
       P n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WSdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WSdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WSdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WSdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WSdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, WSdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WSdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WSdyTHEARCSA(B* df, B *sf)
  {
    WSdyTHEARCSAs(df, sf);
  }

    static void WSdyTHEARCAAs(B * df, B * sf)
    {
       P n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WSdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WSdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WSdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WSdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WSdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WDdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WDdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WDdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyADDASs(df, sf);
#if ENABLE_THREADS
    else WDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WDdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WDdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdyADDSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyADDAAs(B * df, B * sf)
    {
       P n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WDdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WDdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WDdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WDdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WDdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WDdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdySUBASs(df, sf);
#if ENABLE_THREADS
    else WDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WDdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WDdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdySUBSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdySUBAAs(B * df, B * sf)
    {
       P n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WDdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WDdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WDdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WDdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WDdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WDdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyMULASs(df, sf);
#if ENABLE_THREADS
    else WDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WDdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WDdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdyMULSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyMULAAs(B * df, B * sf)
    {
       P n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WDdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WDdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WDdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WDdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WDdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WDdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WDdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WDdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdyDIVSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyDIVAAs(B * df, B * sf)
    {
       P n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WDdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WDdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WDdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WDdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WDdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WDdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

#if ENABLE_THREADS
 static P WDdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void WDdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    WDdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, WDdyPWRSAt, &data, ret);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      WDdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else WDdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyPWRAAs(B * df, B * sf)
    {
       P n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WDdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WDdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WDdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WDdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WDdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WDdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyMODASs(df, sf);
#if ENABLE_THREADS
    else WDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WDdyMODSA(B* df, B *sf)
  {
    WDdyMODSAs(df, sf);
  }

    static void WDdyMODAAs(B * df, B * sf)
    {
       P n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WDdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WDdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WDdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void WDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

  static void WDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; W * d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  }

#if ENABLE_THREADS
  static P WDdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }

  static void WDdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, WDdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WDdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    WDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
   }

  static void WDdyTHEARCSA(B* df, B *sf)
  {
    WDdyTHEARCSAs(df, sf);
  }

    static void WDdyTHEARCAAs(B * df, B * sf)
    {
       P n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
    }


#if ENABLE_THREADS
    static P WDdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
    }

    static void WDdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WDdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, WDdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void WDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) WDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WDdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32BdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t += tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32BdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32BdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32BdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L32BdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32BdyADDASs(df, sf);
#if ENABLE_THREADS
    else L32BdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32BdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32BdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32BdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32BdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32BdyADDSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32BdyADDSAs(df, sf);
#if ENABLE_THREADS
    else L32BdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32BdyADDAAs(B * df, B * sf)
    {
       P n; B * s; L32 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32BdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32BdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32BdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32BdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32BdyADDAAs(df,sf);
#if ENABLE_THREADS
      else L32BdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32BdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t -= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32BdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32BdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32BdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L32BdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32BdySUBASs(df, sf);
#if ENABLE_THREADS
    else L32BdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32BdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32BdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32BdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32BdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32BdySUBSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32BdySUBSAs(df, sf);
#if ENABLE_THREADS
    else L32BdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32BdySUBAAs(B * df, B * sf)
    {
       P n; B * s; L32 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32BdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32BdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32BdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32BdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32BdySUBAAs(df,sf);
#if ENABLE_THREADS
      else L32BdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32BdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t *= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32BdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32BdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32BdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L32BdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32BdyMULASs(df, sf);
#if ENABLE_THREADS
    else L32BdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32BdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32BdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32BdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32BdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32BdyMULSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32BdyMULSAs(df, sf);
#if ENABLE_THREADS
    else L32BdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32BdyMULAAs(B * df, B * sf)
    {
       P n; B * s; L32 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32BdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32BdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32BdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32BdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32BdyMULAAs(df,sf);
#if ENABLE_THREADS
      else L32BdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32BdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t /= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32BdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32BdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32BdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L32BdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32BdyDIVASs(df, sf);
#if ENABLE_THREADS
    else L32BdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32BdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32BdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32BdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32BdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32BdyDIVSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32BdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L32BdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32BdyDIVAAs(B * df, B * sf)
    {
       P n; B * s; L32 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32BdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32BdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32BdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32BdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32BdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L32BdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32BdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32BdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32BdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32BdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L32BdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32BdyPWRASs(df, sf);
#if ENABLE_THREADS
    else L32BdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32BdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32BdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32BdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32BdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32BdyPWRSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32BdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L32BdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32BdyPWRAAs(B * df, B * sf)
    {
       P n; B * s; L32 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32BdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32BdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32BdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32BdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32BdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L32BdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32BdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32BdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32BdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32BdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L32BdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32BdyMODASs(df, sf);
#if ENABLE_THREADS
    else L32BdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32BdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32BdyMODSA(B* df, B *sf)
  {
    L32BdyMODSAs(df, sf);
  }

    static void L32BdyMODAAs(B * df, B * sf)
    {
       P n; B * s; L32 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32BdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32BdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32BdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32BdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32BdyMODAAs(df,sf);
#if ENABLE_THREADS
      else L32BdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32BdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32BdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32BdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32BdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L32BdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32BdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32BdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L32BdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32BdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32BdyTHEARCSA(B* df, B *sf)
  {
    L32BdyTHEARCSAs(df, sf);
  }

    static void L32BdyTHEARCAAs(B * df, B * sf)
    {
       P n; B * s; L32 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32BdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32BdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32BdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32BdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32BdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32BdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L32BdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32WdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t += tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32WdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32WdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32WdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L32WdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32WdyADDASs(df, sf);
#if ENABLE_THREADS
    else L32WdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32WdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32WdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32WdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32WdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32WdyADDSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32WdyADDSAs(df, sf);
#if ENABLE_THREADS
    else L32WdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32WdyADDAAs(B * df, B * sf)
    {
       P n; W * s; L32 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32WdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32WdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32WdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32WdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32WdyADDAAs(df,sf);
#if ENABLE_THREADS
      else L32WdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32WdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t -= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32WdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32WdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32WdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L32WdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32WdySUBASs(df, sf);
#if ENABLE_THREADS
    else L32WdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32WdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32WdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32WdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32WdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32WdySUBSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32WdySUBSAs(df, sf);
#if ENABLE_THREADS
    else L32WdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32WdySUBAAs(B * df, B * sf)
    {
       P n; W * s; L32 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32WdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32WdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32WdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32WdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32WdySUBAAs(df,sf);
#if ENABLE_THREADS
      else L32WdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32WdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t *= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32WdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32WdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32WdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L32WdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32WdyMULASs(df, sf);
#if ENABLE_THREADS
    else L32WdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32WdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32WdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32WdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32WdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32WdyMULSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32WdyMULSAs(df, sf);
#if ENABLE_THREADS
    else L32WdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32WdyMULAAs(B * df, B * sf)
    {
       P n; W * s; L32 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32WdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32WdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32WdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32WdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32WdyMULAAs(df,sf);
#if ENABLE_THREADS
      else L32WdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32WdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t /= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32WdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32WdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32WdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L32WdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32WdyDIVASs(df, sf);
#if ENABLE_THREADS
    else L32WdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32WdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32WdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32WdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32WdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32WdyDIVSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32WdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L32WdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32WdyDIVAAs(B * df, B * sf)
    {
       P n; W * s; L32 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32WdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32WdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32WdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32WdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32WdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L32WdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32WdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32WdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32WdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32WdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L32WdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32WdyPWRASs(df, sf);
#if ENABLE_THREADS
    else L32WdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32WdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32WdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32WdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32WdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32WdyPWRSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32WdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L32WdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32WdyPWRAAs(B * df, B * sf)
    {
       P n; W * s; L32 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32WdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32WdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32WdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32WdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32WdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L32WdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32WdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32WdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32WdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32WdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L32WdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32WdyMODASs(df, sf);
#if ENABLE_THREADS
    else L32WdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32WdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32WdyMODSA(B* df, B *sf)
  {
    L32WdyMODSAs(df, sf);
  }

    static void L32WdyMODAAs(B * df, B * sf)
    {
       P n; W * s; L32 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32WdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32WdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32WdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32WdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32WdyMODAAs(df,sf);
#if ENABLE_THREADS
      else L32WdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32WdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32WdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32WdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32WdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L32WdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32WdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32WdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L32WdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32WdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32WdyTHEARCSA(B* df, B *sf)
  {
    L32WdyTHEARCSAs(df, sf);
  }

    static void L32WdyTHEARCAAs(B * df, B * sf)
    {
       P n; W * s; L32 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32WdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32WdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32WdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32WdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32WdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32WdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L32WdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L32dyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t += tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L32dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L32dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L32dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32L32dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L32dyADDASs(df, sf);
#if ENABLE_THREADS
    else L32L32dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L32dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L32dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L32dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L32dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L32dyADDSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L32dyADDSAs(df, sf);
#if ENABLE_THREADS
    else L32L32dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L32dyADDAAs(B * df, B * sf)
    {
       P n; L32 * s; L32 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L32dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L32dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L32dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L32dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L32dyADDAAs(df,sf);
#if ENABLE_THREADS
      else L32L32dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L32dySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t -= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L32dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L32dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L32dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32L32dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L32dySUBASs(df, sf);
#if ENABLE_THREADS
    else L32L32dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L32dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L32dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L32dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L32dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L32dySUBSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L32dySUBSAs(df, sf);
#if ENABLE_THREADS
    else L32L32dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L32dySUBAAs(B * df, B * sf)
    {
       P n; L32 * s; L32 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L32dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L32dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L32dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L32dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L32dySUBAAs(df,sf);
#if ENABLE_THREADS
      else L32L32dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L32dyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t *= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L32dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L32dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L32dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32L32dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L32dyMULASs(df, sf);
#if ENABLE_THREADS
    else L32L32dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L32dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L32dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L32dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L32dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L32dyMULSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L32dyMULSAs(df, sf);
#if ENABLE_THREADS
    else L32L32dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L32dyMULAAs(B * df, B * sf)
    {
       P n; L32 * s; L32 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L32dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L32dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L32dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L32dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L32dyMULAAs(df,sf);
#if ENABLE_THREADS
      else L32L32dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L32dyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t /= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L32dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L32dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L32dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32L32dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L32dyDIVASs(df, sf);
#if ENABLE_THREADS
    else L32L32dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L32dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L32dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L32dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L32dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L32dyDIVSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L32dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L32L32dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L32dyDIVAAs(B * df, B * sf)
    {
       P n; L32 * s; L32 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L32dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L32dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L32dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L32dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L32dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L32L32dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L32dyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L32dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L32dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L32dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32L32dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L32dyPWRASs(df, sf);
#if ENABLE_THREADS
    else L32L32dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L32dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L32dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L32dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L32dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L32dyPWRSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L32dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L32L32dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L32dyPWRAAs(B * df, B * sf)
    {
       P n; L32 * s; L32 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L32dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L32dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L32dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L32dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L32dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L32L32dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L32dyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L32dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L32dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L32dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32L32dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L32dyMODASs(df, sf);
#if ENABLE_THREADS
    else L32L32dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L32dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32L32dyMODSA(B* df, B *sf)
  {
    L32L32dyMODSAs(df, sf);
  }

    static void L32L32dyMODAAs(B * df, B * sf)
    {
       P n; L32 * s; L32 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L32dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L32dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L32dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L32dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L32dyMODAAs(df,sf);
#if ENABLE_THREADS
      else L32L32dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L32dyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L32dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L32dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L32dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L32L32dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L32dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L32dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L32L32dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L32dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32L32dyTHEARCSA(B* df, B *sf)
  {
    L32L32dyTHEARCSAs(df, sf);
  }

    static void L32L32dyTHEARCAAs(B * df, B * sf)
    {
       P n; L32 * s; L32 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L32dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L32dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L32dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L32dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L32dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L32dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L32L32dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L64dyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t += tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L64dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L64dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L64dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L32L64dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L64dyADDASs(df, sf);
#if ENABLE_THREADS
    else L32L64dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L64dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L64dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L64dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L64dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L64dyADDSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L64dyADDSAs(df, sf);
#if ENABLE_THREADS
    else L32L64dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L64dyADDAAs(B * df, B * sf)
    {
       P n; L64 * s; L32 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L64dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L64dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L64dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L64dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L64dyADDAAs(df,sf);
#if ENABLE_THREADS
      else L32L64dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L64dySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t -= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L64dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L64dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L64dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L32L64dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L64dySUBASs(df, sf);
#if ENABLE_THREADS
    else L32L64dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L64dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L64dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L64dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L64dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L64dySUBSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L64dySUBSAs(df, sf);
#if ENABLE_THREADS
    else L32L64dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L64dySUBAAs(B * df, B * sf)
    {
       P n; L64 * s; L32 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L64dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L64dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L64dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L64dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L64dySUBAAs(df,sf);
#if ENABLE_THREADS
      else L32L64dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L64dyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t *= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L64dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L64dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L64dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L32L64dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L64dyMULASs(df, sf);
#if ENABLE_THREADS
    else L32L64dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L64dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L64dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L64dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L64dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L64dyMULSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L64dyMULSAs(df, sf);
#if ENABLE_THREADS
    else L32L64dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L64dyMULAAs(B * df, B * sf)
    {
       P n; L64 * s; L32 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L64dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L64dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L64dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L64dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L64dyMULAAs(df,sf);
#if ENABLE_THREADS
      else L32L64dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L64dyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t /= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L64dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L64dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L64dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L32L64dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L64dyDIVASs(df, sf);
#if ENABLE_THREADS
    else L32L64dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L64dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L64dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L64dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L64dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L64dyDIVSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L64dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L32L64dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L64dyDIVAAs(B * df, B * sf)
    {
       P n; L64 * s; L32 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L64dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L64dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L64dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L64dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L64dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L32L64dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L64dyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L64dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L64dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L64dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L32L64dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L64dyPWRASs(df, sf);
#if ENABLE_THREADS
    else L32L64dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L64dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32L64dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32L64dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32L64dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32L64dyPWRSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32L64dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L32L64dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32L64dyPWRAAs(B * df, B * sf)
    {
       P n; L64 * s; L32 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L64dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L64dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L64dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L64dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L64dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L32L64dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L64dyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L64dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L64dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L64dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L32L64dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L64dyMODASs(df, sf);
#if ENABLE_THREADS
    else L32L64dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L64dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32L64dyMODSA(B* df, B *sf)
  {
    L32L64dyMODSAs(df, sf);
  }

    static void L32L64dyMODAAs(B * df, B * sf)
    {
       P n; L64 * s; L32 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L64dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L64dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L64dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L64dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L64dyMODAAs(df,sf);
#if ENABLE_THREADS
      else L32L64dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32L64dyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32L64dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32L64dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32L64dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L32L64dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32L64dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32L64dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L32L64dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32L64dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32L64dyTHEARCSA(B* df, B *sf)
  {
    L32L64dyTHEARCSAs(df, sf);
  }

    static void L32L64dyTHEARCAAs(B * df, B * sf)
    {
       P n; L64 * s; L32 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32L64dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32L64dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32L64dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32L64dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32L64dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32L64dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L32L64dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32SdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32SdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32SdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32SdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L32SdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32SdyADDASs(df, sf);
#if ENABLE_THREADS
    else L32SdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32SdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32SdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32SdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32SdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32SdyADDSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32SdyADDSAs(df, sf);
#if ENABLE_THREADS
    else L32SdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32SdyADDAAs(B * df, B * sf)
    {
       P n; S * s; L32 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32SdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32SdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32SdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32SdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32SdyADDAAs(df,sf);
#if ENABLE_THREADS
      else L32SdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32SdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32SdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32SdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32SdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L32SdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32SdySUBASs(df, sf);
#if ENABLE_THREADS
    else L32SdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32SdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32SdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32SdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32SdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32SdySUBSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32SdySUBSAs(df, sf);
#if ENABLE_THREADS
    else L32SdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32SdySUBAAs(B * df, B * sf)
    {
       P n; S * s; L32 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32SdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32SdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32SdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32SdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32SdySUBAAs(df,sf);
#if ENABLE_THREADS
      else L32SdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32SdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32SdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32SdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32SdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L32SdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32SdyMULASs(df, sf);
#if ENABLE_THREADS
    else L32SdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32SdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32SdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32SdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32SdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32SdyMULSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32SdyMULSAs(df, sf);
#if ENABLE_THREADS
    else L32SdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32SdyMULAAs(B * df, B * sf)
    {
       P n; S * s; L32 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32SdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32SdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32SdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32SdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32SdyMULAAs(df,sf);
#if ENABLE_THREADS
      else L32SdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32SdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32SdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32SdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32SdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L32SdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32SdyDIVASs(df, sf);
#if ENABLE_THREADS
    else L32SdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32SdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32SdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32SdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32SdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32SdyDIVSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32SdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L32SdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32SdyDIVAAs(B * df, B * sf)
    {
       P n; S * s; L32 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32SdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32SdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32SdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32SdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32SdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L32SdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32SdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32SdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32SdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32SdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L32SdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32SdyPWRASs(df, sf);
#if ENABLE_THREADS
    else L32SdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32SdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32SdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32SdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32SdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32SdyPWRSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32SdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L32SdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32SdyPWRAAs(B * df, B * sf)
    {
       P n; S * s; L32 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32SdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32SdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32SdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32SdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32SdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L32SdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32SdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32SdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32SdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32SdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L32SdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32SdyMODASs(df, sf);
#if ENABLE_THREADS
    else L32SdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32SdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32SdyMODSA(B* df, B *sf)
  {
    L32SdyMODSAs(df, sf);
  }

    static void L32SdyMODAAs(B * df, B * sf)
    {
       P n; S * s; L32 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32SdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32SdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32SdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32SdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32SdyMODAAs(df,sf);
#if ENABLE_THREADS
      else L32SdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32SdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32SdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32SdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32SdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L32SdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32SdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32SdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L32SdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32SdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32SdyTHEARCSA(B* df, B *sf)
  {
    L32SdyTHEARCSAs(df, sf);
  }

    static void L32SdyTHEARCAAs(B * df, B * sf)
    {
       P n; S * s; L32 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32SdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32SdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32SdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32SdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32SdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32SdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L32SdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32DdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32DdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32DdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32DdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L32DdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32DdyADDASs(df, sf);
#if ENABLE_THREADS
    else L32DdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32DdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32DdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32DdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32DdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32DdyADDSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32DdyADDSAs(df, sf);
#if ENABLE_THREADS
    else L32DdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32DdyADDAAs(B * df, B * sf)
    {
       P n; D * s; L32 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32DdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t += tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32DdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32DdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32DdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32DdyADDAAs(df,sf);
#if ENABLE_THREADS
      else L32DdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32DdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32DdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32DdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32DdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L32DdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32DdySUBASs(df, sf);
#if ENABLE_THREADS
    else L32DdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32DdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32DdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32DdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32DdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32DdySUBSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32DdySUBSAs(df, sf);
#if ENABLE_THREADS
    else L32DdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32DdySUBAAs(B * df, B * sf)
    {
       P n; D * s; L32 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32DdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t -= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32DdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32DdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32DdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32DdySUBAAs(df,sf);
#if ENABLE_THREADS
      else L32DdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32DdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32DdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32DdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32DdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L32DdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32DdyMULASs(df, sf);
#if ENABLE_THREADS
    else L32DdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32DdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32DdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32DdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32DdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32DdyMULSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32DdyMULSAs(df, sf);
#if ENABLE_THREADS
    else L32DdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32DdyMULAAs(B * df, B * sf)
    {
       P n; D * s; L32 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32DdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t *= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32DdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32DdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32DdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32DdyMULAAs(df,sf);
#if ENABLE_THREADS
      else L32DdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32DdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32DdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32DdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32DdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L32DdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32DdyDIVASs(df, sf);
#if ENABLE_THREADS
    else L32DdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32DdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32DdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32DdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32DdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32DdyDIVSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32DdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L32DdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32DdyDIVAAs(B * df, B * sf)
    {
       P n; D * s; L32 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32DdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t /= tt;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32DdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32DdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32DdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32DdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L32DdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32DdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32DdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32DdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32DdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L32DdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32DdyPWRASs(df, sf);
#if ENABLE_THREADS
    else L32DdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32DdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

#if ENABLE_THREADS
 static P L32DdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L32DdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L32DdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L32DdyPWRSAt, &data, ret);
      
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L32DdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L32DdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L32DdyPWRAAs(B * df, B * sf)
    {
       P n; D * s; L32 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32DdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = pow(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32DdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32DdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32DdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32DdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L32DdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32DdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32DdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32DdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32DdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L32DdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32DdyMODASs(df, sf);
#if ENABLE_THREADS
    else L32DdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32DdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32DdyMODSA(B* df, B *sf)
  {
    L32DdyMODSAs(df, sf);
  }

    static void L32DdyMODAAs(B * df, B * sf)
    {
       P n; D * s; L32 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32DdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32DdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32DdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32DdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32DdyMODAAs(df,sf);
#if ENABLE_THREADS
      else L32DdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L32DdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

  static void L32DdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L32 * d;
    d = (L32 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  }

#if ENABLE_THREADS
  static P L32DdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }

  static void L32DdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L32DdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32DdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L32DdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L32DdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L32DdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}}
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
   }

  static void L32DdyTHEARCSA(B* df, B *sf)
  {
    L32DdyTHEARCSAs(df, sf);
  }

    static void L32DdyTHEARCAAs(B * df, B * sf)
    {
       P n; D * s; L32 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
    }


#if ENABLE_THREADS
    static P L32DdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
    }

    static void L32DdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32DdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L32DdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L32DdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L32DdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L32DdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64BdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t += tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64BdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64BdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64BdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L64BdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64BdyADDASs(df, sf);
#if ENABLE_THREADS
    else L64BdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64BdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64BdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64BdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64BdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64BdyADDSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64BdyADDSAs(df, sf);
#if ENABLE_THREADS
    else L64BdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64BdyADDAAs(B * df, B * sf)
    {
       P n; B * s; L64 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64BdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64BdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64BdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64BdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64BdyADDAAs(df,sf);
#if ENABLE_THREADS
      else L64BdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64BdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t -= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64BdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64BdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64BdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L64BdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64BdySUBASs(df, sf);
#if ENABLE_THREADS
    else L64BdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64BdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64BdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64BdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64BdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64BdySUBSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64BdySUBSAs(df, sf);
#if ENABLE_THREADS
    else L64BdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64BdySUBAAs(B * df, B * sf)
    {
       P n; B * s; L64 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64BdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64BdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64BdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64BdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64BdySUBAAs(df,sf);
#if ENABLE_THREADS
      else L64BdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64BdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t *= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64BdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64BdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64BdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L64BdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64BdyMULASs(df, sf);
#if ENABLE_THREADS
    else L64BdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64BdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64BdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64BdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64BdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64BdyMULSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64BdyMULSAs(df, sf);
#if ENABLE_THREADS
    else L64BdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64BdyMULAAs(B * df, B * sf)
    {
       P n; B * s; L64 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64BdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64BdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64BdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64BdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64BdyMULAAs(df,sf);
#if ENABLE_THREADS
      else L64BdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64BdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t /= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64BdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64BdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64BdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L64BdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64BdyDIVASs(df, sf);
#if ENABLE_THREADS
    else L64BdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64BdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64BdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64BdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64BdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64BdyDIVSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64BdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L64BdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64BdyDIVAAs(B * df, B * sf)
    {
       P n; B * s; L64 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64BdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64BdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64BdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64BdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64BdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L64BdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64BdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64BdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64BdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64BdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L64BdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64BdyPWRASs(df, sf);
#if ENABLE_THREADS
    else L64BdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64BdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64BdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64BdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64BdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64BdyPWRSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64BdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L64BdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64BdyPWRAAs(B * df, B * sf)
    {
       P n; B * s; L64 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64BdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64BdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64BdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64BdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64BdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L64BdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64BdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64BdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64BdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64BdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L64BdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64BdyMODASs(df, sf);
#if ENABLE_THREADS
    else L64BdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64BdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64BdyMODSA(B* df, B *sf)
  {
    L64BdyMODSAs(df, sf);
  }

    static void L64BdyMODAAs(B * df, B * sf)
    {
       P n; B * s; L64 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64BdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64BdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64BdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64BdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64BdyMODAAs(df,sf);
#if ENABLE_THREADS
      else L64BdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64BdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64BdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64BdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64BdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, L64BdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64BdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64BdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L64BdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64BdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64BdyTHEARCSA(B* df, B *sf)
  {
    L64BdyTHEARCSAs(df, sf);
  }

    static void L64BdyTHEARCAAs(B * df, B * sf)
    {
       P n; B * s; L64 * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64BdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64BdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64BdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64BdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64BdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64BdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L64BdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64WdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t += tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64WdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64WdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64WdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L64WdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64WdyADDASs(df, sf);
#if ENABLE_THREADS
    else L64WdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64WdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64WdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64WdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64WdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64WdyADDSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64WdyADDSAs(df, sf);
#if ENABLE_THREADS
    else L64WdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64WdyADDAAs(B * df, B * sf)
    {
       P n; W * s; L64 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64WdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64WdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64WdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64WdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64WdyADDAAs(df,sf);
#if ENABLE_THREADS
      else L64WdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64WdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t -= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64WdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64WdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64WdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L64WdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64WdySUBASs(df, sf);
#if ENABLE_THREADS
    else L64WdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64WdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64WdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64WdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64WdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64WdySUBSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64WdySUBSAs(df, sf);
#if ENABLE_THREADS
    else L64WdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64WdySUBAAs(B * df, B * sf)
    {
       P n; W * s; L64 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64WdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64WdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64WdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64WdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64WdySUBAAs(df,sf);
#if ENABLE_THREADS
      else L64WdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64WdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t *= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64WdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64WdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64WdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L64WdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64WdyMULASs(df, sf);
#if ENABLE_THREADS
    else L64WdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64WdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64WdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64WdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64WdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64WdyMULSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64WdyMULSAs(df, sf);
#if ENABLE_THREADS
    else L64WdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64WdyMULAAs(B * df, B * sf)
    {
       P n; W * s; L64 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64WdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64WdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64WdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64WdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64WdyMULAAs(df,sf);
#if ENABLE_THREADS
      else L64WdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64WdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t /= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64WdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64WdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64WdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L64WdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64WdyDIVASs(df, sf);
#if ENABLE_THREADS
    else L64WdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64WdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64WdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64WdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64WdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64WdyDIVSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64WdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L64WdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64WdyDIVAAs(B * df, B * sf)
    {
       P n; W * s; L64 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64WdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64WdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64WdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64WdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64WdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L64WdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64WdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64WdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64WdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64WdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L64WdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64WdyPWRASs(df, sf);
#if ENABLE_THREADS
    else L64WdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64WdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64WdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64WdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64WdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64WdyPWRSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64WdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L64WdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64WdyPWRAAs(B * df, B * sf)
    {
       P n; W * s; L64 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64WdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64WdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64WdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64WdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64WdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L64WdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64WdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64WdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64WdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64WdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L64WdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64WdyMODASs(df, sf);
#if ENABLE_THREADS
    else L64WdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64WdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64WdyMODSA(B* df, B *sf)
  {
    L64WdyMODSAs(df, sf);
  }

    static void L64WdyMODAAs(B * df, B * sf)
    {
       P n; W * s; L64 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64WdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64WdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64WdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64WdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64WdyMODAAs(df,sf);
#if ENABLE_THREADS
      else L64WdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64WdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64WdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64WdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64WdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, L64WdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64WdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64WdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L64WdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64WdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64WdyTHEARCSA(B* df, B *sf)
  {
    L64WdyTHEARCSAs(df, sf);
  }

    static void L64WdyTHEARCAAs(B * df, B * sf)
    {
       P n; W * s; L64 * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64WdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64WdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64WdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64WdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64WdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64WdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L64WdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L32dyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t += tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L32dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L32dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L32dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L64L32dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L32dyADDASs(df, sf);
#if ENABLE_THREADS
    else L64L32dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L32dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L32dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L32dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L32dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L32dyADDSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L32dyADDSAs(df, sf);
#if ENABLE_THREADS
    else L64L32dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L32dyADDAAs(B * df, B * sf)
    {
       P n; L32 * s; L64 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L32dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L32dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L32dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L32dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L32dyADDAAs(df,sf);
#if ENABLE_THREADS
      else L64L32dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L32dySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t -= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L32dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L32dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L32dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L64L32dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L32dySUBASs(df, sf);
#if ENABLE_THREADS
    else L64L32dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L32dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L32dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L32dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L32dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L32dySUBSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L32dySUBSAs(df, sf);
#if ENABLE_THREADS
    else L64L32dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L32dySUBAAs(B * df, B * sf)
    {
       P n; L32 * s; L64 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L32dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L32dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L32dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L32dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L32dySUBAAs(df,sf);
#if ENABLE_THREADS
      else L64L32dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L32dyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t *= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L32dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L32dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L32dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L64L32dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L32dyMULASs(df, sf);
#if ENABLE_THREADS
    else L64L32dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L32dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L32dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L32dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L32dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L32dyMULSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L32dyMULSAs(df, sf);
#if ENABLE_THREADS
    else L64L32dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L32dyMULAAs(B * df, B * sf)
    {
       P n; L32 * s; L64 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L32dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L32dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L32dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L32dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L32dyMULAAs(df,sf);
#if ENABLE_THREADS
      else L64L32dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L32dyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t /= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L32dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L32dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L32dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L64L32dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L32dyDIVASs(df, sf);
#if ENABLE_THREADS
    else L64L32dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L32dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L32dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L32dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L32dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L32dyDIVSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L32dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L64L32dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L32dyDIVAAs(B * df, B * sf)
    {
       P n; L32 * s; L64 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L32dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L32dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L32dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L32dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L32dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L64L32dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L32dyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L32dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L32dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L32dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L64L32dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L32dyPWRASs(df, sf);
#if ENABLE_THREADS
    else L64L32dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L32dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L32dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L32dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L32dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L32dyPWRSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L32dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L64L32dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L32dyPWRAAs(B * df, B * sf)
    {
       P n; L32 * s; L64 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L32dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L32dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L32dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L32dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L32dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L64L32dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L32dyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L32dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L32dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L32dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L64L32dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L32dyMODASs(df, sf);
#if ENABLE_THREADS
    else L64L32dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L32dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64L32dyMODSA(B* df, B *sf)
  {
    L64L32dyMODSAs(df, sf);
  }

    static void L64L32dyMODAAs(B * df, B * sf)
    {
       P n; L32 * s; L64 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L32dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L32dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L32dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L32dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L32dyMODAAs(df,sf);
#if ENABLE_THREADS
      else L64L32dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L32dyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L32dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L32dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L32dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, L64L32dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L32dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L32dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L64L32dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L32dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64L32dyTHEARCSA(B* df, B *sf)
  {
    L64L32dyTHEARCSAs(df, sf);
  }

    static void L64L32dyTHEARCAAs(B * df, B * sf)
    {
       P n; L32 * s; L64 * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L32dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L32dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L32dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L32dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L32dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L32dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L64L32dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L64dyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t += tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L64dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L64dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L64dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64L64dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L64dyADDASs(df, sf);
#if ENABLE_THREADS
    else L64L64dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L64dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L64dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L64dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L64dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L64dyADDSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L64dyADDSAs(df, sf);
#if ENABLE_THREADS
    else L64L64dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L64dyADDAAs(B * df, B * sf)
    {
       P n; L64 * s; L64 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L64dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L64dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L64dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L64dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L64dyADDAAs(df,sf);
#if ENABLE_THREADS
      else L64L64dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L64dySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t -= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L64dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L64dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L64dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64L64dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L64dySUBASs(df, sf);
#if ENABLE_THREADS
    else L64L64dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L64dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L64dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L64dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L64dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L64dySUBSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L64dySUBSAs(df, sf);
#if ENABLE_THREADS
    else L64L64dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L64dySUBAAs(B * df, B * sf)
    {
       P n; L64 * s; L64 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L64dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L64dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L64dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L64dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L64dySUBAAs(df,sf);
#if ENABLE_THREADS
      else L64L64dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L64dyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t *= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L64dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L64dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L64dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64L64dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L64dyMULASs(df, sf);
#if ENABLE_THREADS
    else L64L64dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L64dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L64dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L64dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L64dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L64dyMULSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L64dyMULSAs(df, sf);
#if ENABLE_THREADS
    else L64L64dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L64dyMULAAs(B * df, B * sf)
    {
       P n; L64 * s; L64 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L64dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L64dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L64dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L64dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L64dyMULAAs(df,sf);
#if ENABLE_THREADS
      else L64L64dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L64dyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t /= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L64dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L64dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L64dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64L64dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L64dyDIVASs(df, sf);
#if ENABLE_THREADS
    else L64L64dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L64dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L64dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L64dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L64dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L64dyDIVSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L64dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L64L64dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L64dyDIVAAs(B * df, B * sf)
    {
       P n; L64 * s; L64 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L64dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L64dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L64dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L64dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L64dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L64L64dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L64dyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L64dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L64dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L64dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64L64dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L64dyPWRASs(df, sf);
#if ENABLE_THREADS
    else L64L64dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L64dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64L64dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64L64dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64L64dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64L64dyPWRSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64L64dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L64L64dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64L64dyPWRAAs(B * df, B * sf)
    {
       P n; L64 * s; L64 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L64dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L64dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L64dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L64dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L64dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L64L64dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L64dyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L64dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L64dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L64dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64L64dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L64dyMODASs(df, sf);
#if ENABLE_THREADS
    else L64L64dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L64dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64L64dyMODSA(B* df, B *sf)
  {
    L64L64dyMODSAs(df, sf);
  }

    static void L64L64dyMODAAs(B * df, B * sf)
    {
       P n; L64 * s; L64 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L64dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L64dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L64dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L64dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L64dyMODAAs(df,sf);
#if ENABLE_THREADS
      else L64L64dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64L64dyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64L64dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64L64dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64L64dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, L64L64dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64L64dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64L64dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L64L64dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64L64dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64L64dyTHEARCSA(B* df, B *sf)
  {
    L64L64dyTHEARCSAs(df, sf);
  }

    static void L64L64dyTHEARCAAs(B * df, B * sf)
    {
       P n; L64 * s; L64 * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64L64dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64L64dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64L64dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64L64dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64L64dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64L64dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L64L64dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64SdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64SdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64SdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64SdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L64SdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64SdyADDASs(df, sf);
#if ENABLE_THREADS
    else L64SdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64SdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64SdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64SdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64SdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64SdyADDSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64SdyADDSAs(df, sf);
#if ENABLE_THREADS
    else L64SdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64SdyADDAAs(B * df, B * sf)
    {
       P n; S * s; L64 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64SdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64SdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64SdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64SdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64SdyADDAAs(df,sf);
#if ENABLE_THREADS
      else L64SdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64SdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64SdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64SdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64SdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L64SdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64SdySUBASs(df, sf);
#if ENABLE_THREADS
    else L64SdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64SdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64SdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64SdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64SdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64SdySUBSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64SdySUBSAs(df, sf);
#if ENABLE_THREADS
    else L64SdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64SdySUBAAs(B * df, B * sf)
    {
       P n; S * s; L64 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64SdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64SdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64SdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64SdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64SdySUBAAs(df,sf);
#if ENABLE_THREADS
      else L64SdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64SdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64SdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64SdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64SdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L64SdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64SdyMULASs(df, sf);
#if ENABLE_THREADS
    else L64SdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64SdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64SdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64SdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64SdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64SdyMULSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64SdyMULSAs(df, sf);
#if ENABLE_THREADS
    else L64SdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64SdyMULAAs(B * df, B * sf)
    {
       P n; S * s; L64 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64SdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64SdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64SdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64SdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64SdyMULAAs(df,sf);
#if ENABLE_THREADS
      else L64SdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64SdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64SdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64SdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64SdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L64SdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64SdyDIVASs(df, sf);
#if ENABLE_THREADS
    else L64SdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64SdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64SdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64SdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64SdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64SdyDIVSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64SdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L64SdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64SdyDIVAAs(B * df, B * sf)
    {
       P n; S * s; L64 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64SdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64SdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64SdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64SdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64SdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L64SdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64SdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64SdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64SdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64SdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L64SdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64SdyPWRASs(df, sf);
#if ENABLE_THREADS
    else L64SdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64SdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64SdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64SdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64SdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64SdyPWRSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64SdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L64SdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64SdyPWRAAs(B * df, B * sf)
    {
       P n; S * s; L64 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64SdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64SdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64SdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64SdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64SdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L64SdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64SdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64SdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64SdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64SdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L64SdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64SdyMODASs(df, sf);
#if ENABLE_THREADS
    else L64SdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64SdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64SdyMODSA(B* df, B *sf)
  {
    L64SdyMODSAs(df, sf);
  }

    static void L64SdyMODAAs(B * df, B * sf)
    {
       P n; S * s; L64 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64SdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64SdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64SdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64SdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64SdyMODAAs(df,sf);
#if ENABLE_THREADS
      else L64SdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64SdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64SdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64SdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64SdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, L64SdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64SdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64SdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L64SdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64SdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64SdyTHEARCSA(B* df, B *sf)
  {
    L64SdyTHEARCSAs(df, sf);
  }

    static void L64SdyTHEARCAAs(B * df, B * sf)
    {
       P n; S * s; L64 * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64SdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64SdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64SdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64SdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64SdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64SdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L64SdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64DdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64DdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64DdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64DdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L64DdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64DdyADDASs(df, sf);
#if ENABLE_THREADS
    else L64DdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64DdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64DdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64DdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64DdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64DdyADDSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64DdyADDSAs(df, sf);
#if ENABLE_THREADS
    else L64DdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64DdyADDAAs(B * df, B * sf)
    {
       P n; D * s; L64 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64DdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t += tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64DdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64DdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64DdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64DdyADDAAs(df,sf);
#if ENABLE_THREADS
      else L64DdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64DdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64DdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64DdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64DdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L64DdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64DdySUBASs(df, sf);
#if ENABLE_THREADS
    else L64DdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64DdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64DdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64DdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64DdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64DdySUBSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64DdySUBSAs(df, sf);
#if ENABLE_THREADS
    else L64DdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64DdySUBAAs(B * df, B * sf)
    {
       P n; D * s; L64 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64DdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t -= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64DdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64DdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64DdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64DdySUBAAs(df,sf);
#if ENABLE_THREADS
      else L64DdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64DdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64DdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64DdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64DdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L64DdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64DdyMULASs(df, sf);
#if ENABLE_THREADS
    else L64DdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64DdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64DdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64DdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64DdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64DdyMULSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64DdyMULSAs(df, sf);
#if ENABLE_THREADS
    else L64DdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64DdyMULAAs(B * df, B * sf)
    {
       P n; D * s; L64 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64DdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t *= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64DdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64DdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64DdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64DdyMULAAs(df,sf);
#if ENABLE_THREADS
      else L64DdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64DdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64DdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64DdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64DdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L64DdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64DdyDIVASs(df, sf);
#if ENABLE_THREADS
    else L64DdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64DdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64DdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64DdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64DdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64DdyDIVSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64DdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else L64DdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64DdyDIVAAs(B * df, B * sf)
    {
       P n; D * s; L64 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64DdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t /= tt;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64DdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64DdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64DdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64DdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else L64DdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64DdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64DdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64DdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64DdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L64DdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64DdyPWRASs(df, sf);
#if ENABLE_THREADS
    else L64DdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64DdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

#if ENABLE_THREADS
 static P L64DdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void L64DdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    L64DdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, L64DdyPWRSAt, &data, ret);
      
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      L64DdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else L64DdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void L64DdyPWRAAs(B * df, B * sf)
    {
       P n; D * s; L64 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64DdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = pow(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64DdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64DdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64DdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64DdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else L64DdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64DdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64DdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64DdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64DdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L64DdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64DdyMODASs(df, sf);
#if ENABLE_THREADS
    else L64DdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64DdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64DdyMODSA(B* df, B *sf)
  {
    L64DdyMODSAs(df, sf);
  }

    static void L64DdyMODAAs(B * df, B * sf)
    {
       P n; D * s; L64 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64DdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fmod(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64DdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64DdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64DdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64DdyMODAAs(df,sf);
#if ENABLE_THREADS
      else L64DdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void L64DdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

  static void L64DdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; L64 * d;
    d = (L64 *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  }

#if ENABLE_THREADS
  static P L64DdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }

  static void L64DdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, L64DdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64DdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    L64DdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else L64DdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void L64DdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}}
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
   }

  static void L64DdyTHEARCSA(B* df, B *sf)
  {
    L64DdyTHEARCSAs(df, sf);
  }

    static void L64DdyTHEARCAAs(B * df, B * sf)
    {
       P n; D * s; L64 * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
    }


#if ENABLE_THREADS
    static P L64DdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = thearc(t,tt);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
    }

    static void L64DdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64DdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, L64DdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void L64DdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) L64DdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else L64DdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SBdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SBdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, SBdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyADDASs(df, sf);
#if ENABLE_THREADS
    else SBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SBdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SBdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyADDAAs(B * df, B * sf)
    {
       P n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SBdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SBdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SBdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SBdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SBdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, SBdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdySUBASs(df, sf);
#if ENABLE_THREADS
    else SBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SBdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SBdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdySUBAAs(B * df, B * sf)
    {
       P n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SBdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SBdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SBdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SBdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SBdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, SBdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyMULASs(df, sf);
#if ENABLE_THREADS
    else SBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SBdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SBdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyMULAAs(B * df, B * sf)
    {
       P n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SBdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SBdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SBdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SBdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SBdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, SBdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SBdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SBdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyDIVAAs(B * df, B * sf)
    {
       P n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SBdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SBdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SBdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SBdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SBdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, SBdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SBdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SBdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SBdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SBdyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SBdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SBdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyPWRAAs(B * df, B * sf)
    {
       P n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SBdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SBdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SBdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SBdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SBdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, SBdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyMODASs(df, sf);
#if ENABLE_THREADS
    else SBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SBdyMODSA(B* df, B *sf)
  {
    SBdyMODSAs(df, sf);
  }

    static void SBdyMODAAs(B * df, B * sf)
    {
       P n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SBdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SBdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SBdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SBdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SBdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, SBdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SBdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SBdyTHEARCSA(B* df, B *sf)
  {
    SBdyTHEARCSAs(df, sf);
  }

    static void SBdyTHEARCAAs(B * df, B * sf)
    {
       P n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SBdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SBdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SBdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SBdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SBdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SWdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SWdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, SWdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyADDASs(df, sf);
#if ENABLE_THREADS
    else SWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SWdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SWdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyADDAAs(B * df, B * sf)
    {
       P n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SWdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SWdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SWdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SWdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SWdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, SWdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdySUBASs(df, sf);
#if ENABLE_THREADS
    else SWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SWdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SWdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdySUBAAs(B * df, B * sf)
    {
       P n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SWdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SWdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SWdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SWdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SWdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, SWdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyMULASs(df, sf);
#if ENABLE_THREADS
    else SWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SWdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SWdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyMULAAs(B * df, B * sf)
    {
       P n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SWdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SWdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SWdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SWdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SWdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, SWdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SWdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SWdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyDIVAAs(B * df, B * sf)
    {
       P n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SWdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SWdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SWdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SWdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SWdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, SWdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SWdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SWdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SWdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SWdyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SWdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SWdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyPWRAAs(B * df, B * sf)
    {
       P n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SWdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SWdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SWdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SWdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SWdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, SWdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyMODASs(df, sf);
#if ENABLE_THREADS
    else SWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SWdyMODSA(B* df, B *sf)
  {
    SWdyMODSAs(df, sf);
  }

    static void SWdyMODAAs(B * df, B * sf)
    {
       P n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SWdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SWdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SWdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SWdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SWdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, SWdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SWdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SWdyTHEARCSA(B* df, B *sf)
  {
    SWdyTHEARCSAs(df, sf);
  }

    static void SWdyTHEARCAAs(B * df, B * sf)
    {
       P n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SWdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SWdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SWdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SWdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SWdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL32dyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SL32dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL32dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL32dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, SL32dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL32dyADDASs(df, sf);
#if ENABLE_THREADS
    else SL32dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL32dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL32dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL32dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL32dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL32dyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL32dyADDSAs(df, sf);
#if ENABLE_THREADS
    else SL32dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL32dyADDAAs(B * df, B * sf)
    {
       P n; L32 * s; S * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL32dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL32dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL32dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL32dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL32dyADDAAs(df,sf);
#if ENABLE_THREADS
      else SL32dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL32dySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SL32dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL32dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL32dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, SL32dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL32dySUBASs(df, sf);
#if ENABLE_THREADS
    else SL32dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL32dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL32dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL32dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL32dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL32dySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL32dySUBSAs(df, sf);
#if ENABLE_THREADS
    else SL32dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL32dySUBAAs(B * df, B * sf)
    {
       P n; L32 * s; S * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL32dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL32dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL32dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL32dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL32dySUBAAs(df,sf);
#if ENABLE_THREADS
      else SL32dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL32dyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SL32dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL32dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL32dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, SL32dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL32dyMULASs(df, sf);
#if ENABLE_THREADS
    else SL32dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL32dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL32dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL32dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL32dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL32dyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL32dyMULSAs(df, sf);
#if ENABLE_THREADS
    else SL32dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL32dyMULAAs(B * df, B * sf)
    {
       P n; L32 * s; S * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL32dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL32dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL32dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL32dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL32dyMULAAs(df,sf);
#if ENABLE_THREADS
      else SL32dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL32dyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SL32dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL32dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL32dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, SL32dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL32dyDIVASs(df, sf);
#if ENABLE_THREADS
    else SL32dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL32dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL32dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL32dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL32dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL32dyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL32dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SL32dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL32dyDIVAAs(B * df, B * sf)
    {
       P n; L32 * s; S * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL32dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL32dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL32dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL32dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL32dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SL32dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL32dyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SL32dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL32dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL32dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, SL32dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL32dyPWRASs(df, sf);
#if ENABLE_THREADS
    else SL32dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL32dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL32dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL32dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL32dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL32dyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL32dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SL32dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL32dyPWRAAs(B * df, B * sf)
    {
       P n; L32 * s; S * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL32dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL32dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL32dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL32dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL32dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SL32dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL32dyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SL32dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL32dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL32dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, SL32dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL32dyMODASs(df, sf);
#if ENABLE_THREADS
    else SL32dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL32dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SL32dyMODSA(B* df, B *sf)
  {
    SL32dyMODSAs(df, sf);
  }

    static void SL32dyMODAAs(B * df, B * sf)
    {
       P n; L32 * s; S * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL32dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL32dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL32dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL32dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL32dyMODAAs(df,sf);
#if ENABLE_THREADS
      else SL32dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL32dyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SL32dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL32dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL32dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, SL32dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL32dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL32dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SL32dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL32dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SL32dyTHEARCSA(B* df, B *sf)
  {
    SL32dyTHEARCSAs(df, sf);
  }

    static void SL32dyTHEARCAAs(B * df, B * sf)
    {
       P n; L32 * s; S * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL32dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL32dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL32dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL32dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL32dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL32dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SL32dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL64dyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SL64dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL64dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL64dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, SL64dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL64dyADDASs(df, sf);
#if ENABLE_THREADS
    else SL64dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL64dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL64dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL64dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL64dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL64dyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL64dyADDSAs(df, sf);
#if ENABLE_THREADS
    else SL64dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL64dyADDAAs(B * df, B * sf)
    {
       P n; L64 * s; S * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL64dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL64dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL64dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL64dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL64dyADDAAs(df,sf);
#if ENABLE_THREADS
      else SL64dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL64dySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SL64dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL64dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL64dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, SL64dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL64dySUBASs(df, sf);
#if ENABLE_THREADS
    else SL64dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL64dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL64dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL64dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL64dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL64dySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL64dySUBSAs(df, sf);
#if ENABLE_THREADS
    else SL64dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL64dySUBAAs(B * df, B * sf)
    {
       P n; L64 * s; S * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL64dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL64dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL64dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL64dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL64dySUBAAs(df,sf);
#if ENABLE_THREADS
      else SL64dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL64dyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SL64dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL64dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL64dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, SL64dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL64dyMULASs(df, sf);
#if ENABLE_THREADS
    else SL64dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL64dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL64dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL64dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL64dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL64dyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL64dyMULSAs(df, sf);
#if ENABLE_THREADS
    else SL64dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL64dyMULAAs(B * df, B * sf)
    {
       P n; L64 * s; S * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL64dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL64dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL64dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL64dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL64dyMULAAs(df,sf);
#if ENABLE_THREADS
      else SL64dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL64dyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SL64dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL64dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL64dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, SL64dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL64dyDIVASs(df, sf);
#if ENABLE_THREADS
    else SL64dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL64dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL64dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL64dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL64dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL64dyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL64dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SL64dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL64dyDIVAAs(B * df, B * sf)
    {
       P n; L64 * s; S * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL64dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL64dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL64dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL64dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL64dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SL64dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL64dyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SL64dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL64dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL64dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, SL64dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL64dyPWRASs(df, sf);
#if ENABLE_THREADS
    else SL64dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL64dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SL64dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SL64dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SL64dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SL64dyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SL64dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SL64dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SL64dyPWRAAs(B * df, B * sf)
    {
       P n; L64 * s; S * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL64dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL64dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL64dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL64dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL64dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SL64dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL64dyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SL64dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL64dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL64dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, SL64dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL64dyMODASs(df, sf);
#if ENABLE_THREADS
    else SL64dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL64dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SL64dyMODSA(B* df, B *sf)
  {
    SL64dyMODSAs(df, sf);
  }

    static void SL64dyMODAAs(B * df, B * sf)
    {
       P n; L64 * s; S * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL64dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL64dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL64dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL64dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL64dyMODAAs(df,sf);
#if ENABLE_THREADS
      else SL64dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SL64dyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SL64dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SL64dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SL64dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, SL64dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SL64dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SL64dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SL64dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SL64dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SL64dyTHEARCSA(B* df, B *sf)
  {
    SL64dyTHEARCSAs(df, sf);
  }

    static void SL64dyTHEARCAAs(B * df, B * sf)
    {
       P n; L64 * s; S * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SL64dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SL64dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SL64dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SL64dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SL64dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SL64dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SL64dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SSdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SSdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyADDASs(df, sf);
#if ENABLE_THREADS
    else SSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SSdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SSdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyADDAAs(B * df, B * sf)
    {
       P n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SSdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SSdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SSdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SSdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SSdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdySUBASs(df, sf);
#if ENABLE_THREADS
    else SSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SSdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SSdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdySUBAAs(B * df, B * sf)
    {
       P n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SSdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SSdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SSdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SSdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SSdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyMULASs(df, sf);
#if ENABLE_THREADS
    else SSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SSdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SSdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyMULAAs(B * df, B * sf)
    {
       P n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SSdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SSdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SSdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SSdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SSdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SSdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SSdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyDIVAAs(B * df, B * sf)
    {
       P n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SSdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SSdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SSdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SSdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SSdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SSdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SSdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SSdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SSdyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SSdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SSdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyPWRAAs(B * df, B * sf)
    {
       P n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SSdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SSdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SSdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SSdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SSdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyMODASs(df, sf);
#if ENABLE_THREADS
    else SSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SSdyMODSA(B* df, B *sf)
  {
    SSdyMODSAs(df, sf);
  }

    static void SSdyMODAAs(B * df, B * sf)
    {
       P n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SSdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SSdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SSdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SSdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SSdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, SSdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SSdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SSdyTHEARCSA(B* df, B *sf)
  {
    SSdyTHEARCSAs(df, sf);
  }

    static void SSdyTHEARCAAs(B * df, B * sf)
    {
       P n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SSdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SSdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SSdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SSdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SSdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SDdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SDdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyADDASs(df, sf);
#if ENABLE_THREADS
    else SDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SDdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SDdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdyADDSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyADDAAs(B * df, B * sf)
    {
       P n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SDdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SDdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SDdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SDdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SDdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdySUBASs(df, sf);
#if ENABLE_THREADS
    else SDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SDdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SDdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdySUBSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdySUBAAs(B * df, B * sf)
    {
       P n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SDdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SDdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SDdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SDdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SDdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyMULASs(df, sf);
#if ENABLE_THREADS
    else SDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SDdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SDdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdyMULSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyMULAAs(B * df, B * sf)
    {
       P n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SDdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SDdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SDdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SDdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
  }

  static void SDdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SDdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SDdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdyDIVSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyDIVAAs(B * df, B * sf)
    {
       P n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SDdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}}
  return OK;
    }

    static void SDdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SDdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SDdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SDdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P SDdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void SDdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    SDdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, SDdyPWRSAt, &data, ret);
      
t = *((S *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      SDdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else SDdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyPWRAAs(B * df, B * sf)
    {
       P n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SDdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SDdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SDdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SDdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SDdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyMODASs(df, sf);
#if ENABLE_THREADS
    else SDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SDdyMODSA(B* df, B *sf)
  {
    SDdyMODSAs(df, sf);
  }

    static void SDdyMODAAs(B * df, B * sf)
    {
       P n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SDdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SDdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SDdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void SDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; S * d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P SDdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
  }

  static void SDdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, SDdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SDdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    SDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}}
*((S *)NUM_VAL(df)) = t;
   }

  static void SDdyTHEARCSA(B* df, B *sf)
  {
    SDdyTHEARCSAs(df, sf);
  }

    static void SDdyTHEARCAAs(B * df, B * sf)
    {
       P n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P SDdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}}
  return OK;
    }

    static void SDdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SDdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, SDdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void SDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) SDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SDdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DBdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DBdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, DBdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyADDASs(df, sf);
#if ENABLE_THREADS
    else DBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DBdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DBdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyADDAAs(B * df, B * sf)
    {
       P n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DBdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DBdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DBdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DBdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DBdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, DBdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdySUBASs(df, sf);
#if ENABLE_THREADS
    else DBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DBdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DBdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdySUBAAs(B * df, B * sf)
    {
       P n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DBdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DBdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DBdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DBdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DBdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, DBdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyMULASs(df, sf);
#if ENABLE_THREADS
    else DBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DBdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DBdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyMULAAs(B * df, B * sf)
    {
       P n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DBdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DBdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DBdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DBdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DBdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, DBdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DBdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DBdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyDIVAAs(B * df, B * sf)
    {
       P n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DBdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DBdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DBdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DBdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DBdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, DBdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DBdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * s = ((B *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DBdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DBdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DBdyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DBdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DBdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyPWRAAs(B * df, B * sf)
    {
       P n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DBdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DBdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DBdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DBdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DBdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, DBdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyMODASs(df, sf);
#if ENABLE_THREADS
    else DBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DBdyMODSA(B* df, B *sf)
  {
    DBdyMODSAs(df, sf);
  }

    static void DBdyMODAAs(B * df, B * sf)
    {
       P n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DBdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DBdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DBdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DBdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DBdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = HUGE_VAL;
      threads_do(nways, DBdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DBdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; B * s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DBdyTHEARCSA(B* df, B *sf)
  {
    DBdyTHEARCSAs(df, sf);
  }

    static void DBdyTHEARCAAs(B * df, B * sf)
    {
       P n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DBdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  B * s = ((B *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DBdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DBdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DBdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DBdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DWdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DWdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, DWdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyADDASs(df, sf);
#if ENABLE_THREADS
    else DWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DWdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DWdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyADDAAs(B * df, B * sf)
    {
       P n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DWdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DWdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DWdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DWdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DWdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, DWdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdySUBASs(df, sf);
#if ENABLE_THREADS
    else DWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DWdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DWdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdySUBAAs(B * df, B * sf)
    {
       P n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DWdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DWdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DWdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DWdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DWdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, DWdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyMULASs(df, sf);
#if ENABLE_THREADS
    else DWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DWdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DWdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyMULAAs(B * df, B * sf)
    {
       P n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DWdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DWdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DWdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DWdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DWdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, DWdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DWdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DWdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyDIVAAs(B * df, B * sf)
    {
       P n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DWdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DWdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DWdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DWdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DWdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, DWdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DWdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * s = ((W *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DWdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DWdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DWdyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DWdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DWdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyPWRAAs(B * df, B * sf)
    {
       P n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DWdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DWdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DWdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DWdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DWdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, DWdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyMODASs(df, sf);
#if ENABLE_THREADS
    else DWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DWdyMODSA(B* df, B *sf)
  {
    DWdyMODSAs(df, sf);
  }

    static void DWdyMODAAs(B * df, B * sf)
    {
       P n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DWdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DWdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DWdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DWdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DWdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = HUGE_VAL;
      threads_do(nways, DWdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DWdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; W * s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DWdyTHEARCSA(B* df, B *sf)
  {
    DWdyTHEARCSAs(df, sf);
  }

    static void DWdyTHEARCAAs(B * df, B * sf)
    {
       P n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DWdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  W * s = ((W *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DWdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DWdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DWdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DWdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL32dyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DL32dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL32dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL32dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, DL32dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL32dyADDASs(df, sf);
#if ENABLE_THREADS
    else DL32dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL32dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL32dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL32dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL32dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL32dyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL32dyADDSAs(df, sf);
#if ENABLE_THREADS
    else DL32dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL32dyADDAAs(B * df, B * sf)
    {
       P n; L32 * s; D * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL32dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL32dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL32dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL32dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL32dyADDAAs(df,sf);
#if ENABLE_THREADS
      else DL32dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL32dySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DL32dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL32dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL32dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, DL32dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL32dySUBASs(df, sf);
#if ENABLE_THREADS
    else DL32dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL32dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL32dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL32dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL32dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL32dySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL32dySUBSAs(df, sf);
#if ENABLE_THREADS
    else DL32dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL32dySUBAAs(B * df, B * sf)
    {
       P n; L32 * s; D * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL32dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL32dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL32dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL32dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL32dySUBAAs(df,sf);
#if ENABLE_THREADS
      else DL32dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL32dyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DL32dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL32dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL32dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, DL32dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL32dyMULASs(df, sf);
#if ENABLE_THREADS
    else DL32dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL32dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL32dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL32dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL32dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL32dyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL32dyMULSAs(df, sf);
#if ENABLE_THREADS
    else DL32dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL32dyMULAAs(B * df, B * sf)
    {
       P n; L32 * s; D * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL32dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL32dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL32dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL32dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL32dyMULAAs(df,sf);
#if ENABLE_THREADS
      else DL32dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL32dyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DL32dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL32dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL32dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, DL32dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL32dyDIVASs(df, sf);
#if ENABLE_THREADS
    else DL32dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL32dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL32dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL32dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL32dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL32dyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL32dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DL32dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL32dyDIVAAs(B * df, B * sf)
    {
       P n; L32 * s; D * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL32dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL32dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL32dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL32dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL32dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DL32dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL32dyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DL32dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL32dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL32dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, DL32dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL32dyPWRASs(df, sf);
#if ENABLE_THREADS
    else DL32dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL32dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL32dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL32dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL32dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL32dyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL32dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DL32dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL32dyPWRAAs(B * df, B * sf)
    {
       P n; L32 * s; D * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL32dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL32dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL32dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL32dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL32dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DL32dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL32dyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DL32dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL32dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL32dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, DL32dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL32dyMODASs(df, sf);
#if ENABLE_THREADS
    else DL32dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL32dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DL32dyMODSA(B* df, B *sf)
  {
    DL32dyMODSAs(df, sf);
  }

    static void DL32dyMODAAs(B * df, B * sf)
    {
       P n; L32 * s; D * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL32dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL32dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL32dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL32dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL32dyMODAAs(df,sf);
#if ENABLE_THREADS
      else DL32dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL32dyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DL32dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L32 *)NUM_VAL(sf))) == L32INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL32dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL32dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L32 *)NUM_VAL(sf))) == L32INF) data.in = HUGE_VAL;
      threads_do(nways, DL32dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL32dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL32dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DL32dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL32dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L32 * s;
    s = (L32 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DL32dyTHEARCSA(B* df, B *sf)
  {
    DL32dyTHEARCSAs(df, sf);
  }

    static void DL32dyTHEARCAAs(B * df, B * sf)
    {
       P n; L32 * s; D * d;
       D t, tt;
       s = (L32 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL32dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L32 * s = ((L32 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L32 *)s++)) == L32INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL32dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL32dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL32dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL32dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL32dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DL32dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL64dyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DL64dyADDASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL64dyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL64dyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, DL64dyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL64dyADDASs(df, sf);
#if ENABLE_THREADS
    else DL64dyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL64dyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL64dyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL64dyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL64dyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL64dyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL64dyADDSAs(df, sf);
#if ENABLE_THREADS
    else DL64dyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL64dyADDAAs(B * df, B * sf)
    {
       P n; L64 * s; D * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL64dyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL64dyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL64dyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL64dyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL64dyADDAAs(df,sf);
#if ENABLE_THREADS
      else DL64dyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL64dySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DL64dySUBASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL64dySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL64dySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, DL64dySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL64dySUBASs(df, sf);
#if ENABLE_THREADS
    else DL64dySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL64dySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL64dySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL64dySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL64dySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL64dySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL64dySUBSAs(df, sf);
#if ENABLE_THREADS
    else DL64dySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL64dySUBAAs(B * df, B * sf)
    {
       P n; L64 * s; D * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL64dySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL64dySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL64dySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL64dySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL64dySUBAAs(df,sf);
#if ENABLE_THREADS
      else DL64dySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL64dyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DL64dyMULASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL64dyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL64dyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, DL64dyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL64dyMULASs(df, sf);
#if ENABLE_THREADS
    else DL64dyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL64dyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL64dyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL64dyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL64dyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL64dyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL64dyMULSAs(df, sf);
#if ENABLE_THREADS
    else DL64dyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL64dyMULAAs(B * df, B * sf)
    {
       P n; L64 * s; D * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL64dyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL64dyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL64dyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL64dyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL64dyMULAAs(df,sf);
#if ENABLE_THREADS
      else DL64dyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL64dyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DL64dyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL64dyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL64dyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, DL64dyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL64dyDIVASs(df, sf);
#if ENABLE_THREADS
    else DL64dyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL64dyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL64dyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL64dyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL64dyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL64dyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL64dyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DL64dyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL64dyDIVAAs(B * df, B * sf)
    {
       P n; L64 * s; D * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL64dyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL64dyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL64dyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL64dyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL64dyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DL64dyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL64dyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DL64dyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL64dyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL64dyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, DL64dyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL64dyPWRASs(df, sf);
#if ENABLE_THREADS
    else DL64dyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL64dyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DL64dyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DL64dyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DL64dyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DL64dyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DL64dyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DL64dyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DL64dyPWRAAs(B * df, B * sf)
    {
       P n; L64 * s; D * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL64dyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL64dyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL64dyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL64dyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL64dyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DL64dyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL64dyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DL64dyMODASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL64dyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL64dyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, DL64dyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL64dyMODASs(df, sf);
#if ENABLE_THREADS
    else DL64dyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL64dyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = fmod(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DL64dyMODSA(B* df, B *sf)
  {
    DL64dyMODSAs(df, sf);
  }

    static void DL64dyMODAAs(B * df, B * sf)
    {
       P n; L64 * s; D * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL64dyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL64dyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL64dyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL64dyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL64dyMODAAs(df,sf);
#if ENABLE_THREADS
      else DL64dyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DL64dyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DL64dyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L64 *)NUM_VAL(sf))) == L64INF) tt = HUGE_VAL;
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DL64dyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DL64dyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
if ((data.in = *((L64 *)NUM_VAL(sf))) == L64INF) data.in = HUGE_VAL;
      threads_do(nways, DL64dyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DL64dyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DL64dyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DL64dyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DL64dyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; L64 * s;
    s = (L64 *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = thearc(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DL64dyTHEARCSA(B* df, B *sf)
  {
    DL64dyTHEARCSAs(df, sf);
  }

    static void DL64dyTHEARCAAs(B * df, B * sf)
    {
       P n; L64 * s; D * d;
       D t, tt;
       s = (L64 *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DL64dyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  L64 * s = ((L64 *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((tt = *((L64 *)s++)) == L64INF) tt = HUGE_VAL;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DL64dyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DL64dyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DL64dyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DL64dyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DL64dyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DL64dyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DSdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DSdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyADDASs(df, sf);
#if ENABLE_THREADS
    else DSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DSdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DSdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyADDAAs(B * df, B * sf)
    {
       P n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DSdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DSdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DSdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DSdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DSdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdySUBASs(df, sf);
#if ENABLE_THREADS
    else DSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DSdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DSdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdySUBAAs(B * df, B * sf)
    {
       P n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DSdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DSdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DSdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DSdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DSdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyMULASs(df, sf);
#if ENABLE_THREADS
    else DSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DSdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DSdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyMULAAs(B * df, B * sf)
    {
       P n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DSdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DSdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DSdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DSdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DSdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DSdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DSdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyDIVAAs(B * df, B * sf)
    {
       P n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DSdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DSdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DSdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DSdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DSdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DSdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * s = ((S *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DSdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DSdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DSdyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DSdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DSdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyPWRAAs(B * df, B * sf)
    {
       P n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DSdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DSdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DSdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DSdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DSdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyMODASs(df, sf);
#if ENABLE_THREADS
    else DSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DSdyMODSA(B* df, B *sf)
  {
    DSdyMODSAs(df, sf);
  }

    static void DSdyMODAAs(B * df, B * sf)
    {
       P n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DSdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DSdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DSdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DSdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DSdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((S *)NUM_VAL(sf));
      threads_do(nways, DSdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DSdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; S * s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DSdyTHEARCSA(B* df, B *sf)
  {
    DSdyTHEARCSAs(df, sf);
  }

    static void DSdyTHEARCAAs(B * df, B * sf)
    {
       P n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DSdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  S * s = ((S *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DSdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DSdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DSdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DSdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyADDASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DDdyADDASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DDdyADDASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyADDASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyADDASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyADDAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyADDASs(df, sf);
#if ENABLE_THREADS
    else DDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyADDSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DDdyADDSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DDdyADDSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdyADDSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdyADDSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
        tt = *(r++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t += tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyADDSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyADDAAs(B * df, B * sf)
    {
       P n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DDdyADDAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DDdyADDAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyADDAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyADDAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyADDAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DDdyADDAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdySUBASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DDdySUBASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DDdySUBASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdySUBASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdySUBASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdySUBAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdySUBASs(df, sf);
#if ENABLE_THREADS
    else DDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdySUBSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t -= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DDdySUBSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 0, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t += tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DDdySUBSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdySUBSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdySUBSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t -= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
        tt = *(r++);
t -= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t -= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdySUBSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdySUBAAs(B * df, B * sf)
    {
       P n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DDdySUBAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DDdySUBAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdySUBAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdySUBAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdySUBAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DDdySUBAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyMULASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DDdyMULASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DDdyMULASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyMULASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyMULASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyMULAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyMULASs(df, sf);
#if ENABLE_THREADS
    else DDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyMULSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DDdyMULSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DDdyMULSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdyMULSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdyMULSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
        tt = *(r++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t *= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyMULSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyMULAAs(B * df, B * sf)
    {
       P n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DDdyMULAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DDdyMULAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyMULAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyMULAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyMULAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DDdyMULAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyDIVASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DDdyDIVASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
  }

  static void DDdyDIVASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyDIVASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyDIVASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyDIVAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t /= tt;
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DDdyDIVSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DDdyDIVSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdyDIVSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdyDIVSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t /= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
        tt = *(r++);
t /= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t /= tt;
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyDIVSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyDIVAAs(B * df, B * sf)
    {
       P n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DDdyDIVAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}}
  return OK;
    }

    static void DDdyDIVAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyDIVAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyDIVAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyDIVAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DDdyDIVAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyPWRASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DDdyPWRASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DDdyPWRASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyPWRASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyPWRASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyPWRAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static P DDdyPWRSAt(UP id, const void* indata,
                                          void* outdata)
 {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * s = ((D *) data->sf_start)+data->perthread*id;
     D * ret = (D*) outdata;
     D t = 1, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t *= tt;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}}
     *ret = t;
  return OK;
  }
    
  static void DDdyPWRSAc(B* df, B* sf)
  {
  if (ARRAY_SIZE(sf) < THREADMUL*8)
    DDdyPWRSAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(sf)/(THREADMUL*8)
               + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(sf) / nways;
    data.leftover = ARRAY_SIZE(sf) % nways; 
   data.sf_start = VALUE_PTR(sf);
    {
      UP n, n_ = nways;
      D t,tt, ret[THREADNUM];
      D* r = ret;
      threads_do_local(nways, DDdyPWRSAt, &data, ret);
      
t = *((D *)NUM_VAL(df));
{ UP n__ = (UP)r % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*r))) {
        handleerr();
        return;
      }
      n__ /= sizeof(*r);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
        tt = *(r++);
t = pow(t,tt);
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
        tt = *(r++);
t = pow(t,tt);
}
for (n = ((n_-n__) & 7); n>0; n--) {
        tt = *(r++);
t = pow(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyPWRSA(B* df, B *sf)
  {
    if (thread_num() == 1 || serialized)
      DDdyPWRSAs(df, sf);
#if ENABLE_THREADS
    else DDdyPWRSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyPWRAAs(B * df, B * sf)
    {
       P n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DDdyPWRAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DDdyPWRAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyPWRAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyPWRAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyPWRAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DDdyPWRAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyMODASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DDdyMODASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DDdyMODASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyMODASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyMODASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyMODAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyMODASs(df, sf);
#if ENABLE_THREADS
    else DDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyMODSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DDdyMODSA(B* df, B *sf)
  {
    DDdyMODSAs(df, sf);
  }

    static void DDdyMODAAs(B * df, B * sf)
    {
       P n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DDdyMODAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DDdyMODAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyMODAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyMODAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyMODAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DDdyMODAAc(df,sf);
#endif //ENABLE_THREADS
    }

static void DDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; P n; D * d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  }

#if ENABLE_THREADS
  static P DDdyTHEARCASt(UP id, const void* indata,
                                           void* ignore
                                           __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t, tt = data->in;
      
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
  }

  static void DDdyTHEARCASc(B* df, B *sf)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyTHEARCASs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
data.in = *((D *)NUM_VAL(sf));
      threads_do(nways, DDdyTHEARCASt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DDdyTHEARCAS(B *df, B *sf)
  {
    if (thread_num() == 1)
    DDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; P n; D * s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
{ UP n__ = VALUE_BASE(sf) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(sf))
            n__ = ARRAY_SIZE(sf);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
}
for (n = ((ARRAY_SIZE(sf)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = ((ARRAY_SIZE(sf)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}}
*((D *)NUM_VAL(df)) = t;
   }

  static void DDdyTHEARCSA(B* df, B *sf)
  {
    DDdyTHEARCSAs(df, sf);
  }

    static void DDdyTHEARCAAs(B * df, B * sf)
    {
       P n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
    }


#if ENABLE_THREADS
    static P DDdyTHEARCAAt(UP id, const void* indata,
                                             void* ignore
                                             __attribute__ ((__unused__)))
    {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
  D * s = ((D *) data->sf_start)+data->perthread*id;
        D t, tt;
{ UP n__ = (UP)s % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*s))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*s);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}}
  return OK;
    }

    static void DDdyTHEARCAAc(B* df, B* sf)
    {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DDdyTHEARCAAs(df, sf);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
   data.sf_start = VALUE_PTR(sf);
    {
         threads_do(nways, DDdyTHEARCAAt, &data);
    }
  }
    }
#endif //ENABLE_THREADS

    static void DDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized || thread_num() == 1) DDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DDdyTHEARCAAc(df,sf);
#endif //ENABLE_THREADS
    }

typedef void (*dyadic_fct)(B*,B*);
static dyadic_fct ADDlist[] = {
BBdyADDSS, BBdyADDAS, BBdyADDSA, BBdyADDAA, 
BWdyADDSS, BWdyADDAS, BWdyADDSA, BWdyADDAA, 
BL32dyADDSS, BL32dyADDAS, BL32dyADDSA, BL32dyADDAA, 
BL64dyADDSS, BL64dyADDAS, BL64dyADDSA, BL64dyADDAA, 
BSdyADDSS, BSdyADDAS, BSdyADDSA, BSdyADDAA, 
BDdyADDSS, BDdyADDAS, BDdyADDSA, BDdyADDAA, 
WBdyADDSS, WBdyADDAS, WBdyADDSA, WBdyADDAA, 
WWdyADDSS, WWdyADDAS, WWdyADDSA, WWdyADDAA, 
WL32dyADDSS, WL32dyADDAS, WL32dyADDSA, WL32dyADDAA, 
WL64dyADDSS, WL64dyADDAS, WL64dyADDSA, WL64dyADDAA, 
WSdyADDSS, WSdyADDAS, WSdyADDSA, WSdyADDAA, 
WDdyADDSS, WDdyADDAS, WDdyADDSA, WDdyADDAA, 
L32BdyADDSS, L32BdyADDAS, L32BdyADDSA, L32BdyADDAA, 
L32WdyADDSS, L32WdyADDAS, L32WdyADDSA, L32WdyADDAA, 
L32L32dyADDSS, L32L32dyADDAS, L32L32dyADDSA, L32L32dyADDAA, 
L32L64dyADDSS, L32L64dyADDAS, L32L64dyADDSA, L32L64dyADDAA, 
L32SdyADDSS, L32SdyADDAS, L32SdyADDSA, L32SdyADDAA, 
L32DdyADDSS, L32DdyADDAS, L32DdyADDSA, L32DdyADDAA, 
L64BdyADDSS, L64BdyADDAS, L64BdyADDSA, L64BdyADDAA, 
L64WdyADDSS, L64WdyADDAS, L64WdyADDSA, L64WdyADDAA, 
L64L32dyADDSS, L64L32dyADDAS, L64L32dyADDSA, L64L32dyADDAA, 
L64L64dyADDSS, L64L64dyADDAS, L64L64dyADDSA, L64L64dyADDAA, 
L64SdyADDSS, L64SdyADDAS, L64SdyADDSA, L64SdyADDAA, 
L64DdyADDSS, L64DdyADDAS, L64DdyADDSA, L64DdyADDAA, 
SBdyADDSS, SBdyADDAS, SBdyADDSA, SBdyADDAA, 
SWdyADDSS, SWdyADDAS, SWdyADDSA, SWdyADDAA, 
SL32dyADDSS, SL32dyADDAS, SL32dyADDSA, SL32dyADDAA, 
SL64dyADDSS, SL64dyADDAS, SL64dyADDSA, SL64dyADDAA, 
SSdyADDSS, SSdyADDAS, SSdyADDSA, SSdyADDAA, 
SDdyADDSS, SDdyADDAS, SDdyADDSA, SDdyADDAA, 
DBdyADDSS, DBdyADDAS, DBdyADDSA, DBdyADDAA, 
DWdyADDSS, DWdyADDAS, DWdyADDSA, DWdyADDAA, 
DL32dyADDSS, DL32dyADDAS, DL32dyADDSA, DL32dyADDAA, 
DL64dyADDSS, DL64dyADDAS, DL64dyADDSA, DL64dyADDAA, 
DSdyADDSS, DSdyADDAS, DSdyADDSA, DSdyADDAA, 
DDdyADDSS, DDdyADDAS, DDdyADDSA, DDdyADDAA, 

};
static dyadic_fct SUBlist[] = {
BBdySUBSS, BBdySUBAS, BBdySUBSA, BBdySUBAA, 
BWdySUBSS, BWdySUBAS, BWdySUBSA, BWdySUBAA, 
BL32dySUBSS, BL32dySUBAS, BL32dySUBSA, BL32dySUBAA, 
BL64dySUBSS, BL64dySUBAS, BL64dySUBSA, BL64dySUBAA, 
BSdySUBSS, BSdySUBAS, BSdySUBSA, BSdySUBAA, 
BDdySUBSS, BDdySUBAS, BDdySUBSA, BDdySUBAA, 
WBdySUBSS, WBdySUBAS, WBdySUBSA, WBdySUBAA, 
WWdySUBSS, WWdySUBAS, WWdySUBSA, WWdySUBAA, 
WL32dySUBSS, WL32dySUBAS, WL32dySUBSA, WL32dySUBAA, 
WL64dySUBSS, WL64dySUBAS, WL64dySUBSA, WL64dySUBAA, 
WSdySUBSS, WSdySUBAS, WSdySUBSA, WSdySUBAA, 
WDdySUBSS, WDdySUBAS, WDdySUBSA, WDdySUBAA, 
L32BdySUBSS, L32BdySUBAS, L32BdySUBSA, L32BdySUBAA, 
L32WdySUBSS, L32WdySUBAS, L32WdySUBSA, L32WdySUBAA, 
L32L32dySUBSS, L32L32dySUBAS, L32L32dySUBSA, L32L32dySUBAA, 
L32L64dySUBSS, L32L64dySUBAS, L32L64dySUBSA, L32L64dySUBAA, 
L32SdySUBSS, L32SdySUBAS, L32SdySUBSA, L32SdySUBAA, 
L32DdySUBSS, L32DdySUBAS, L32DdySUBSA, L32DdySUBAA, 
L64BdySUBSS, L64BdySUBAS, L64BdySUBSA, L64BdySUBAA, 
L64WdySUBSS, L64WdySUBAS, L64WdySUBSA, L64WdySUBAA, 
L64L32dySUBSS, L64L32dySUBAS, L64L32dySUBSA, L64L32dySUBAA, 
L64L64dySUBSS, L64L64dySUBAS, L64L64dySUBSA, L64L64dySUBAA, 
L64SdySUBSS, L64SdySUBAS, L64SdySUBSA, L64SdySUBAA, 
L64DdySUBSS, L64DdySUBAS, L64DdySUBSA, L64DdySUBAA, 
SBdySUBSS, SBdySUBAS, SBdySUBSA, SBdySUBAA, 
SWdySUBSS, SWdySUBAS, SWdySUBSA, SWdySUBAA, 
SL32dySUBSS, SL32dySUBAS, SL32dySUBSA, SL32dySUBAA, 
SL64dySUBSS, SL64dySUBAS, SL64dySUBSA, SL64dySUBAA, 
SSdySUBSS, SSdySUBAS, SSdySUBSA, SSdySUBAA, 
SDdySUBSS, SDdySUBAS, SDdySUBSA, SDdySUBAA, 
DBdySUBSS, DBdySUBAS, DBdySUBSA, DBdySUBAA, 
DWdySUBSS, DWdySUBAS, DWdySUBSA, DWdySUBAA, 
DL32dySUBSS, DL32dySUBAS, DL32dySUBSA, DL32dySUBAA, 
DL64dySUBSS, DL64dySUBAS, DL64dySUBSA, DL64dySUBAA, 
DSdySUBSS, DSdySUBAS, DSdySUBSA, DSdySUBAA, 
DDdySUBSS, DDdySUBAS, DDdySUBSA, DDdySUBAA, 

};
static dyadic_fct MULlist[] = {
BBdyMULSS, BBdyMULAS, BBdyMULSA, BBdyMULAA, 
BWdyMULSS, BWdyMULAS, BWdyMULSA, BWdyMULAA, 
BL32dyMULSS, BL32dyMULAS, BL32dyMULSA, BL32dyMULAA, 
BL64dyMULSS, BL64dyMULAS, BL64dyMULSA, BL64dyMULAA, 
BSdyMULSS, BSdyMULAS, BSdyMULSA, BSdyMULAA, 
BDdyMULSS, BDdyMULAS, BDdyMULSA, BDdyMULAA, 
WBdyMULSS, WBdyMULAS, WBdyMULSA, WBdyMULAA, 
WWdyMULSS, WWdyMULAS, WWdyMULSA, WWdyMULAA, 
WL32dyMULSS, WL32dyMULAS, WL32dyMULSA, WL32dyMULAA, 
WL64dyMULSS, WL64dyMULAS, WL64dyMULSA, WL64dyMULAA, 
WSdyMULSS, WSdyMULAS, WSdyMULSA, WSdyMULAA, 
WDdyMULSS, WDdyMULAS, WDdyMULSA, WDdyMULAA, 
L32BdyMULSS, L32BdyMULAS, L32BdyMULSA, L32BdyMULAA, 
L32WdyMULSS, L32WdyMULAS, L32WdyMULSA, L32WdyMULAA, 
L32L32dyMULSS, L32L32dyMULAS, L32L32dyMULSA, L32L32dyMULAA, 
L32L64dyMULSS, L32L64dyMULAS, L32L64dyMULSA, L32L64dyMULAA, 
L32SdyMULSS, L32SdyMULAS, L32SdyMULSA, L32SdyMULAA, 
L32DdyMULSS, L32DdyMULAS, L32DdyMULSA, L32DdyMULAA, 
L64BdyMULSS, L64BdyMULAS, L64BdyMULSA, L64BdyMULAA, 
L64WdyMULSS, L64WdyMULAS, L64WdyMULSA, L64WdyMULAA, 
L64L32dyMULSS, L64L32dyMULAS, L64L32dyMULSA, L64L32dyMULAA, 
L64L64dyMULSS, L64L64dyMULAS, L64L64dyMULSA, L64L64dyMULAA, 
L64SdyMULSS, L64SdyMULAS, L64SdyMULSA, L64SdyMULAA, 
L64DdyMULSS, L64DdyMULAS, L64DdyMULSA, L64DdyMULAA, 
SBdyMULSS, SBdyMULAS, SBdyMULSA, SBdyMULAA, 
SWdyMULSS, SWdyMULAS, SWdyMULSA, SWdyMULAA, 
SL32dyMULSS, SL32dyMULAS, SL32dyMULSA, SL32dyMULAA, 
SL64dyMULSS, SL64dyMULAS, SL64dyMULSA, SL64dyMULAA, 
SSdyMULSS, SSdyMULAS, SSdyMULSA, SSdyMULAA, 
SDdyMULSS, SDdyMULAS, SDdyMULSA, SDdyMULAA, 
DBdyMULSS, DBdyMULAS, DBdyMULSA, DBdyMULAA, 
DWdyMULSS, DWdyMULAS, DWdyMULSA, DWdyMULAA, 
DL32dyMULSS, DL32dyMULAS, DL32dyMULSA, DL32dyMULAA, 
DL64dyMULSS, DL64dyMULAS, DL64dyMULSA, DL64dyMULAA, 
DSdyMULSS, DSdyMULAS, DSdyMULSA, DSdyMULAA, 
DDdyMULSS, DDdyMULAS, DDdyMULSA, DDdyMULAA, 

};
static dyadic_fct DIVlist[] = {
BBdyDIVSS, BBdyDIVAS, BBdyDIVSA, BBdyDIVAA, 
BWdyDIVSS, BWdyDIVAS, BWdyDIVSA, BWdyDIVAA, 
BL32dyDIVSS, BL32dyDIVAS, BL32dyDIVSA, BL32dyDIVAA, 
BL64dyDIVSS, BL64dyDIVAS, BL64dyDIVSA, BL64dyDIVAA, 
BSdyDIVSS, BSdyDIVAS, BSdyDIVSA, BSdyDIVAA, 
BDdyDIVSS, BDdyDIVAS, BDdyDIVSA, BDdyDIVAA, 
WBdyDIVSS, WBdyDIVAS, WBdyDIVSA, WBdyDIVAA, 
WWdyDIVSS, WWdyDIVAS, WWdyDIVSA, WWdyDIVAA, 
WL32dyDIVSS, WL32dyDIVAS, WL32dyDIVSA, WL32dyDIVAA, 
WL64dyDIVSS, WL64dyDIVAS, WL64dyDIVSA, WL64dyDIVAA, 
WSdyDIVSS, WSdyDIVAS, WSdyDIVSA, WSdyDIVAA, 
WDdyDIVSS, WDdyDIVAS, WDdyDIVSA, WDdyDIVAA, 
L32BdyDIVSS, L32BdyDIVAS, L32BdyDIVSA, L32BdyDIVAA, 
L32WdyDIVSS, L32WdyDIVAS, L32WdyDIVSA, L32WdyDIVAA, 
L32L32dyDIVSS, L32L32dyDIVAS, L32L32dyDIVSA, L32L32dyDIVAA, 
L32L64dyDIVSS, L32L64dyDIVAS, L32L64dyDIVSA, L32L64dyDIVAA, 
L32SdyDIVSS, L32SdyDIVAS, L32SdyDIVSA, L32SdyDIVAA, 
L32DdyDIVSS, L32DdyDIVAS, L32DdyDIVSA, L32DdyDIVAA, 
L64BdyDIVSS, L64BdyDIVAS, L64BdyDIVSA, L64BdyDIVAA, 
L64WdyDIVSS, L64WdyDIVAS, L64WdyDIVSA, L64WdyDIVAA, 
L64L32dyDIVSS, L64L32dyDIVAS, L64L32dyDIVSA, L64L32dyDIVAA, 
L64L64dyDIVSS, L64L64dyDIVAS, L64L64dyDIVSA, L64L64dyDIVAA, 
L64SdyDIVSS, L64SdyDIVAS, L64SdyDIVSA, L64SdyDIVAA, 
L64DdyDIVSS, L64DdyDIVAS, L64DdyDIVSA, L64DdyDIVAA, 
SBdyDIVSS, SBdyDIVAS, SBdyDIVSA, SBdyDIVAA, 
SWdyDIVSS, SWdyDIVAS, SWdyDIVSA, SWdyDIVAA, 
SL32dyDIVSS, SL32dyDIVAS, SL32dyDIVSA, SL32dyDIVAA, 
SL64dyDIVSS, SL64dyDIVAS, SL64dyDIVSA, SL64dyDIVAA, 
SSdyDIVSS, SSdyDIVAS, SSdyDIVSA, SSdyDIVAA, 
SDdyDIVSS, SDdyDIVAS, SDdyDIVSA, SDdyDIVAA, 
DBdyDIVSS, DBdyDIVAS, DBdyDIVSA, DBdyDIVAA, 
DWdyDIVSS, DWdyDIVAS, DWdyDIVSA, DWdyDIVAA, 
DL32dyDIVSS, DL32dyDIVAS, DL32dyDIVSA, DL32dyDIVAA, 
DL64dyDIVSS, DL64dyDIVAS, DL64dyDIVSA, DL64dyDIVAA, 
DSdyDIVSS, DSdyDIVAS, DSdyDIVSA, DSdyDIVAA, 
DDdyDIVSS, DDdyDIVAS, DDdyDIVSA, DDdyDIVAA, 

};
static dyadic_fct PWRlist[] = {
BBdyPWRSS, BBdyPWRAS, BBdyPWRSA, BBdyPWRAA, 
BWdyPWRSS, BWdyPWRAS, BWdyPWRSA, BWdyPWRAA, 
BL32dyPWRSS, BL32dyPWRAS, BL32dyPWRSA, BL32dyPWRAA, 
BL64dyPWRSS, BL64dyPWRAS, BL64dyPWRSA, BL64dyPWRAA, 
BSdyPWRSS, BSdyPWRAS, BSdyPWRSA, BSdyPWRAA, 
BDdyPWRSS, BDdyPWRAS, BDdyPWRSA, BDdyPWRAA, 
WBdyPWRSS, WBdyPWRAS, WBdyPWRSA, WBdyPWRAA, 
WWdyPWRSS, WWdyPWRAS, WWdyPWRSA, WWdyPWRAA, 
WL32dyPWRSS, WL32dyPWRAS, WL32dyPWRSA, WL32dyPWRAA, 
WL64dyPWRSS, WL64dyPWRAS, WL64dyPWRSA, WL64dyPWRAA, 
WSdyPWRSS, WSdyPWRAS, WSdyPWRSA, WSdyPWRAA, 
WDdyPWRSS, WDdyPWRAS, WDdyPWRSA, WDdyPWRAA, 
L32BdyPWRSS, L32BdyPWRAS, L32BdyPWRSA, L32BdyPWRAA, 
L32WdyPWRSS, L32WdyPWRAS, L32WdyPWRSA, L32WdyPWRAA, 
L32L32dyPWRSS, L32L32dyPWRAS, L32L32dyPWRSA, L32L32dyPWRAA, 
L32L64dyPWRSS, L32L64dyPWRAS, L32L64dyPWRSA, L32L64dyPWRAA, 
L32SdyPWRSS, L32SdyPWRAS, L32SdyPWRSA, L32SdyPWRAA, 
L32DdyPWRSS, L32DdyPWRAS, L32DdyPWRSA, L32DdyPWRAA, 
L64BdyPWRSS, L64BdyPWRAS, L64BdyPWRSA, L64BdyPWRAA, 
L64WdyPWRSS, L64WdyPWRAS, L64WdyPWRSA, L64WdyPWRAA, 
L64L32dyPWRSS, L64L32dyPWRAS, L64L32dyPWRSA, L64L32dyPWRAA, 
L64L64dyPWRSS, L64L64dyPWRAS, L64L64dyPWRSA, L64L64dyPWRAA, 
L64SdyPWRSS, L64SdyPWRAS, L64SdyPWRSA, L64SdyPWRAA, 
L64DdyPWRSS, L64DdyPWRAS, L64DdyPWRSA, L64DdyPWRAA, 
SBdyPWRSS, SBdyPWRAS, SBdyPWRSA, SBdyPWRAA, 
SWdyPWRSS, SWdyPWRAS, SWdyPWRSA, SWdyPWRAA, 
SL32dyPWRSS, SL32dyPWRAS, SL32dyPWRSA, SL32dyPWRAA, 
SL64dyPWRSS, SL64dyPWRAS, SL64dyPWRSA, SL64dyPWRAA, 
SSdyPWRSS, SSdyPWRAS, SSdyPWRSA, SSdyPWRAA, 
SDdyPWRSS, SDdyPWRAS, SDdyPWRSA, SDdyPWRAA, 
DBdyPWRSS, DBdyPWRAS, DBdyPWRSA, DBdyPWRAA, 
DWdyPWRSS, DWdyPWRAS, DWdyPWRSA, DWdyPWRAA, 
DL32dyPWRSS, DL32dyPWRAS, DL32dyPWRSA, DL32dyPWRAA, 
DL64dyPWRSS, DL64dyPWRAS, DL64dyPWRSA, DL64dyPWRAA, 
DSdyPWRSS, DSdyPWRAS, DSdyPWRSA, DSdyPWRAA, 
DDdyPWRSS, DDdyPWRAS, DDdyPWRSA, DDdyPWRAA, 

};
static dyadic_fct MODlist[] = {
BBdyMODSS, BBdyMODAS, BBdyMODSA, BBdyMODAA, 
BWdyMODSS, BWdyMODAS, BWdyMODSA, BWdyMODAA, 
BL32dyMODSS, BL32dyMODAS, BL32dyMODSA, BL32dyMODAA, 
BL64dyMODSS, BL64dyMODAS, BL64dyMODSA, BL64dyMODAA, 
BSdyMODSS, BSdyMODAS, BSdyMODSA, BSdyMODAA, 
BDdyMODSS, BDdyMODAS, BDdyMODSA, BDdyMODAA, 
WBdyMODSS, WBdyMODAS, WBdyMODSA, WBdyMODAA, 
WWdyMODSS, WWdyMODAS, WWdyMODSA, WWdyMODAA, 
WL32dyMODSS, WL32dyMODAS, WL32dyMODSA, WL32dyMODAA, 
WL64dyMODSS, WL64dyMODAS, WL64dyMODSA, WL64dyMODAA, 
WSdyMODSS, WSdyMODAS, WSdyMODSA, WSdyMODAA, 
WDdyMODSS, WDdyMODAS, WDdyMODSA, WDdyMODAA, 
L32BdyMODSS, L32BdyMODAS, L32BdyMODSA, L32BdyMODAA, 
L32WdyMODSS, L32WdyMODAS, L32WdyMODSA, L32WdyMODAA, 
L32L32dyMODSS, L32L32dyMODAS, L32L32dyMODSA, L32L32dyMODAA, 
L32L64dyMODSS, L32L64dyMODAS, L32L64dyMODSA, L32L64dyMODAA, 
L32SdyMODSS, L32SdyMODAS, L32SdyMODSA, L32SdyMODAA, 
L32DdyMODSS, L32DdyMODAS, L32DdyMODSA, L32DdyMODAA, 
L64BdyMODSS, L64BdyMODAS, L64BdyMODSA, L64BdyMODAA, 
L64WdyMODSS, L64WdyMODAS, L64WdyMODSA, L64WdyMODAA, 
L64L32dyMODSS, L64L32dyMODAS, L64L32dyMODSA, L64L32dyMODAA, 
L64L64dyMODSS, L64L64dyMODAS, L64L64dyMODSA, L64L64dyMODAA, 
L64SdyMODSS, L64SdyMODAS, L64SdyMODSA, L64SdyMODAA, 
L64DdyMODSS, L64DdyMODAS, L64DdyMODSA, L64DdyMODAA, 
SBdyMODSS, SBdyMODAS, SBdyMODSA, SBdyMODAA, 
SWdyMODSS, SWdyMODAS, SWdyMODSA, SWdyMODAA, 
SL32dyMODSS, SL32dyMODAS, SL32dyMODSA, SL32dyMODAA, 
SL64dyMODSS, SL64dyMODAS, SL64dyMODSA, SL64dyMODAA, 
SSdyMODSS, SSdyMODAS, SSdyMODSA, SSdyMODAA, 
SDdyMODSS, SDdyMODAS, SDdyMODSA, SDdyMODAA, 
DBdyMODSS, DBdyMODAS, DBdyMODSA, DBdyMODAA, 
DWdyMODSS, DWdyMODAS, DWdyMODSA, DWdyMODAA, 
DL32dyMODSS, DL32dyMODAS, DL32dyMODSA, DL32dyMODAA, 
DL64dyMODSS, DL64dyMODAS, DL64dyMODSA, DL64dyMODAA, 
DSdyMODSS, DSdyMODAS, DSdyMODSA, DSdyMODAA, 
DDdyMODSS, DDdyMODAS, DDdyMODSA, DDdyMODAA, 

};
static dyadic_fct THEARClist[] = {
BBdyTHEARCSS, BBdyTHEARCAS, BBdyTHEARCSA, BBdyTHEARCAA, 
BWdyTHEARCSS, BWdyTHEARCAS, BWdyTHEARCSA, BWdyTHEARCAA, 
BL32dyTHEARCSS, BL32dyTHEARCAS, BL32dyTHEARCSA, BL32dyTHEARCAA, 
BL64dyTHEARCSS, BL64dyTHEARCAS, BL64dyTHEARCSA, BL64dyTHEARCAA, 
BSdyTHEARCSS, BSdyTHEARCAS, BSdyTHEARCSA, BSdyTHEARCAA, 
BDdyTHEARCSS, BDdyTHEARCAS, BDdyTHEARCSA, BDdyTHEARCAA, 
WBdyTHEARCSS, WBdyTHEARCAS, WBdyTHEARCSA, WBdyTHEARCAA, 
WWdyTHEARCSS, WWdyTHEARCAS, WWdyTHEARCSA, WWdyTHEARCAA, 
WL32dyTHEARCSS, WL32dyTHEARCAS, WL32dyTHEARCSA, WL32dyTHEARCAA, 
WL64dyTHEARCSS, WL64dyTHEARCAS, WL64dyTHEARCSA, WL64dyTHEARCAA, 
WSdyTHEARCSS, WSdyTHEARCAS, WSdyTHEARCSA, WSdyTHEARCAA, 
WDdyTHEARCSS, WDdyTHEARCAS, WDdyTHEARCSA, WDdyTHEARCAA, 
L32BdyTHEARCSS, L32BdyTHEARCAS, L32BdyTHEARCSA, L32BdyTHEARCAA, 
L32WdyTHEARCSS, L32WdyTHEARCAS, L32WdyTHEARCSA, L32WdyTHEARCAA, 
L32L32dyTHEARCSS, L32L32dyTHEARCAS, L32L32dyTHEARCSA, L32L32dyTHEARCAA, 
L32L64dyTHEARCSS, L32L64dyTHEARCAS, L32L64dyTHEARCSA, L32L64dyTHEARCAA, 
L32SdyTHEARCSS, L32SdyTHEARCAS, L32SdyTHEARCSA, L32SdyTHEARCAA, 
L32DdyTHEARCSS, L32DdyTHEARCAS, L32DdyTHEARCSA, L32DdyTHEARCAA, 
L64BdyTHEARCSS, L64BdyTHEARCAS, L64BdyTHEARCSA, L64BdyTHEARCAA, 
L64WdyTHEARCSS, L64WdyTHEARCAS, L64WdyTHEARCSA, L64WdyTHEARCAA, 
L64L32dyTHEARCSS, L64L32dyTHEARCAS, L64L32dyTHEARCSA, L64L32dyTHEARCAA, 
L64L64dyTHEARCSS, L64L64dyTHEARCAS, L64L64dyTHEARCSA, L64L64dyTHEARCAA, 
L64SdyTHEARCSS, L64SdyTHEARCAS, L64SdyTHEARCSA, L64SdyTHEARCAA, 
L64DdyTHEARCSS, L64DdyTHEARCAS, L64DdyTHEARCSA, L64DdyTHEARCAA, 
SBdyTHEARCSS, SBdyTHEARCAS, SBdyTHEARCSA, SBdyTHEARCAA, 
SWdyTHEARCSS, SWdyTHEARCAS, SWdyTHEARCSA, SWdyTHEARCAA, 
SL32dyTHEARCSS, SL32dyTHEARCAS, SL32dyTHEARCSA, SL32dyTHEARCAA, 
SL64dyTHEARCSS, SL64dyTHEARCAS, SL64dyTHEARCSA, SL64dyTHEARCAA, 
SSdyTHEARCSS, SSdyTHEARCAS, SSdyTHEARCSA, SSdyTHEARCAA, 
SDdyTHEARCSS, SDdyTHEARCAS, SDdyTHEARCSA, SDdyTHEARCAA, 
DBdyTHEARCSS, DBdyTHEARCAS, DBdyTHEARCSA, DBdyTHEARCAA, 
DWdyTHEARCSS, DWdyTHEARCAS, DWdyTHEARCSA, DWdyTHEARCAA, 
DL32dyTHEARCSS, DL32dyTHEARCAS, DL32dyTHEARCSA, DL32dyTHEARCAA, 
DL64dyTHEARCSS, DL64dyTHEARCAS, DL64dyTHEARCSA, DL64dyTHEARCAA, 
DSdyTHEARCSS, DSdyTHEARCAS, DSdyTHEARCSA, DSdyTHEARCAA, 
DDdyTHEARCSS, DDdyTHEARCAS, DDdyTHEARCSA, DDdyTHEARCAA, 

};

static void BmoNEGS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = -t;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoNEGAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoNEGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoNEGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoNEGA(B *df)
  {
    if (thread_num() == 1) BmoNEGAs(df);
#if ENABLE_THREADS
    else BmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void BmoABSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoABSAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoABSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoABSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoABSA(B *df)
  {
    if (thread_num() == 1) BmoABSAs(df);
#if ENABLE_THREADS
    else BmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void BmoSQRTS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoSQRTAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoSQRTAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoSQRTAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoSQRTA(B *df)
  {
    if (thread_num() == 1) BmoSQRTAs(df);
#if ENABLE_THREADS
    else BmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void BmoEXPS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoEXPAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoEXPAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoEXPAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoEXPA(B *df)
  {
    if (thread_num() == 1) BmoEXPAs(df);
#if ENABLE_THREADS
    else BmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void BmoLNS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoLNAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoLNAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoLNAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoLNA(B *df)
  {
    if (thread_num() == 1) BmoLNAs(df);
#if ENABLE_THREADS
    else BmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void BmoLGS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoLGAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoLGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoLGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoLGA(B *df)
  {
    if (thread_num() == 1) BmoLGAs(df);
#if ENABLE_THREADS
    else BmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void BmoFLOORS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoFLOORAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoFLOORAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoFLOORAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoFLOORA(B *df)
  {
    if (thread_num() == 1) BmoFLOORAs(df);
#if ENABLE_THREADS
    else BmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void BmoCEILS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoCEILAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoCEILAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoCEILAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoCEILA(B *df)
  {
    if (thread_num() == 1) BmoCEILAs(df);
#if ENABLE_THREADS
    else BmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void BmoSINS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoSINAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoSINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoSINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoSINA(B *df)
  {
    if (thread_num() == 1) BmoSINAs(df);
#if ENABLE_THREADS
    else BmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void BmoCOSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoCOSAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoCOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoCOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoCOSA(B *df)
  {
    if (thread_num() == 1) BmoCOSAs(df);
#if ENABLE_THREADS
    else BmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void BmoTANS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoTANAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoTANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoTANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoTANA(B *df)
  {
    if (thread_num() == 1) BmoTANAs(df);
#if ENABLE_THREADS
    else BmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void BmoASINS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoASINAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoASINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoASINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoASINA(B *df)
  {
    if (thread_num() == 1) BmoASINAs(df);
#if ENABLE_THREADS
    else BmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void BmoACOSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoACOSAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoACOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoACOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoACOSA(B *df)
  {
    if (thread_num() == 1) BmoACOSAs(df);
#if ENABLE_THREADS
    else BmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void BmoATANS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

   static void BmoATANAs(B *df)
   {
     D t; B *d; P n;
     d = (B *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(B))) {
            handleerr();
            return;
          }
          n__ /= sizeof(B);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
   }

#if ENABLE_THREADS
  static P BmoATANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  B * d = ((B *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = HUGE_VAL;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}}
  return OK;
  }
    
  static void BmoATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    BmoATANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, BmoATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void BmoATANA(B *df)
  {
    if (thread_num() == 1) BmoATANAs(df);
#if ENABLE_THREADS
    else BmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void WmoNEGS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = -t;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoNEGAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoNEGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoNEGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoNEGA(B *df)
  {
    if (thread_num() == 1) WmoNEGAs(df);
#if ENABLE_THREADS
    else WmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void WmoABSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoABSAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoABSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoABSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoABSA(B *df)
  {
    if (thread_num() == 1) WmoABSAs(df);
#if ENABLE_THREADS
    else WmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void WmoSQRTS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoSQRTAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoSQRTAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoSQRTAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoSQRTA(B *df)
  {
    if (thread_num() == 1) WmoSQRTAs(df);
#if ENABLE_THREADS
    else WmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void WmoEXPS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoEXPAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoEXPAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoEXPAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoEXPA(B *df)
  {
    if (thread_num() == 1) WmoEXPAs(df);
#if ENABLE_THREADS
    else WmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void WmoLNS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoLNAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoLNAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoLNAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoLNA(B *df)
  {
    if (thread_num() == 1) WmoLNAs(df);
#if ENABLE_THREADS
    else WmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void WmoLGS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoLGAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoLGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoLGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoLGA(B *df)
  {
    if (thread_num() == 1) WmoLGAs(df);
#if ENABLE_THREADS
    else WmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void WmoFLOORS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoFLOORAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoFLOORAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoFLOORAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoFLOORA(B *df)
  {
    if (thread_num() == 1) WmoFLOORAs(df);
#if ENABLE_THREADS
    else WmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void WmoCEILS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoCEILAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoCEILAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoCEILAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoCEILA(B *df)
  {
    if (thread_num() == 1) WmoCEILAs(df);
#if ENABLE_THREADS
    else WmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void WmoSINS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoSINAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoSINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoSINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoSINA(B *df)
  {
    if (thread_num() == 1) WmoSINAs(df);
#if ENABLE_THREADS
    else WmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void WmoCOSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoCOSAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoCOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoCOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoCOSA(B *df)
  {
    if (thread_num() == 1) WmoCOSAs(df);
#if ENABLE_THREADS
    else WmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void WmoTANS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoTANAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoTANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoTANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoTANA(B *df)
  {
    if (thread_num() == 1) WmoTANAs(df);
#if ENABLE_THREADS
    else WmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void WmoASINS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoASINAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoASINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoASINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoASINA(B *df)
  {
    if (thread_num() == 1) WmoASINAs(df);
#if ENABLE_THREADS
    else WmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void WmoACOSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoACOSAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoACOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoACOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoACOSA(B *df)
  {
    if (thread_num() == 1) WmoACOSAs(df);
#if ENABLE_THREADS
    else WmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void WmoATANS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

   static void WmoATANAs(B *df)
   {
     D t; W *d; P n;
     d = (W *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(W))) {
            handleerr();
            return;
          }
          n__ /= sizeof(W);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
   }

#if ENABLE_THREADS
  static P WmoATANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  W * d = ((W *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = HUGE_VAL;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}}
  return OK;
  }
    
  static void WmoATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    WmoATANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, WmoATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void WmoATANA(B *df)
  {
    if (thread_num() == 1) WmoATANAs(df);
#if ENABLE_THREADS
    else WmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void L32moNEGS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moNEGAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moNEGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = -t;
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moNEGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moNEGA(B *df)
  {
    if (thread_num() == 1) L32moNEGAs(df);
#if ENABLE_THREADS
    else L32moNEGAc(df);
#endif //ENABLE_THREADS
  }

static void L32moABSS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moABSAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moABSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = fabs(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moABSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moABSA(B *df)
  {
    if (thread_num() == 1) L32moABSAs(df);
#if ENABLE_THREADS
    else L32moABSAc(df);
#endif //ENABLE_THREADS
  }

static void L32moSQRTS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moSQRTAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moSQRTAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sqrt(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moSQRTAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moSQRTA(B *df)
  {
    if (thread_num() == 1) L32moSQRTAs(df);
#if ENABLE_THREADS
    else L32moSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void L32moEXPS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moEXPAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moEXPAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = exp(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moEXPAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moEXPA(B *df)
  {
    if (thread_num() == 1) L32moEXPAs(df);
#if ENABLE_THREADS
    else L32moEXPAc(df);
#endif //ENABLE_THREADS
  }

static void L32moLNS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moLNAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moLNAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moLNAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moLNA(B *df)
  {
    if (thread_num() == 1) L32moLNAs(df);
#if ENABLE_THREADS
    else L32moLNAc(df);
#endif //ENABLE_THREADS
  }

static void L32moLGS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moLGAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moLGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = log10(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moLGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moLGA(B *df)
  {
    if (thread_num() == 1) L32moLGAs(df);
#if ENABLE_THREADS
    else L32moLGAc(df);
#endif //ENABLE_THREADS
  }

static void L32moFLOORS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moFLOORAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moFLOORAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = floor(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moFLOORAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moFLOORA(B *df)
  {
    if (thread_num() == 1) L32moFLOORAs(df);
#if ENABLE_THREADS
    else L32moFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void L32moCEILS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moCEILAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moCEILAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = ceil(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moCEILAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moCEILA(B *df)
  {
    if (thread_num() == 1) L32moCEILAs(df);
#if ENABLE_THREADS
    else L32moCEILAc(df);
#endif //ENABLE_THREADS
  }

static void L32moSINS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moSINAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moSINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = sin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moSINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moSINA(B *df)
  {
    if (thread_num() == 1) L32moSINAs(df);
#if ENABLE_THREADS
    else L32moSINAc(df);
#endif //ENABLE_THREADS
  }

static void L32moCOSS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moCOSAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moCOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = cos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moCOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moCOSA(B *df)
  {
    if (thread_num() == 1) L32moCOSAs(df);
#if ENABLE_THREADS
    else L32moCOSAc(df);
#endif //ENABLE_THREADS
  }

static void L32moTANS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moTANAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moTANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = tan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moTANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moTANA(B *df)
  {
    if (thread_num() == 1) L32moTANAs(df);
#if ENABLE_THREADS
    else L32moTANAc(df);
#endif //ENABLE_THREADS
  }

static void L32moASINS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moASINAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moASINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = asin(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moASINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moASINA(B *df)
  {
    if (thread_num() == 1) L32moASINAs(df);
#if ENABLE_THREADS
    else L32moASINAc(df);
#endif //ENABLE_THREADS
  }

static void L32moACOSS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moACOSAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moACOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = acos(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moACOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moACOSA(B *df)
  {
    if (thread_num() == 1) L32moACOSAs(df);
#if ENABLE_THREADS
    else L32moACOSAc(df);
#endif //ENABLE_THREADS
  }

static void L32moATANS(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

   static void L32moATANAs(B *df)
   {
     D t; L32 *d; P n;
     d = (L32 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L32))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L32);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
   }

#if ENABLE_THREADS
  static P L32moATANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L32 * d = ((L32 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L32 *)d)) == L32INF) t = HUGE_VAL;
t = atan(t);
*((L32 *)d++) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}}
  return OK;
  }
    
  static void L32moATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L32moATANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L32moATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L32moATANA(B *df)
  {
    if (thread_num() == 1) L32moATANAs(df);
#if ENABLE_THREADS
    else L32moATANAc(df);
#endif //ENABLE_THREADS
  }

static void L64moNEGS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moNEGAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moNEGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = -t;
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moNEGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moNEGA(B *df)
  {
    if (thread_num() == 1) L64moNEGAs(df);
#if ENABLE_THREADS
    else L64moNEGAc(df);
#endif //ENABLE_THREADS
  }

static void L64moABSS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moABSAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moABSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = fabs(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moABSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moABSA(B *df)
  {
    if (thread_num() == 1) L64moABSAs(df);
#if ENABLE_THREADS
    else L64moABSAc(df);
#endif //ENABLE_THREADS
  }

static void L64moSQRTS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moSQRTAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moSQRTAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sqrt(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moSQRTAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moSQRTA(B *df)
  {
    if (thread_num() == 1) L64moSQRTAs(df);
#if ENABLE_THREADS
    else L64moSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void L64moEXPS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moEXPAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moEXPAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = exp(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moEXPAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moEXPA(B *df)
  {
    if (thread_num() == 1) L64moEXPAs(df);
#if ENABLE_THREADS
    else L64moEXPAc(df);
#endif //ENABLE_THREADS
  }

static void L64moLNS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moLNAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moLNAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moLNAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moLNA(B *df)
  {
    if (thread_num() == 1) L64moLNAs(df);
#if ENABLE_THREADS
    else L64moLNAc(df);
#endif //ENABLE_THREADS
  }

static void L64moLGS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moLGAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moLGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = log10(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moLGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moLGA(B *df)
  {
    if (thread_num() == 1) L64moLGAs(df);
#if ENABLE_THREADS
    else L64moLGAc(df);
#endif //ENABLE_THREADS
  }

static void L64moFLOORS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moFLOORAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moFLOORAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = floor(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moFLOORAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moFLOORA(B *df)
  {
    if (thread_num() == 1) L64moFLOORAs(df);
#if ENABLE_THREADS
    else L64moFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void L64moCEILS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moCEILAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moCEILAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = ceil(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moCEILAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moCEILA(B *df)
  {
    if (thread_num() == 1) L64moCEILAs(df);
#if ENABLE_THREADS
    else L64moCEILAc(df);
#endif //ENABLE_THREADS
  }

static void L64moSINS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moSINAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moSINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = sin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moSINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moSINA(B *df)
  {
    if (thread_num() == 1) L64moSINAs(df);
#if ENABLE_THREADS
    else L64moSINAc(df);
#endif //ENABLE_THREADS
  }

static void L64moCOSS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moCOSAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moCOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = cos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moCOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moCOSA(B *df)
  {
    if (thread_num() == 1) L64moCOSAs(df);
#if ENABLE_THREADS
    else L64moCOSAc(df);
#endif //ENABLE_THREADS
  }

static void L64moTANS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moTANAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moTANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = tan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moTANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moTANA(B *df)
  {
    if (thread_num() == 1) L64moTANAs(df);
#if ENABLE_THREADS
    else L64moTANAc(df);
#endif //ENABLE_THREADS
  }

static void L64moASINS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moASINAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moASINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = asin(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moASINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moASINA(B *df)
  {
    if (thread_num() == 1) L64moASINAs(df);
#if ENABLE_THREADS
    else L64moASINAc(df);
#endif //ENABLE_THREADS
  }

static void L64moACOSS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moACOSAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moACOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = acos(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moACOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moACOSA(B *df)
  {
    if (thread_num() == 1) L64moACOSAs(df);
#if ENABLE_THREADS
    else L64moACOSAc(df);
#endif //ENABLE_THREADS
  }

static void L64moATANS(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

   static void L64moATANAs(B *df)
   {
     D t; L64 *d; P n;
     d = (L64 *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(L64))) {
            handleerr();
            return;
          }
          n__ /= sizeof(L64);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
   }

#if ENABLE_THREADS
  static P L64moATANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  L64 * d = ((L64 *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
if ((t = *((L64 *)d)) == L64INF) t = HUGE_VAL;
t = atan(t);
*((L64 *)d++) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}}
  return OK;
  }
    
  static void L64moATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    L64moATANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, L64moATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void L64moATANA(B *df)
  {
    if (thread_num() == 1) L64moATANAs(df);
#if ENABLE_THREADS
    else L64moATANAc(df);
#endif //ENABLE_THREADS
  }

static void SmoNEGS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = -t;
*((S *)NUM_VAL(df)) = t;
}

   static void SmoNEGAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoNEGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoNEGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoNEGA(B *df)
  {
    if (thread_num() == 1) SmoNEGAs(df);
#if ENABLE_THREADS
    else SmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void SmoABSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = fabs(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoABSAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoABSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoABSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoABSA(B *df)
  {
    if (thread_num() == 1) SmoABSAs(df);
#if ENABLE_THREADS
    else SmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void SmoSQRTS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = sqrt(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoSQRTAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoSQRTAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoSQRTAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoSQRTA(B *df)
  {
    if (thread_num() == 1) SmoSQRTAs(df);
#if ENABLE_THREADS
    else SmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void SmoEXPS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = exp(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoEXPAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoEXPAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoEXPAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoEXPA(B *df)
  {
    if (thread_num() == 1) SmoEXPAs(df);
#if ENABLE_THREADS
    else SmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void SmoLNS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = log(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoLNAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoLNAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoLNAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoLNA(B *df)
  {
    if (thread_num() == 1) SmoLNAs(df);
#if ENABLE_THREADS
    else SmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void SmoLGS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = log10(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoLGAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoLGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoLGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoLGA(B *df)
  {
    if (thread_num() == 1) SmoLGAs(df);
#if ENABLE_THREADS
    else SmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void SmoFLOORS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = floor(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoFLOORAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoFLOORAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoFLOORAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoFLOORA(B *df)
  {
    if (thread_num() == 1) SmoFLOORAs(df);
#if ENABLE_THREADS
    else SmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void SmoCEILS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = ceil(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoCEILAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoCEILAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoCEILAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoCEILA(B *df)
  {
    if (thread_num() == 1) SmoCEILAs(df);
#if ENABLE_THREADS
    else SmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void SmoSINS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = sin(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoSINAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoSINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoSINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoSINA(B *df)
  {
    if (thread_num() == 1) SmoSINAs(df);
#if ENABLE_THREADS
    else SmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void SmoCOSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = cos(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoCOSAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoCOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoCOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoCOSA(B *df)
  {
    if (thread_num() == 1) SmoCOSAs(df);
#if ENABLE_THREADS
    else SmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void SmoTANS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = tan(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoTANAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoTANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoTANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoTANA(B *df)
  {
    if (thread_num() == 1) SmoTANAs(df);
#if ENABLE_THREADS
    else SmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void SmoASINS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = asin(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoASINAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoASINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoASINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoASINA(B *df)
  {
    if (thread_num() == 1) SmoASINAs(df);
#if ENABLE_THREADS
    else SmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void SmoACOSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = acos(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoACOSAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoACOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoACOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoACOSA(B *df)
  {
    if (thread_num() == 1) SmoACOSAs(df);
#if ENABLE_THREADS
    else SmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void SmoATANS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = atan(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoATANAs(B *df)
   {
     D t; S *d; P n;
     d = (S *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(S))) {
            handleerr();
            return;
          }
          n__ /= sizeof(S);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P SmoATANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  S * d = ((S *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}}
  return OK;
  }
    
  static void SmoATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    SmoATANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, SmoATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void SmoATANA(B *df)
  {
    if (thread_num() == 1) SmoATANAs(df);
#if ENABLE_THREADS
    else SmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void DmoNEGS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = -t;
*((D *)NUM_VAL(df)) = t;
}

   static void DmoNEGAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoNEGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoNEGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoNEGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoNEGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoNEGA(B *df)
  {
    if (thread_num() == 1) DmoNEGAs(df);
#if ENABLE_THREADS
    else DmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void DmoABSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = fabs(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoABSAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoABSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoABSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoABSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoABSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoABSA(B *df)
  {
    if (thread_num() == 1) DmoABSAs(df);
#if ENABLE_THREADS
    else DmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void DmoSQRTS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = sqrt(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoSQRTAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoSQRTAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoSQRTAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoSQRTAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoSQRTAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoSQRTA(B *df)
  {
    if (thread_num() == 1) DmoSQRTAs(df);
#if ENABLE_THREADS
    else DmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void DmoEXPS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = exp(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoEXPAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoEXPAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoEXPAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoEXPAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoEXPAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoEXPA(B *df)
  {
    if (thread_num() == 1) DmoEXPAs(df);
#if ENABLE_THREADS
    else DmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void DmoLNS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = log(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoLNAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoLNAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoLNAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoLNAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoLNAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoLNA(B *df)
  {
    if (thread_num() == 1) DmoLNAs(df);
#if ENABLE_THREADS
    else DmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void DmoLGS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = log10(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoLGAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoLGAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoLGAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoLGAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoLGAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoLGA(B *df)
  {
    if (thread_num() == 1) DmoLGAs(df);
#if ENABLE_THREADS
    else DmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void DmoFLOORS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = floor(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoFLOORAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoFLOORAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoFLOORAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoFLOORAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoFLOORAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoFLOORA(B *df)
  {
    if (thread_num() == 1) DmoFLOORAs(df);
#if ENABLE_THREADS
    else DmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void DmoCEILS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = ceil(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoCEILAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoCEILAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoCEILAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoCEILAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoCEILAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoCEILA(B *df)
  {
    if (thread_num() == 1) DmoCEILAs(df);
#if ENABLE_THREADS
    else DmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void DmoSINS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = sin(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoSINAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoSINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoSINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoSINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoSINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoSINA(B *df)
  {
    if (thread_num() == 1) DmoSINAs(df);
#if ENABLE_THREADS
    else DmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void DmoCOSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = cos(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoCOSAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoCOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoCOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoCOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoCOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoCOSA(B *df)
  {
    if (thread_num() == 1) DmoCOSAs(df);
#if ENABLE_THREADS
    else DmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void DmoTANS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = tan(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoTANAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoTANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoTANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoTANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoTANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoTANA(B *df)
  {
    if (thread_num() == 1) DmoTANAs(df);
#if ENABLE_THREADS
    else DmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void DmoASINS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = asin(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoASINAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoASINAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoASINAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoASINAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoASINAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoASINA(B *df)
  {
    if (thread_num() == 1) DmoASINAs(df);
#if ENABLE_THREADS
    else DmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void DmoACOSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = acos(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoACOSAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoACOSAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoACOSAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoACOSAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoACOSAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoACOSA(B *df)
  {
    if (thread_num() == 1) DmoACOSAs(df);
#if ENABLE_THREADS
    else DmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void DmoATANS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = atan(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoATANAs(B *df)
   {
     D t; D *d; P n;
     d = (D *)VALUE_BASE(df);
{ UP n__ = VALUE_BASE(df) % 8;
        if (n__) {
          n__ = 8 - n__;
          if (DEBUG_DMNUM && (n__ % sizeof(D))) {
            handleerr();
            return;
          }
          n__ /= sizeof(D);
          if (n__ > ARRAY_SIZE(df))
            n__ = ARRAY_SIZE(df);
          for (n = n__; n > 0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
}
for (n = ((ARRAY_SIZE(df)-n__)>>3); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
for (n = ((ARRAY_SIZE(df)-n__)&7); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}}
   }

#if ENABLE_THREADS
  static P DmoATANAt(UP id, const void* indata,
                                     void* ignore
                                     __attribute__ ((__unused__)))
  {
  const thread_array_data* data = (const thread_array_data*) indata;
  UP n, n_ = data->perthread + (thread_max() == id ? data->leftover : 0);
  D * d = ((D *) data->df_start)+data->perthread*id;
      D t;
{ UP n__ = (UP)d % 8;
      if (n__) {
      n__ = 8 - n__;
      if (DEBUG_DMNUM && (n__ % sizeof(*d))) {
        handleerr();
        return BAD_ARR;
      }
      n__ /= sizeof(*d);
      if (n__ > n_) n__ = n_;
      for (n = n__; n > 0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
}
for (n = ((n_-n__) >> 3); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
for (n = ((n_-n__) & 7); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}}
  return OK;
  }
    
  static void DmoATANAc(B * df)
  {
  if (ARRAY_SIZE(df) < THREADMUL*8)
    DmoATANAs(df);
  else {
    thread_array_data data;
    UP nways = ARRAY_SIZE(df)/(THREADMUL*8)
               + (ARRAY_SIZE(df)%(THREADMUL*8) ?
               1 : 0);
    if (nways > thread_num()) nways = thread_num();
    data.perthread = ARRAY_SIZE(df) / nways;
    data.leftover = ARRAY_SIZE(df) % nways; 
   data.df_start = VALUE_PTR(df);
    {
      threads_do(nways, DmoATANAt, &data);
    }
  }
  }
#endif //ENABLE_THREADS

  static void DmoATANA(B *df)
  {
    if (thread_num() == 1) DmoATANAs(df);
#if ENABLE_THREADS
    else DmoATANAc(df);
#endif //ENABLE_THREADS
  }

typedef void (*monadic_fct)(B*);
static monadic_fct NEGlist[] = {
BmoNEGS, BmoNEGA, 
WmoNEGS, WmoNEGA, 
L32moNEGS, L32moNEGA, 
L64moNEGS, L64moNEGA, 
SmoNEGS, SmoNEGA, 
DmoNEGS, DmoNEGA, 

};
static monadic_fct ABSlist[] = {
BmoABSS, BmoABSA, 
WmoABSS, WmoABSA, 
L32moABSS, L32moABSA, 
L64moABSS, L64moABSA, 
SmoABSS, SmoABSA, 
DmoABSS, DmoABSA, 

};
static monadic_fct SQRTlist[] = {
BmoSQRTS, BmoSQRTA, 
WmoSQRTS, WmoSQRTA, 
L32moSQRTS, L32moSQRTA, 
L64moSQRTS, L64moSQRTA, 
SmoSQRTS, SmoSQRTA, 
DmoSQRTS, DmoSQRTA, 

};
static monadic_fct EXPlist[] = {
BmoEXPS, BmoEXPA, 
WmoEXPS, WmoEXPA, 
L32moEXPS, L32moEXPA, 
L64moEXPS, L64moEXPA, 
SmoEXPS, SmoEXPA, 
DmoEXPS, DmoEXPA, 

};
static monadic_fct LNlist[] = {
BmoLNS, BmoLNA, 
WmoLNS, WmoLNA, 
L32moLNS, L32moLNA, 
L64moLNS, L64moLNA, 
SmoLNS, SmoLNA, 
DmoLNS, DmoLNA, 

};
static monadic_fct LGlist[] = {
BmoLGS, BmoLGA, 
WmoLGS, WmoLGA, 
L32moLGS, L32moLGA, 
L64moLGS, L64moLGA, 
SmoLGS, SmoLGA, 
DmoLGS, DmoLGA, 

};
static monadic_fct FLOORlist[] = {
BmoFLOORS, BmoFLOORA, 
WmoFLOORS, WmoFLOORA, 
L32moFLOORS, L32moFLOORA, 
L64moFLOORS, L64moFLOORA, 
SmoFLOORS, SmoFLOORA, 
DmoFLOORS, DmoFLOORA, 

};
static monadic_fct CEILlist[] = {
BmoCEILS, BmoCEILA, 
WmoCEILS, WmoCEILA, 
L32moCEILS, L32moCEILA, 
L64moCEILS, L64moCEILA, 
SmoCEILS, SmoCEILA, 
DmoCEILS, DmoCEILA, 

};
static monadic_fct SINlist[] = {
BmoSINS, BmoSINA, 
WmoSINS, WmoSINA, 
L32moSINS, L32moSINA, 
L64moSINS, L64moSINA, 
SmoSINS, SmoSINA, 
DmoSINS, DmoSINA, 

};
static monadic_fct COSlist[] = {
BmoCOSS, BmoCOSA, 
WmoCOSS, WmoCOSA, 
L32moCOSS, L32moCOSA, 
L64moCOSS, L64moCOSA, 
SmoCOSS, SmoCOSA, 
DmoCOSS, DmoCOSA, 

};
static monadic_fct TANlist[] = {
BmoTANS, BmoTANA, 
WmoTANS, WmoTANA, 
L32moTANS, L32moTANA, 
L64moTANS, L64moTANA, 
SmoTANS, SmoTANA, 
DmoTANS, DmoTANA, 

};
static monadic_fct ASINlist[] = {
BmoASINS, BmoASINA, 
WmoASINS, WmoASINA, 
L32moASINS, L32moASINA, 
L64moASINS, L64moASINA, 
SmoASINS, SmoASINA, 
DmoASINS, DmoASINA, 

};
static monadic_fct ACOSlist[] = {
BmoACOSS, BmoACOSA, 
WmoACOSS, WmoACOSA, 
L32moACOSS, L32moACOSA, 
L64moACOSS, L64moACOSA, 
SmoACOSS, SmoACOSA, 
DmoACOSS, DmoACOSA, 

};
static monadic_fct ATANlist[] = {
BmoATANS, BmoATANA, 
WmoATANS, WmoATANA, 
L32moATANS, L32moATANA, 
L64moATANS, L64moATANA, 
SmoATANS, SmoATANA, 
DmoATANS, DmoATANA, 

};
static void Bdecr(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = HUGE_VAL;
t -= 1.0;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((t) < -BMAX) || ISUNDEF(t))? BINF : t;
}

static void Wdecr(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = HUGE_VAL;
t -= 1.0;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((t) < -WMAX) || ISUNDEF(t))? WINF : t;
}

static void L32decr(B *df)
{
D t;
if ((t = *((L32 *)NUM_VAL(df))) == L32INF) t = HUGE_VAL;
t -= 1.0;
*((L32 *)NUM_VAL(df)) = (((t) > L32MAX) || ((t) < -L32MAX) || ISUNDEF(t))? L32INF : t;
}

static void L64decr(B *df)
{
D t;
if ((t = *((L64 *)NUM_VAL(df))) == L64INF) t = HUGE_VAL;
t -= 1.0;
*((L64 *)NUM_VAL(df)) = (((t) > L64MAX) || ((t) < -L64MAX) || ISUNDEF(t))? L64INF : t;
}

static void Sdecr(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t -= 1.0;
*((S *)NUM_VAL(df)) = t;
}

static void Ddecr(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t -= 1.0;
*((D *)NUM_VAL(df)) = t;
}

typedef void (*DECR_fct)(B*);
static DECR_fct DECRlist[] = {
Bdecr, Wdecr, L32decr, L64decr, Sdecr, Ddecr, 
};
