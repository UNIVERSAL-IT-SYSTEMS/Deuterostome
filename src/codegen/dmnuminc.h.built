

static void DBencode(D t, B *dp)
{
*((B *)dp) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
static void DWencode(D t, B *dp)
{
*((W *)dp) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
static void DLencode(D t, B *dp)
{
*((L *)dp) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
static void DSencode(D t, B *dp)
{
*((S *)dp) = t;
}
static void DDencode(D t, B *dp)
{
*((D *)dp) = t;
}
typedef void (*ENCODEfct)(D,B*);
static ENCODEfct ENCODElist[] = {
DBencode, 
DWencode, 
DLencode, 
DSencode, 
DDencode, 
};

static L BLvalue(B *sp)
{
D t; L tc;
if ((t = *((B *)sp)) == BINF) t = DINF;
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L WLvalue(B *sp)
{
D t; L tc;
if ((t = *((W *)sp)) == WINF) t = DINF;
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L LLvalue(B *sp)
{
D t; L tc;
if ((t = *((L *)sp)) == LINF) t = DINF;
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L SLvalue(B *sp)
{
D t; L tc;
t = *((S *)sp);
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L DLvalue(B *sp)
{
D t; L tc;
t = *((D *)sp);
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
typedef L (*VALUEfct)(B*);
static VALUEfct VALUElist[] = {
BLvalue, 
WLvalue, 
LLvalue, 
SLvalue, 
DLvalue, 
};

static D BDtest(B *sp)
{
D t;
if ((t = *((B *)sp)) == BINF) t = DINF;
return(t);
}
static D WDtest(B *sp)
{
D t;
if ((t = *((W *)sp)) == WINF) t = DINF;
return(t);
}
static D LDtest(B *sp)
{
D t;
if ((t = *((L *)sp)) == LINF) t = DINF;
return(t);
}
static D SDtest(B *sp)
{
D t;
t = *((S *)sp);
return(t);
}
static D DDtest(B *sp)
{
D t;
t = *((D *)sp);
return(t);
}
typedef D (*TESTfct)(B*);
static TESTfct TESTlist[] = {
BDtest, 
WDtest, 
LDtest, 
SDtest, 
DDtest, 
};

static void BBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BBmoveSA(B *sf, B *df)
{
D t; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BBmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; B * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; B * d;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if THREADS_ENABLED
    static L BBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void BBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void BBmoveAA(B *sf, B *df)
   {
    if (serialized) BBmoveAAs(sf,df);
#if THREADS_ENABLED
    else BBmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else BBmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void BWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void BWmoveSA(B *sf, B *df)
{
D t; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void BWmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void BWmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; W * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void BWmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; W * d;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if THREADS_ENABLED
    static L BWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void BWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void BWmoveAA(B *sf, B *df)
   {
    if (serialized) BWmoveAAs(sf,df);
#if THREADS_ENABLED
    else BWmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else BWmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void BLmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void BLmoveSA(B *sf, B *df)
{
D t; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void BLmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void BLmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; L * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void BLmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; L * d;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if THREADS_ENABLED
    static L BLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void BLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void BLmoveAA(B *sf, B *df)
   {
    if (serialized) BLmoveAAs(sf,df);
#if THREADS_ENABLED
    else BLmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else BLmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void BSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((S *)NUM_VAL(df)) = t;
}

static void BSmoveSA(B *sf, B *df)
{
D t; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
}

static void BSmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((S *)NUM_VAL(df)) = t;
}

    static void BSmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; S * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
    }

    static void BSmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; S * d;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L BSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
       return OK;
    }

    static void BSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void BSmoveAA(B *sf, B *df)
   {
    if (serialized) BSmoveAAs(sf,df);
#if THREADS_ENABLED
    else BSmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else BSmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void BDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((D *)NUM_VAL(df)) = t;
}

static void BDmoveSA(B *sf, B *df)
{
D t; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
}

static void BDmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((D *)NUM_VAL(df)) = t;
}

    static void BDmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; D * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
    }

    static void BDmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; D * d;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L BDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
       return OK;
    }

    static void BDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void BDmoveAA(B *sf, B *df)
   {
    if (serialized) BDmoveAAs(sf,df);
#if THREADS_ENABLED
    else BDmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else BDmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void WBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void WBmoveSA(B *sf, B *df)
{
D t; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void WBmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void WBmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; B * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void WBmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; B * d;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if THREADS_ENABLED
    static L WBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void WBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void WBmoveAA(B *sf, B *df)
   {
    if (serialized) WBmoveAAs(sf,df);
#if THREADS_ENABLED
    else WBmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else WBmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void WWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WWmoveSA(B *sf, B *df)
{
D t; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WWmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; W * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; W * d;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if THREADS_ENABLED
    static L WWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void WWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void WWmoveAA(B *sf, B *df)
   {
    if (serialized) WWmoveAAs(sf,df);
#if THREADS_ENABLED
    else WWmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else WWmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void WLmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void WLmoveSA(B *sf, B *df)
{
D t; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void WLmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void WLmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; L * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void WLmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; L * d;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if THREADS_ENABLED
    static L WLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void WLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void WLmoveAA(B *sf, B *df)
   {
    if (serialized) WLmoveAAs(sf,df);
#if THREADS_ENABLED
    else WLmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else WLmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void WSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((S *)NUM_VAL(df)) = t;
}

static void WSmoveSA(B *sf, B *df)
{
D t; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
}

static void WSmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((S *)NUM_VAL(df)) = t;
}

    static void WSmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; S * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
    }

    static void WSmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; S * d;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L WSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
       return OK;
    }

    static void WSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void WSmoveAA(B *sf, B *df)
   {
    if (serialized) WSmoveAAs(sf,df);
#if THREADS_ENABLED
    else WSmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else WSmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void WDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((D *)NUM_VAL(df)) = t;
}

static void WDmoveSA(B *sf, B *df)
{
D t; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
}

static void WDmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((D *)NUM_VAL(df)) = t;
}

    static void WDmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; D * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
    }

    static void WDmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; D * d;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L WDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
       return OK;
    }

    static void WDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void WDmoveAA(B *sf, B *df)
   {
    if (serialized) WDmoveAAs(sf,df);
#if THREADS_ENABLED
    else WDmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else WDmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void LBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void LBmoveSA(B *sf, B *df)
{
D t; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void LBmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void LBmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; B * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void LBmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; B * d;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if THREADS_ENABLED
    static L LBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void LBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void LBmoveAA(B *sf, B *df)
   {
    if (serialized) LBmoveAAs(sf,df);
#if THREADS_ENABLED
    else LBmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else LBmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void LWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void LWmoveSA(B *sf, B *df)
{
D t; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void LWmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void LWmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; W * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void LWmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; W * d;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if THREADS_ENABLED
    static L LWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void LWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void LWmoveAA(B *sf, B *df)
   {
    if (serialized) LWmoveAAs(sf,df);
#if THREADS_ENABLED
    else LWmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else LWmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void LLmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LLmoveSA(B *sf, B *df)
{
D t; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LLmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; L * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; L * d;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if THREADS_ENABLED
    static L LLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void LLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void LLmoveAA(B *sf, B *df)
   {
    if (serialized) LLmoveAAs(sf,df);
#if THREADS_ENABLED
    else LLmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else LLmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void LSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((S *)NUM_VAL(df)) = t;
}

static void LSmoveSA(B *sf, B *df)
{
D t; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
}

static void LSmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((S *)NUM_VAL(df)) = t;
}

    static void LSmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; S * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
    }

    static void LSmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; S * d;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L LSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
       return OK;
    }

    static void LSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void LSmoveAA(B *sf, B *df)
   {
    if (serialized) LSmoveAAs(sf,df);
#if THREADS_ENABLED
    else LSmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else LSmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void LDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((D *)NUM_VAL(df)) = t;
}

static void LDmoveSA(B *sf, B *df)
{
D t; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
}

static void LDmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((D *)NUM_VAL(df)) = t;
}

    static void LDmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; D * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
    }

    static void LDmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; D * d;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L LDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
       return OK;
    }

    static void LDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void LDmoveAA(B *sf, B *df)
   {
    if (serialized) LDmoveAAs(sf,df);
#if THREADS_ENABLED
    else LDmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else LDmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void SBmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void SBmoveSA(B *sf, B *df)
{
D t; L n; B *d;
d = (B *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void SBmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void SBmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; B * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void SBmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; B * d;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if THREADS_ENABLED
    static L SBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void SBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void SBmoveAA(B *sf, B *df)
   {
    if (serialized) SBmoveAAs(sf,df);
#if THREADS_ENABLED
    else SBmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else SBmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void SWmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void SWmoveSA(B *sf, B *df)
{
D t; L n; W *d;
d = (W *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void SWmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void SWmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; W * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void SWmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; W * d;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if THREADS_ENABLED
    static L SWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void SWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void SWmoveAA(B *sf, B *df)
   {
    if (serialized) SWmoveAAs(sf,df);
#if THREADS_ENABLED
    else SWmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else SWmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void SLmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void SLmoveSA(B *sf, B *df)
{
D t; L n; L *d;
d = (L *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void SLmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void SLmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; L * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void SLmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; L * d;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if THREADS_ENABLED
    static L SLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void SLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void SLmoveAA(B *sf, B *df)
   {
    if (serialized) SLmoveAAs(sf,df);
#if THREADS_ENABLED
    else SLmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else SLmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void SSmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((S *)NUM_VAL(df)) = t;
}

static void SSmoveSA(B *sf, B *df)
{
D t; L n; S *d;
d = (S *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
}

static void SSmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((S *)NUM_VAL(df)) = t;
}

    static void SSmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; S * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
    }

    static void SSmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; S * d;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L SSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
       return OK;
    }

    static void SSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void SSmoveAA(B *sf, B *df)
   {
    if (serialized) SSmoveAAs(sf,df);
#if THREADS_ENABLED
    else SSmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else SSmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void SDmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((D *)NUM_VAL(df)) = t;
}

static void SDmoveSA(B *sf, B *df)
{
D t; L n; D *d;
d = (D *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
}

static void SDmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((D *)NUM_VAL(df)) = t;
}

    static void SDmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; D * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
    }

    static void SDmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; D * d;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L SDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
       return OK;
    }

    static void SDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void SDmoveAA(B *sf, B *df)
   {
    if (serialized) SDmoveAAs(sf,df);
#if THREADS_ENABLED
    else SDmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else SDmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void DBmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void DBmoveSA(B *sf, B *df)
{
D t; L n; B *d;
d = (B *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void DBmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void DBmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; B * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void DBmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; B * d;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if THREADS_ENABLED
    static L DBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void DBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void DBmoveAA(B *sf, B *df)
   {
    if (serialized) DBmoveAAs(sf,df);
#if THREADS_ENABLED
    else DBmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else DBmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void DWmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void DWmoveSA(B *sf, B *df)
{
D t; L n; W *d;
d = (W *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void DWmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void DWmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; W * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void DWmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; W * d;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if THREADS_ENABLED
    static L DWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void DWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void DWmoveAA(B *sf, B *df)
   {
    if (serialized) DWmoveAAs(sf,df);
#if THREADS_ENABLED
    else DWmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else DWmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void DLmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void DLmoveSA(B *sf, B *df)
{
D t; L n; L *d;
d = (L *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void DLmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void DLmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; L * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void DLmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; L * d;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if THREADS_ENABLED
    static L DLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void DLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void DLmoveAA(B *sf, B *df)
   {
    if (serialized) DLmoveAAs(sf,df);
#if THREADS_ENABLED
    else DLmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else DLmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void DSmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((S *)NUM_VAL(df)) = t;
}

static void DSmoveSA(B *sf, B *df)
{
D t; L n; S *d;
d = (S *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
}

static void DSmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((S *)NUM_VAL(df)) = t;
}

    static void DSmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; S * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
    }

    static void DSmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; S * d;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L DSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
       return OK;
    }

    static void DSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void DSmoveAA(B *sf, B *df)
   {
    if (serialized) DSmoveAAs(sf,df);
#if THREADS_ENABLED
    else DSmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else DSmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

static void DDmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((D *)NUM_VAL(df)) = t;
}

static void DDmoveSA(B *sf, B *df)
{
D t; L n; D *d;
d = (D *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
}

static void DDmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((D *)NUM_VAL(df)) = t;
}

    static void DDmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; D * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
    }

    static void DDmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; D * d;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
    }


#if THREADS_ENABLED
    static L DDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
       return OK;
    }

    static void DDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDmoveAAt, (B*) &data);
     }
   }
#endif //THREADS_ENABLED

   static void DDmoveAA(B *sf, B *df)
   {
    if (serialized) DDmoveAAs(sf,df);
#if THREADS_ENABLED
    else DDmoveAAc(sf, df);
#else //!THREADS_ENABLED
    else DDmoveAAp(sf,df);
#endif //!THREADS_ENABLED
   }

typedef void (*MOVEfct)(B*,B*);
static MOVEfct MOVElist[] = {
BBmoveSS, BBmoveSA, BBmoveAS, BBmoveAA, 
BWmoveSS, BWmoveSA, BWmoveAS, BWmoveAA, 
BLmoveSS, BLmoveSA, BLmoveAS, BLmoveAA, 
BSmoveSS, BSmoveSA, BSmoveAS, BSmoveAA, 
BDmoveSS, BDmoveSA, BDmoveAS, BDmoveAA, 
WBmoveSS, WBmoveSA, WBmoveAS, WBmoveAA, 
WWmoveSS, WWmoveSA, WWmoveAS, WWmoveAA, 
WLmoveSS, WLmoveSA, WLmoveAS, WLmoveAA, 
WSmoveSS, WSmoveSA, WSmoveAS, WSmoveAA, 
WDmoveSS, WDmoveSA, WDmoveAS, WDmoveAA, 
LBmoveSS, LBmoveSA, LBmoveAS, LBmoveAA, 
LWmoveSS, LWmoveSA, LWmoveAS, LWmoveAA, 
LLmoveSS, LLmoveSA, LLmoveAS, LLmoveAA, 
LSmoveSS, LSmoveSA, LSmoveAS, LSmoveAA, 
LDmoveSS, LDmoveSA, LDmoveAS, LDmoveAA, 
SBmoveSS, SBmoveSA, SBmoveAS, SBmoveAA, 
SWmoveSS, SWmoveSA, SWmoveAS, SWmoveAA, 
SLmoveSS, SLmoveSA, SLmoveAS, SLmoveAA, 
SSmoveSS, SSmoveSA, SSmoveAS, SSmoveAA, 
SDmoveSS, SDmoveSA, SDmoveAS, SDmoveAA, 
DBmoveSS, DBmoveSA, DBmoveAS, DBmoveAA, 
DWmoveSS, DWmoveSA, DWmoveAS, DWmoveAA, 
DLmoveSS, DLmoveSA, DLmoveAS, DLmoveAA, 
DSmoveSS, DSmoveSA, DSmoveAS, DSmoveAA, 
DDmoveSS, DDmoveSA, DDmoveAS, DDmoveAA, 

};

static void BBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BBdyADDAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BBdyADDSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BBdyADDAA(B * df, B * sf)
    {
      if (serialized) BBdyADDAAs(df,sf);
#if THREADS_ENABLED
      else BBdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else BBdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BBdySUBAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BBdySUBSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BBdySUBAA(B * df, B * sf)
    {
      if (serialized) BBdySUBAAs(df,sf);
#if THREADS_ENABLED
      else BBdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else BBdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BBdyMULAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BBdyMULSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BBdyMULAA(B * df, B * sf)
    {
      if (serialized) BBdyMULAAs(df,sf);
#if THREADS_ENABLED
      else BBdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else BBdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BBdyDIVAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BBdyDIVSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BBdyDIVAA(B * df, B * sf)
    {
      if (serialized) BBdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else BBdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else BBdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BBdyPWRAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BBdyPWRSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BBdyPWRAA(B * df, B * sf)
    {
      if (serialized) BBdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else BBdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else BBdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BBdyMODAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BBdyMODSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BBdyMODAA(B * df, B * sf)
    {
      if (serialized) BBdyMODAAs(df,sf);
#if THREADS_ENABLED
      else BBdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else BBdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BBdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BBdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BBdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else BBdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else BBdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BWdyADDAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BWdyADDSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BWdyADDAA(B * df, B * sf)
    {
      if (serialized) BWdyADDAAs(df,sf);
#if THREADS_ENABLED
      else BWdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else BWdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BWdySUBAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BWdySUBSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BWdySUBAA(B * df, B * sf)
    {
      if (serialized) BWdySUBAAs(df,sf);
#if THREADS_ENABLED
      else BWdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else BWdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BWdyMULAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BWdyMULSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BWdyMULAA(B * df, B * sf)
    {
      if (serialized) BWdyMULAAs(df,sf);
#if THREADS_ENABLED
      else BWdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else BWdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BWdyDIVAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BWdyDIVSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BWdyDIVAA(B * df, B * sf)
    {
      if (serialized) BWdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else BWdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else BWdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BWdyPWRAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BWdyPWRSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BWdyPWRAA(B * df, B * sf)
    {
      if (serialized) BWdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else BWdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else BWdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BWdyMODAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BWdyMODSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BWdyMODAA(B * df, B * sf)
    {
      if (serialized) BWdyMODAAs(df,sf);
#if THREADS_ENABLED
      else BWdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else BWdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BWdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BWdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BWdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else BWdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else BWdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BLdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BLdyADDAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BLdyADDSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BLdyADDAA(B * df, B * sf)
    {
      if (serialized) BLdyADDAAs(df,sf);
#if THREADS_ENABLED
      else BLdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else BLdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BLdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BLdySUBAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BLdySUBSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BLdySUBAA(B * df, B * sf)
    {
      if (serialized) BLdySUBAAs(df,sf);
#if THREADS_ENABLED
      else BLdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else BLdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BLdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BLdyMULAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BLdyMULSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BLdyMULAA(B * df, B * sf)
    {
      if (serialized) BLdyMULAAs(df,sf);
#if THREADS_ENABLED
      else BLdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else BLdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BLdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BLdyDIVAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BLdyDIVSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BLdyDIVAA(B * df, B * sf)
    {
      if (serialized) BLdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else BLdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else BLdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BLdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BLdyPWRAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BLdyPWRSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BLdyPWRAA(B * df, B * sf)
    {
      if (serialized) BLdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else BLdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else BLdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BLdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BLdyMODAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BLdyMODSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BLdyMODAA(B * df, B * sf)
    {
      if (serialized) BLdyMODAAs(df,sf);
#if THREADS_ENABLED
      else BLdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else BLdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BLdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BLdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BLdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else BLdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else BLdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BSdyADDAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BSdyADDSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BSdyADDAA(B * df, B * sf)
    {
      if (serialized) BSdyADDAAs(df,sf);
#if THREADS_ENABLED
      else BSdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else BSdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BSdySUBAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BSdySUBSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BSdySUBAA(B * df, B * sf)
    {
      if (serialized) BSdySUBAAs(df,sf);
#if THREADS_ENABLED
      else BSdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else BSdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BSdyMULAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BSdyMULSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BSdyMULAA(B * df, B * sf)
    {
      if (serialized) BSdyMULAAs(df,sf);
#if THREADS_ENABLED
      else BSdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else BSdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BSdyDIVAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BSdyDIVSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BSdyDIVAA(B * df, B * sf)
    {
      if (serialized) BSdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else BSdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else BSdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BSdyPWRAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BSdyPWRSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BSdyPWRAA(B * df, B * sf)
    {
      if (serialized) BSdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else BSdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else BSdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BSdyMODAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BSdyMODSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BSdyMODAA(B * df, B * sf)
    {
      if (serialized) BSdyMODAAs(df,sf);
#if THREADS_ENABLED
      else BSdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else BSdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BSdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BSdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BSdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else BSdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else BSdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BDdyADDAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BDdyADDSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BDdyADDAA(B * df, B * sf)
    {
      if (serialized) BDdyADDAAs(df,sf);
#if THREADS_ENABLED
      else BDdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else BDdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BDdySUBAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BDdySUBSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BDdySUBAA(B * df, B * sf)
    {
      if (serialized) BDdySUBAAs(df,sf);
#if THREADS_ENABLED
      else BDdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else BDdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BDdyMULAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BDdyMULSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BDdyMULAA(B * df, B * sf)
    {
      if (serialized) BDdyMULAAs(df,sf);
#if THREADS_ENABLED
      else BDdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else BDdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BDdyDIVAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BDdyDIVSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BDdyDIVAA(B * df, B * sf)
    {
      if (serialized) BDdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else BDdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else BDdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BDdyPWRAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BDdyPWRSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BDdyPWRAA(B * df, B * sf)
    {
      if (serialized) BDdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else BDdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else BDdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BDdyMODAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BDdyMODSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BDdyMODAA(B * df, B * sf)
    {
      if (serialized) BDdyMODAAs(df,sf);
#if THREADS_ENABLED
      else BDdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else BDdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void BDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BDdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; B *d;
d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BDdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L BDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void BDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BDdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else BDdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else BDdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WBdyADDAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WBdyADDSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WBdyADDAA(B * df, B * sf)
    {
      if (serialized) WBdyADDAAs(df,sf);
#if THREADS_ENABLED
      else WBdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else WBdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WBdySUBAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WBdySUBSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WBdySUBAA(B * df, B * sf)
    {
      if (serialized) WBdySUBAAs(df,sf);
#if THREADS_ENABLED
      else WBdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else WBdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WBdyMULAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WBdyMULSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WBdyMULAA(B * df, B * sf)
    {
      if (serialized) WBdyMULAAs(df,sf);
#if THREADS_ENABLED
      else WBdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else WBdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WBdyDIVAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WBdyDIVSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WBdyDIVAA(B * df, B * sf)
    {
      if (serialized) WBdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else WBdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else WBdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WBdyPWRAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WBdyPWRSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WBdyPWRAA(B * df, B * sf)
    {
      if (serialized) WBdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else WBdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else WBdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WBdyMODAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WBdyMODSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WBdyMODAA(B * df, B * sf)
    {
      if (serialized) WBdyMODAAs(df,sf);
#if THREADS_ENABLED
      else WBdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else WBdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WBdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WBdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WBdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else WBdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else WBdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WWdyADDAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WWdyADDSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WWdyADDAA(B * df, B * sf)
    {
      if (serialized) WWdyADDAAs(df,sf);
#if THREADS_ENABLED
      else WWdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else WWdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WWdySUBAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WWdySUBSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WWdySUBAA(B * df, B * sf)
    {
      if (serialized) WWdySUBAAs(df,sf);
#if THREADS_ENABLED
      else WWdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else WWdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WWdyMULAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WWdyMULSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WWdyMULAA(B * df, B * sf)
    {
      if (serialized) WWdyMULAAs(df,sf);
#if THREADS_ENABLED
      else WWdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else WWdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WWdyDIVAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WWdyDIVSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WWdyDIVAA(B * df, B * sf)
    {
      if (serialized) WWdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else WWdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else WWdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WWdyPWRAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WWdyPWRSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WWdyPWRAA(B * df, B * sf)
    {
      if (serialized) WWdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else WWdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else WWdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WWdyMODAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WWdyMODSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WWdyMODAA(B * df, B * sf)
    {
      if (serialized) WWdyMODAAs(df,sf);
#if THREADS_ENABLED
      else WWdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else WWdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WWdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WWdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WWdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else WWdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else WWdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WLdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WLdyADDAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WLdyADDSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WLdyADDAA(B * df, B * sf)
    {
      if (serialized) WLdyADDAAs(df,sf);
#if THREADS_ENABLED
      else WLdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else WLdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WLdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WLdySUBAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WLdySUBSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WLdySUBAA(B * df, B * sf)
    {
      if (serialized) WLdySUBAAs(df,sf);
#if THREADS_ENABLED
      else WLdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else WLdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WLdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WLdyMULAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WLdyMULSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WLdyMULAA(B * df, B * sf)
    {
      if (serialized) WLdyMULAAs(df,sf);
#if THREADS_ENABLED
      else WLdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else WLdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WLdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WLdyDIVAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WLdyDIVSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WLdyDIVAA(B * df, B * sf)
    {
      if (serialized) WLdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else WLdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else WLdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WLdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WLdyPWRAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WLdyPWRSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WLdyPWRAA(B * df, B * sf)
    {
      if (serialized) WLdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else WLdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else WLdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WLdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WLdyMODAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WLdyMODSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WLdyMODAA(B * df, B * sf)
    {
      if (serialized) WLdyMODAAs(df,sf);
#if THREADS_ENABLED
      else WLdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else WLdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WLdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WLdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WLdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else WLdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else WLdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WSdyADDAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WSdyADDSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WSdyADDAA(B * df, B * sf)
    {
      if (serialized) WSdyADDAAs(df,sf);
#if THREADS_ENABLED
      else WSdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else WSdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WSdySUBAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WSdySUBSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WSdySUBAA(B * df, B * sf)
    {
      if (serialized) WSdySUBAAs(df,sf);
#if THREADS_ENABLED
      else WSdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else WSdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WSdyMULAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WSdyMULSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WSdyMULAA(B * df, B * sf)
    {
      if (serialized) WSdyMULAAs(df,sf);
#if THREADS_ENABLED
      else WSdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else WSdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WSdyDIVAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WSdyDIVSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WSdyDIVAA(B * df, B * sf)
    {
      if (serialized) WSdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else WSdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else WSdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WSdyPWRAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WSdyPWRSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WSdyPWRAA(B * df, B * sf)
    {
      if (serialized) WSdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else WSdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else WSdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WSdyMODAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WSdyMODSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WSdyMODAA(B * df, B * sf)
    {
      if (serialized) WSdyMODAAs(df,sf);
#if THREADS_ENABLED
      else WSdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else WSdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WSdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WSdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WSdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else WSdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else WSdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WDdyADDAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WDdyADDSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WDdyADDAA(B * df, B * sf)
    {
      if (serialized) WDdyADDAAs(df,sf);
#if THREADS_ENABLED
      else WDdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else WDdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WDdySUBAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WDdySUBSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WDdySUBAA(B * df, B * sf)
    {
      if (serialized) WDdySUBAAs(df,sf);
#if THREADS_ENABLED
      else WDdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else WDdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WDdyMULAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WDdyMULSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WDdyMULAA(B * df, B * sf)
    {
      if (serialized) WDdyMULAAs(df,sf);
#if THREADS_ENABLED
      else WDdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else WDdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WDdyDIVAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WDdyDIVSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WDdyDIVAA(B * df, B * sf)
    {
      if (serialized) WDdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else WDdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else WDdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WDdyPWRAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WDdyPWRSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WDdyPWRAA(B * df, B * sf)
    {
      if (serialized) WDdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else WDdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else WDdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WDdyMODAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WDdyMODSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WDdyMODAA(B * df, B * sf)
    {
      if (serialized) WDdyMODAAs(df,sf);
#if THREADS_ENABLED
      else WDdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else WDdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void WDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WDdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; W *d;
d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WDdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L WDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void WDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WDdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else WDdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else WDdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LBdyADDAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LBdyADDSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LBdyADDAA(B * df, B * sf)
    {
      if (serialized) LBdyADDAAs(df,sf);
#if THREADS_ENABLED
      else LBdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else LBdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LBdySUBAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LBdySUBSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LBdySUBAA(B * df, B * sf)
    {
      if (serialized) LBdySUBAAs(df,sf);
#if THREADS_ENABLED
      else LBdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else LBdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LBdyMULAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LBdyMULSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LBdyMULAA(B * df, B * sf)
    {
      if (serialized) LBdyMULAAs(df,sf);
#if THREADS_ENABLED
      else LBdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else LBdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LBdyDIVAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LBdyDIVSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LBdyDIVAA(B * df, B * sf)
    {
      if (serialized) LBdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else LBdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else LBdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LBdyPWRAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LBdyPWRSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LBdyPWRAA(B * df, B * sf)
    {
      if (serialized) LBdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else LBdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else LBdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LBdyMODAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LBdyMODSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LBdyMODAA(B * df, B * sf)
    {
      if (serialized) LBdyMODAAs(df,sf);
#if THREADS_ENABLED
      else LBdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else LBdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LBdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LBdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LBdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else LBdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else LBdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LWdyADDAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LWdyADDSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LWdyADDAA(B * df, B * sf)
    {
      if (serialized) LWdyADDAAs(df,sf);
#if THREADS_ENABLED
      else LWdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else LWdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LWdySUBAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LWdySUBSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LWdySUBAA(B * df, B * sf)
    {
      if (serialized) LWdySUBAAs(df,sf);
#if THREADS_ENABLED
      else LWdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else LWdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LWdyMULAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LWdyMULSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LWdyMULAA(B * df, B * sf)
    {
      if (serialized) LWdyMULAAs(df,sf);
#if THREADS_ENABLED
      else LWdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else LWdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LWdyDIVAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LWdyDIVSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LWdyDIVAA(B * df, B * sf)
    {
      if (serialized) LWdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else LWdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else LWdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LWdyPWRAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LWdyPWRSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LWdyPWRAA(B * df, B * sf)
    {
      if (serialized) LWdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else LWdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else LWdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LWdyMODAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LWdyMODSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LWdyMODAA(B * df, B * sf)
    {
      if (serialized) LWdyMODAAs(df,sf);
#if THREADS_ENABLED
      else LWdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else LWdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LWdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LWdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LWdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else LWdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else LWdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LLdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LLdyADDAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LLdyADDSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LLdyADDAA(B * df, B * sf)
    {
      if (serialized) LLdyADDAAs(df,sf);
#if THREADS_ENABLED
      else LLdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else LLdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LLdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LLdySUBAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LLdySUBSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LLdySUBAA(B * df, B * sf)
    {
      if (serialized) LLdySUBAAs(df,sf);
#if THREADS_ENABLED
      else LLdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else LLdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LLdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LLdyMULAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LLdyMULSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LLdyMULAA(B * df, B * sf)
    {
      if (serialized) LLdyMULAAs(df,sf);
#if THREADS_ENABLED
      else LLdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else LLdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LLdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LLdyDIVAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LLdyDIVSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LLdyDIVAA(B * df, B * sf)
    {
      if (serialized) LLdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else LLdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else LLdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LLdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LLdyPWRAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LLdyPWRSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LLdyPWRAA(B * df, B * sf)
    {
      if (serialized) LLdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else LLdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else LLdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LLdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LLdyMODAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LLdyMODSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LLdyMODAA(B * df, B * sf)
    {
      if (serialized) LLdyMODAAs(df,sf);
#if THREADS_ENABLED
      else LLdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else LLdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LLdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LLdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LLdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else LLdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else LLdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LSdyADDAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LSdyADDSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LSdyADDAA(B * df, B * sf)
    {
      if (serialized) LSdyADDAAs(df,sf);
#if THREADS_ENABLED
      else LSdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else LSdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LSdySUBAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LSdySUBSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LSdySUBAA(B * df, B * sf)
    {
      if (serialized) LSdySUBAAs(df,sf);
#if THREADS_ENABLED
      else LSdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else LSdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LSdyMULAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LSdyMULSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LSdyMULAA(B * df, B * sf)
    {
      if (serialized) LSdyMULAAs(df,sf);
#if THREADS_ENABLED
      else LSdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else LSdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LSdyDIVAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LSdyDIVSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LSdyDIVAA(B * df, B * sf)
    {
      if (serialized) LSdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else LSdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else LSdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LSdyPWRAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LSdyPWRSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LSdyPWRAA(B * df, B * sf)
    {
      if (serialized) LSdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else LSdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else LSdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LSdyMODAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LSdyMODSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LSdyMODAA(B * df, B * sf)
    {
      if (serialized) LSdyMODAAs(df,sf);
#if THREADS_ENABLED
      else LSdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else LSdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LSdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LSdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LSdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else LSdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else LSdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LDdyADDAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LDdyADDSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LDdyADDAA(B * df, B * sf)
    {
      if (serialized) LDdyADDAAs(df,sf);
#if THREADS_ENABLED
      else LDdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else LDdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LDdySUBAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LDdySUBSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LDdySUBAA(B * df, B * sf)
    {
      if (serialized) LDdySUBAAs(df,sf);
#if THREADS_ENABLED
      else LDdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else LDdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LDdyMULAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LDdyMULSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LDdyMULAA(B * df, B * sf)
    {
      if (serialized) LDdyMULAAs(df,sf);
#if THREADS_ENABLED
      else LDdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else LDdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LDdyDIVAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LDdyDIVSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LDdyDIVAA(B * df, B * sf)
    {
      if (serialized) LDdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else LDdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else LDdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LDdyPWRAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LDdyPWRSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LDdyPWRAA(B * df, B * sf)
    {
      if (serialized) LDdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else LDdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else LDdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LDdyMODAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LDdyMODSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LDdyMODAA(B * df, B * sf)
    {
      if (serialized) LDdyMODAAs(df,sf);
#if THREADS_ENABLED
      else LDdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else LDdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void LDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LDdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; L *d;
d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LDdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef THREADS_ENABLED
    static L LDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void LDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LDdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else LDdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else LDdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SBdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

static void SBdyADDAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}

static void SBdyADDSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SBdyADDAA(B * df, B * sf)
    {
      if (serialized) SBdyADDAAs(df,sf);
#if THREADS_ENABLED
      else SBdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else SBdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SBdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SBdySUBAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}

static void SBdySUBSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SBdySUBAA(B * df, B * sf)
    {
      if (serialized) SBdySUBAAs(df,sf);
#if THREADS_ENABLED
      else SBdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else SBdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SBdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SBdyMULAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}

static void SBdyMULSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SBdyMULAA(B * df, B * sf)
    {
      if (serialized) SBdyMULAAs(df,sf);
#if THREADS_ENABLED
      else SBdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else SBdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SBdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SBdyDIVAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}

static void SBdyDIVSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SBdyDIVAA(B * df, B * sf)
    {
      if (serialized) SBdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else SBdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else SBdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SBdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SBdyPWRAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}

static void SBdyPWRSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SBdyPWRAA(B * df, B * sf)
    {
      if (serialized) SBdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else SBdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else SBdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SBdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SBdyMODAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}

static void SBdyMODSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SBdyMODAA(B * df, B * sf)
    {
      if (serialized) SBdyMODAAs(df,sf);
#if THREADS_ENABLED
      else SBdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else SBdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SBdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}

static void SBdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SBdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else SBdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else SBdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SWdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

static void SWdyADDAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}

static void SWdyADDSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SWdyADDAA(B * df, B * sf)
    {
      if (serialized) SWdyADDAAs(df,sf);
#if THREADS_ENABLED
      else SWdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else SWdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SWdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SWdySUBAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}

static void SWdySUBSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SWdySUBAA(B * df, B * sf)
    {
      if (serialized) SWdySUBAAs(df,sf);
#if THREADS_ENABLED
      else SWdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else SWdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SWdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SWdyMULAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}

static void SWdyMULSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SWdyMULAA(B * df, B * sf)
    {
      if (serialized) SWdyMULAAs(df,sf);
#if THREADS_ENABLED
      else SWdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else SWdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SWdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SWdyDIVAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}

static void SWdyDIVSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SWdyDIVAA(B * df, B * sf)
    {
      if (serialized) SWdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else SWdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else SWdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SWdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SWdyPWRAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}

static void SWdyPWRSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SWdyPWRAA(B * df, B * sf)
    {
      if (serialized) SWdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else SWdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else SWdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SWdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SWdyMODAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}

static void SWdyMODSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SWdyMODAA(B * df, B * sf)
    {
      if (serialized) SWdyMODAAs(df,sf);
#if THREADS_ENABLED
      else SWdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else SWdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SWdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}

static void SWdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SWdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else SWdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else SWdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SLdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

static void SLdyADDAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}

static void SLdyADDSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SLdyADDAA(B * df, B * sf)
    {
      if (serialized) SLdyADDAAs(df,sf);
#if THREADS_ENABLED
      else SLdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else SLdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SLdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SLdySUBAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}

static void SLdySUBSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SLdySUBAA(B * df, B * sf)
    {
      if (serialized) SLdySUBAAs(df,sf);
#if THREADS_ENABLED
      else SLdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else SLdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SLdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SLdyMULAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}

static void SLdyMULSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SLdyMULAA(B * df, B * sf)
    {
      if (serialized) SLdyMULAAs(df,sf);
#if THREADS_ENABLED
      else SLdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else SLdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SLdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SLdyDIVAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}

static void SLdyDIVSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SLdyDIVAA(B * df, B * sf)
    {
      if (serialized) SLdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else SLdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else SLdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SLdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SLdyPWRAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}

static void SLdyPWRSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SLdyPWRAA(B * df, B * sf)
    {
      if (serialized) SLdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else SLdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else SLdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SLdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SLdyMODAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}

static void SLdyMODSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SLdyMODAA(B * df, B * sf)
    {
      if (serialized) SLdyMODAAs(df,sf);
#if THREADS_ENABLED
      else SLdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else SLdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SLdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}

static void SLdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SLdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else SLdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else SLdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SSdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t += tt;
*((S *)NUM_VAL(df)) = t;
}

static void SSdyADDAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}

static void SSdyADDSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SSdyADDAA(B * df, B * sf)
    {
      if (serialized) SSdyADDAAs(df,sf);
#if THREADS_ENABLED
      else SSdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else SSdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SSdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SSdySUBAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}

static void SSdySUBSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SSdySUBAA(B * df, B * sf)
    {
      if (serialized) SSdySUBAAs(df,sf);
#if THREADS_ENABLED
      else SSdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else SSdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SSdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SSdyMULAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}

static void SSdyMULSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SSdyMULAA(B * df, B * sf)
    {
      if (serialized) SSdyMULAAs(df,sf);
#if THREADS_ENABLED
      else SSdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else SSdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SSdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SSdyDIVAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}

static void SSdyDIVSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SSdyDIVAA(B * df, B * sf)
    {
      if (serialized) SSdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else SSdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else SSdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SSdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SSdyPWRAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}

static void SSdyPWRSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SSdyPWRAA(B * df, B * sf)
    {
      if (serialized) SSdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else SSdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else SSdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SSdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SSdyMODAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}

static void SSdyMODSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SSdyMODAA(B * df, B * sf)
    {
      if (serialized) SSdyMODAAs(df,sf);
#if THREADS_ENABLED
      else SSdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else SSdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SSdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}

static void SSdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SSdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else SSdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else SSdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SDdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t += tt;
*((S *)NUM_VAL(df)) = t;
}

static void SDdyADDAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
}

static void SDdyADDSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SDdyADDAA(B * df, B * sf)
    {
      if (serialized) SDdyADDAAs(df,sf);
#if THREADS_ENABLED
      else SDdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else SDdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SDdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SDdySUBAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
}

static void SDdySUBSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SDdySUBAA(B * df, B * sf)
    {
      if (serialized) SDdySUBAAs(df,sf);
#if THREADS_ENABLED
      else SDdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else SDdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SDdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SDdyMULAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
}

static void SDdyMULSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SDdyMULAA(B * df, B * sf)
    {
      if (serialized) SDdyMULAAs(df,sf);
#if THREADS_ENABLED
      else SDdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else SDdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SDdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

static void SDdyDIVAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
}

static void SDdyDIVSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
}

    static void SDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SDdyDIVAA(B * df, B * sf)
    {
      if (serialized) SDdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else SDdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else SDdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SDdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SDdyPWRAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
}

static void SDdyPWRSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SDdyPWRAA(B * df, B * sf)
    {
      if (serialized) SDdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else SDdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else SDdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SDdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SDdyMODAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
}

static void SDdyMODSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SDdyMODAA(B * df, B * sf)
    {
      if (serialized) SDdyMODAAs(df,sf);
#if THREADS_ENABLED
      else SDdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else SDdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void SDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

static void SDdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; S *d;
d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
}

static void SDdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
}

    static void SDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L SDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void SDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SDdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else SDdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else SDdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DBdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

static void DBdyADDAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}

static void DBdyADDSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DBdyADDAA(B * df, B * sf)
    {
      if (serialized) DBdyADDAAs(df,sf);
#if THREADS_ENABLED
      else DBdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else DBdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DBdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DBdySUBAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}

static void DBdySUBSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DBdySUBAA(B * df, B * sf)
    {
      if (serialized) DBdySUBAAs(df,sf);
#if THREADS_ENABLED
      else DBdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else DBdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DBdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DBdyMULAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}

static void DBdyMULSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DBdyMULAA(B * df, B * sf)
    {
      if (serialized) DBdyMULAAs(df,sf);
#if THREADS_ENABLED
      else DBdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else DBdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DBdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DBdyDIVAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}

static void DBdyDIVSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DBdyDIVAA(B * df, B * sf)
    {
      if (serialized) DBdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else DBdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else DBdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DBdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DBdyPWRAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}

static void DBdyPWRSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DBdyPWRAA(B * df, B * sf)
    {
      if (serialized) DBdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else DBdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else DBdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DBdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DBdyMODAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}

static void DBdyMODSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DBdyMODAA(B * df, B * sf)
    {
      if (serialized) DBdyMODAAs(df,sf);
#if THREADS_ENABLED
      else DBdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else DBdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DBdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}

static void DBdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; B *s;
s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DBdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else DBdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else DBdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DWdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

static void DWdyADDAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}

static void DWdyADDSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DWdyADDAA(B * df, B * sf)
    {
      if (serialized) DWdyADDAAs(df,sf);
#if THREADS_ENABLED
      else DWdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else DWdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DWdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DWdySUBAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}

static void DWdySUBSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DWdySUBAA(B * df, B * sf)
    {
      if (serialized) DWdySUBAAs(df,sf);
#if THREADS_ENABLED
      else DWdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else DWdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DWdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DWdyMULAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}

static void DWdyMULSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DWdyMULAA(B * df, B * sf)
    {
      if (serialized) DWdyMULAAs(df,sf);
#if THREADS_ENABLED
      else DWdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else DWdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DWdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DWdyDIVAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}

static void DWdyDIVSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DWdyDIVAA(B * df, B * sf)
    {
      if (serialized) DWdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else DWdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else DWdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DWdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DWdyPWRAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}

static void DWdyPWRSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DWdyPWRAA(B * df, B * sf)
    {
      if (serialized) DWdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else DWdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else DWdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DWdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DWdyMODAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}

static void DWdyMODSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DWdyMODAA(B * df, B * sf)
    {
      if (serialized) DWdyMODAAs(df,sf);
#if THREADS_ENABLED
      else DWdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else DWdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DWdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}

static void DWdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; W *s;
s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DWdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else DWdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else DWdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DLdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

static void DLdyADDAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}

static void DLdyADDSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DLdyADDAA(B * df, B * sf)
    {
      if (serialized) DLdyADDAAs(df,sf);
#if THREADS_ENABLED
      else DLdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else DLdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DLdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DLdySUBAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}

static void DLdySUBSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DLdySUBAA(B * df, B * sf)
    {
      if (serialized) DLdySUBAAs(df,sf);
#if THREADS_ENABLED
      else DLdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else DLdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DLdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DLdyMULAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}

static void DLdyMULSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DLdyMULAA(B * df, B * sf)
    {
      if (serialized) DLdyMULAAs(df,sf);
#if THREADS_ENABLED
      else DLdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else DLdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DLdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DLdyDIVAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}

static void DLdyDIVSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DLdyDIVAA(B * df, B * sf)
    {
      if (serialized) DLdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else DLdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else DLdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DLdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DLdyPWRAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}

static void DLdyPWRSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DLdyPWRAA(B * df, B * sf)
    {
      if (serialized) DLdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else DLdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else DLdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DLdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DLdyMODAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}

static void DLdyMODSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DLdyMODAA(B * df, B * sf)
    {
      if (serialized) DLdyMODAAs(df,sf);
#if THREADS_ENABLED
      else DLdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else DLdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DLdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}

static void DLdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; L *s;
s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DLdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else DLdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else DLdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DSdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t += tt;
*((D *)NUM_VAL(df)) = t;
}

static void DSdyADDAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}

static void DSdyADDSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DSdyADDAA(B * df, B * sf)
    {
      if (serialized) DSdyADDAAs(df,sf);
#if THREADS_ENABLED
      else DSdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else DSdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DSdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DSdySUBAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}

static void DSdySUBSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DSdySUBAA(B * df, B * sf)
    {
      if (serialized) DSdySUBAAs(df,sf);
#if THREADS_ENABLED
      else DSdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else DSdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DSdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DSdyMULAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}

static void DSdyMULSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DSdyMULAA(B * df, B * sf)
    {
      if (serialized) DSdyMULAAs(df,sf);
#if THREADS_ENABLED
      else DSdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else DSdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DSdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DSdyDIVAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}

static void DSdyDIVSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DSdyDIVAA(B * df, B * sf)
    {
      if (serialized) DSdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else DSdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else DSdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DSdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DSdyPWRAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}

static void DSdyPWRSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DSdyPWRAA(B * df, B * sf)
    {
      if (serialized) DSdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else DSdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else DSdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DSdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DSdyMODAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}

static void DSdyMODSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DSdyMODAA(B * df, B * sf)
    {
      if (serialized) DSdyMODAAs(df,sf);
#if THREADS_ENABLED
      else DSdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else DSdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DSdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}

static void DSdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; S *s;
s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DSdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else DSdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else DSdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DDdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t += tt;
*((D *)NUM_VAL(df)) = t;
}

static void DDdyADDAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
}

static void DDdyADDSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyADDAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DDdyADDAA(B * df, B * sf)
    {
      if (serialized) DDdyADDAAs(df,sf);
#if THREADS_ENABLED
      else DDdyADDAAc(df,sf);
#else //!THREADS_ENABLED
      else DDdyADDAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DDdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DDdySUBAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
}

static void DDdySUBSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdySUBAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DDdySUBAA(B * df, B * sf)
    {
      if (serialized) DDdySUBAAs(df,sf);
#if THREADS_ENABLED
      else DDdySUBAAc(df,sf);
#else //!THREADS_ENABLED
      else DDdySUBAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DDdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DDdyMULAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
}

static void DDdyMULSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyMULAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DDdyMULAA(B * df, B * sf)
    {
      if (serialized) DDdyMULAAs(df,sf);
#if THREADS_ENABLED
      else DDdyMULAAc(df,sf);
#else //!THREADS_ENABLED
      else DDdyMULAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DDdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

static void DDdyDIVAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
}

static void DDdyDIVSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
}

    static void DDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyDIVAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DDdyDIVAA(B * df, B * sf)
    {
      if (serialized) DDdyDIVAAs(df,sf);
#if THREADS_ENABLED
      else DDdyDIVAAc(df,sf);
#else //!THREADS_ENABLED
      else DDdyDIVAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DDdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DDdyPWRAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
}

static void DDdyPWRSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyPWRAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DDdyPWRAA(B * df, B * sf)
    {
      if (serialized) DDdyPWRAAs(df,sf);
#if THREADS_ENABLED
      else DDdyPWRAAc(df,sf);
#else //!THREADS_ENABLED
      else DDdyPWRAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DDdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DDdyMODAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
}

static void DDdyMODSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyMODAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DDdyMODAA(B * df, B * sf)
    {
      if (serialized) DDdyMODAAs(df,sf);
#if THREADS_ENABLED
      else DDdyMODAAc(df,sf);
#else //!THREADS_ENABLED
      else DDdyMODAAp(df,sf);
#endif //!THREADS_ENABLED
    }

static void DDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

static void DDdyTHEARCAS(B *df, B *sf)
{
D t,tt; L n; D *d;
d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
}

static void DDdyTHEARCSA(B *df, B *sf)
{
D t,tt; L n; D *s;
s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
}

    static void DDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef THREADS_ENABLED
    static L DDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //THREADS_ENABLED

    static void DDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DDdyTHEARCAAs(df,sf);
#if THREADS_ENABLED
      else DDdyTHEARCAAc(df,sf);
#else //!THREADS_ENABLED
      else DDdyTHEARCAAp(df,sf);
#endif //!THREADS_ENABLED
    }

typedef void (*dyadic_fct)(B*,B*);
static dyadic_fct ADDlist[] = {
BBdyADDSS, BBdyADDAS, BBdyADDSA, BBdyADDAA, 
BWdyADDSS, BWdyADDAS, BWdyADDSA, BWdyADDAA, 
BLdyADDSS, BLdyADDAS, BLdyADDSA, BLdyADDAA, 
BSdyADDSS, BSdyADDAS, BSdyADDSA, BSdyADDAA, 
BDdyADDSS, BDdyADDAS, BDdyADDSA, BDdyADDAA, 
WBdyADDSS, WBdyADDAS, WBdyADDSA, WBdyADDAA, 
WWdyADDSS, WWdyADDAS, WWdyADDSA, WWdyADDAA, 
WLdyADDSS, WLdyADDAS, WLdyADDSA, WLdyADDAA, 
WSdyADDSS, WSdyADDAS, WSdyADDSA, WSdyADDAA, 
WDdyADDSS, WDdyADDAS, WDdyADDSA, WDdyADDAA, 
LBdyADDSS, LBdyADDAS, LBdyADDSA, LBdyADDAA, 
LWdyADDSS, LWdyADDAS, LWdyADDSA, LWdyADDAA, 
LLdyADDSS, LLdyADDAS, LLdyADDSA, LLdyADDAA, 
LSdyADDSS, LSdyADDAS, LSdyADDSA, LSdyADDAA, 
LDdyADDSS, LDdyADDAS, LDdyADDSA, LDdyADDAA, 
SBdyADDSS, SBdyADDAS, SBdyADDSA, SBdyADDAA, 
SWdyADDSS, SWdyADDAS, SWdyADDSA, SWdyADDAA, 
SLdyADDSS, SLdyADDAS, SLdyADDSA, SLdyADDAA, 
SSdyADDSS, SSdyADDAS, SSdyADDSA, SSdyADDAA, 
SDdyADDSS, SDdyADDAS, SDdyADDSA, SDdyADDAA, 
DBdyADDSS, DBdyADDAS, DBdyADDSA, DBdyADDAA, 
DWdyADDSS, DWdyADDAS, DWdyADDSA, DWdyADDAA, 
DLdyADDSS, DLdyADDAS, DLdyADDSA, DLdyADDAA, 
DSdyADDSS, DSdyADDAS, DSdyADDSA, DSdyADDAA, 
DDdyADDSS, DDdyADDAS, DDdyADDSA, DDdyADDAA, 

};
static dyadic_fct SUBlist[] = {
BBdySUBSS, BBdySUBAS, BBdySUBSA, BBdySUBAA, 
BWdySUBSS, BWdySUBAS, BWdySUBSA, BWdySUBAA, 
BLdySUBSS, BLdySUBAS, BLdySUBSA, BLdySUBAA, 
BSdySUBSS, BSdySUBAS, BSdySUBSA, BSdySUBAA, 
BDdySUBSS, BDdySUBAS, BDdySUBSA, BDdySUBAA, 
WBdySUBSS, WBdySUBAS, WBdySUBSA, WBdySUBAA, 
WWdySUBSS, WWdySUBAS, WWdySUBSA, WWdySUBAA, 
WLdySUBSS, WLdySUBAS, WLdySUBSA, WLdySUBAA, 
WSdySUBSS, WSdySUBAS, WSdySUBSA, WSdySUBAA, 
WDdySUBSS, WDdySUBAS, WDdySUBSA, WDdySUBAA, 
LBdySUBSS, LBdySUBAS, LBdySUBSA, LBdySUBAA, 
LWdySUBSS, LWdySUBAS, LWdySUBSA, LWdySUBAA, 
LLdySUBSS, LLdySUBAS, LLdySUBSA, LLdySUBAA, 
LSdySUBSS, LSdySUBAS, LSdySUBSA, LSdySUBAA, 
LDdySUBSS, LDdySUBAS, LDdySUBSA, LDdySUBAA, 
SBdySUBSS, SBdySUBAS, SBdySUBSA, SBdySUBAA, 
SWdySUBSS, SWdySUBAS, SWdySUBSA, SWdySUBAA, 
SLdySUBSS, SLdySUBAS, SLdySUBSA, SLdySUBAA, 
SSdySUBSS, SSdySUBAS, SSdySUBSA, SSdySUBAA, 
SDdySUBSS, SDdySUBAS, SDdySUBSA, SDdySUBAA, 
DBdySUBSS, DBdySUBAS, DBdySUBSA, DBdySUBAA, 
DWdySUBSS, DWdySUBAS, DWdySUBSA, DWdySUBAA, 
DLdySUBSS, DLdySUBAS, DLdySUBSA, DLdySUBAA, 
DSdySUBSS, DSdySUBAS, DSdySUBSA, DSdySUBAA, 
DDdySUBSS, DDdySUBAS, DDdySUBSA, DDdySUBAA, 

};
static dyadic_fct MULlist[] = {
BBdyMULSS, BBdyMULAS, BBdyMULSA, BBdyMULAA, 
BWdyMULSS, BWdyMULAS, BWdyMULSA, BWdyMULAA, 
BLdyMULSS, BLdyMULAS, BLdyMULSA, BLdyMULAA, 
BSdyMULSS, BSdyMULAS, BSdyMULSA, BSdyMULAA, 
BDdyMULSS, BDdyMULAS, BDdyMULSA, BDdyMULAA, 
WBdyMULSS, WBdyMULAS, WBdyMULSA, WBdyMULAA, 
WWdyMULSS, WWdyMULAS, WWdyMULSA, WWdyMULAA, 
WLdyMULSS, WLdyMULAS, WLdyMULSA, WLdyMULAA, 
WSdyMULSS, WSdyMULAS, WSdyMULSA, WSdyMULAA, 
WDdyMULSS, WDdyMULAS, WDdyMULSA, WDdyMULAA, 
LBdyMULSS, LBdyMULAS, LBdyMULSA, LBdyMULAA, 
LWdyMULSS, LWdyMULAS, LWdyMULSA, LWdyMULAA, 
LLdyMULSS, LLdyMULAS, LLdyMULSA, LLdyMULAA, 
LSdyMULSS, LSdyMULAS, LSdyMULSA, LSdyMULAA, 
LDdyMULSS, LDdyMULAS, LDdyMULSA, LDdyMULAA, 
SBdyMULSS, SBdyMULAS, SBdyMULSA, SBdyMULAA, 
SWdyMULSS, SWdyMULAS, SWdyMULSA, SWdyMULAA, 
SLdyMULSS, SLdyMULAS, SLdyMULSA, SLdyMULAA, 
SSdyMULSS, SSdyMULAS, SSdyMULSA, SSdyMULAA, 
SDdyMULSS, SDdyMULAS, SDdyMULSA, SDdyMULAA, 
DBdyMULSS, DBdyMULAS, DBdyMULSA, DBdyMULAA, 
DWdyMULSS, DWdyMULAS, DWdyMULSA, DWdyMULAA, 
DLdyMULSS, DLdyMULAS, DLdyMULSA, DLdyMULAA, 
DSdyMULSS, DSdyMULAS, DSdyMULSA, DSdyMULAA, 
DDdyMULSS, DDdyMULAS, DDdyMULSA, DDdyMULAA, 

};
static dyadic_fct DIVlist[] = {
BBdyDIVSS, BBdyDIVAS, BBdyDIVSA, BBdyDIVAA, 
BWdyDIVSS, BWdyDIVAS, BWdyDIVSA, BWdyDIVAA, 
BLdyDIVSS, BLdyDIVAS, BLdyDIVSA, BLdyDIVAA, 
BSdyDIVSS, BSdyDIVAS, BSdyDIVSA, BSdyDIVAA, 
BDdyDIVSS, BDdyDIVAS, BDdyDIVSA, BDdyDIVAA, 
WBdyDIVSS, WBdyDIVAS, WBdyDIVSA, WBdyDIVAA, 
WWdyDIVSS, WWdyDIVAS, WWdyDIVSA, WWdyDIVAA, 
WLdyDIVSS, WLdyDIVAS, WLdyDIVSA, WLdyDIVAA, 
WSdyDIVSS, WSdyDIVAS, WSdyDIVSA, WSdyDIVAA, 
WDdyDIVSS, WDdyDIVAS, WDdyDIVSA, WDdyDIVAA, 
LBdyDIVSS, LBdyDIVAS, LBdyDIVSA, LBdyDIVAA, 
LWdyDIVSS, LWdyDIVAS, LWdyDIVSA, LWdyDIVAA, 
LLdyDIVSS, LLdyDIVAS, LLdyDIVSA, LLdyDIVAA, 
LSdyDIVSS, LSdyDIVAS, LSdyDIVSA, LSdyDIVAA, 
LDdyDIVSS, LDdyDIVAS, LDdyDIVSA, LDdyDIVAA, 
SBdyDIVSS, SBdyDIVAS, SBdyDIVSA, SBdyDIVAA, 
SWdyDIVSS, SWdyDIVAS, SWdyDIVSA, SWdyDIVAA, 
SLdyDIVSS, SLdyDIVAS, SLdyDIVSA, SLdyDIVAA, 
SSdyDIVSS, SSdyDIVAS, SSdyDIVSA, SSdyDIVAA, 
SDdyDIVSS, SDdyDIVAS, SDdyDIVSA, SDdyDIVAA, 
DBdyDIVSS, DBdyDIVAS, DBdyDIVSA, DBdyDIVAA, 
DWdyDIVSS, DWdyDIVAS, DWdyDIVSA, DWdyDIVAA, 
DLdyDIVSS, DLdyDIVAS, DLdyDIVSA, DLdyDIVAA, 
DSdyDIVSS, DSdyDIVAS, DSdyDIVSA, DSdyDIVAA, 
DDdyDIVSS, DDdyDIVAS, DDdyDIVSA, DDdyDIVAA, 

};
static dyadic_fct PWRlist[] = {
BBdyPWRSS, BBdyPWRAS, BBdyPWRSA, BBdyPWRAA, 
BWdyPWRSS, BWdyPWRAS, BWdyPWRSA, BWdyPWRAA, 
BLdyPWRSS, BLdyPWRAS, BLdyPWRSA, BLdyPWRAA, 
BSdyPWRSS, BSdyPWRAS, BSdyPWRSA, BSdyPWRAA, 
BDdyPWRSS, BDdyPWRAS, BDdyPWRSA, BDdyPWRAA, 
WBdyPWRSS, WBdyPWRAS, WBdyPWRSA, WBdyPWRAA, 
WWdyPWRSS, WWdyPWRAS, WWdyPWRSA, WWdyPWRAA, 
WLdyPWRSS, WLdyPWRAS, WLdyPWRSA, WLdyPWRAA, 
WSdyPWRSS, WSdyPWRAS, WSdyPWRSA, WSdyPWRAA, 
WDdyPWRSS, WDdyPWRAS, WDdyPWRSA, WDdyPWRAA, 
LBdyPWRSS, LBdyPWRAS, LBdyPWRSA, LBdyPWRAA, 
LWdyPWRSS, LWdyPWRAS, LWdyPWRSA, LWdyPWRAA, 
LLdyPWRSS, LLdyPWRAS, LLdyPWRSA, LLdyPWRAA, 
LSdyPWRSS, LSdyPWRAS, LSdyPWRSA, LSdyPWRAA, 
LDdyPWRSS, LDdyPWRAS, LDdyPWRSA, LDdyPWRAA, 
SBdyPWRSS, SBdyPWRAS, SBdyPWRSA, SBdyPWRAA, 
SWdyPWRSS, SWdyPWRAS, SWdyPWRSA, SWdyPWRAA, 
SLdyPWRSS, SLdyPWRAS, SLdyPWRSA, SLdyPWRAA, 
SSdyPWRSS, SSdyPWRAS, SSdyPWRSA, SSdyPWRAA, 
SDdyPWRSS, SDdyPWRAS, SDdyPWRSA, SDdyPWRAA, 
DBdyPWRSS, DBdyPWRAS, DBdyPWRSA, DBdyPWRAA, 
DWdyPWRSS, DWdyPWRAS, DWdyPWRSA, DWdyPWRAA, 
DLdyPWRSS, DLdyPWRAS, DLdyPWRSA, DLdyPWRAA, 
DSdyPWRSS, DSdyPWRAS, DSdyPWRSA, DSdyPWRAA, 
DDdyPWRSS, DDdyPWRAS, DDdyPWRSA, DDdyPWRAA, 

};
static dyadic_fct MODlist[] = {
BBdyMODSS, BBdyMODAS, BBdyMODSA, BBdyMODAA, 
BWdyMODSS, BWdyMODAS, BWdyMODSA, BWdyMODAA, 
BLdyMODSS, BLdyMODAS, BLdyMODSA, BLdyMODAA, 
BSdyMODSS, BSdyMODAS, BSdyMODSA, BSdyMODAA, 
BDdyMODSS, BDdyMODAS, BDdyMODSA, BDdyMODAA, 
WBdyMODSS, WBdyMODAS, WBdyMODSA, WBdyMODAA, 
WWdyMODSS, WWdyMODAS, WWdyMODSA, WWdyMODAA, 
WLdyMODSS, WLdyMODAS, WLdyMODSA, WLdyMODAA, 
WSdyMODSS, WSdyMODAS, WSdyMODSA, WSdyMODAA, 
WDdyMODSS, WDdyMODAS, WDdyMODSA, WDdyMODAA, 
LBdyMODSS, LBdyMODAS, LBdyMODSA, LBdyMODAA, 
LWdyMODSS, LWdyMODAS, LWdyMODSA, LWdyMODAA, 
LLdyMODSS, LLdyMODAS, LLdyMODSA, LLdyMODAA, 
LSdyMODSS, LSdyMODAS, LSdyMODSA, LSdyMODAA, 
LDdyMODSS, LDdyMODAS, LDdyMODSA, LDdyMODAA, 
SBdyMODSS, SBdyMODAS, SBdyMODSA, SBdyMODAA, 
SWdyMODSS, SWdyMODAS, SWdyMODSA, SWdyMODAA, 
SLdyMODSS, SLdyMODAS, SLdyMODSA, SLdyMODAA, 
SSdyMODSS, SSdyMODAS, SSdyMODSA, SSdyMODAA, 
SDdyMODSS, SDdyMODAS, SDdyMODSA, SDdyMODAA, 
DBdyMODSS, DBdyMODAS, DBdyMODSA, DBdyMODAA, 
DWdyMODSS, DWdyMODAS, DWdyMODSA, DWdyMODAA, 
DLdyMODSS, DLdyMODAS, DLdyMODSA, DLdyMODAA, 
DSdyMODSS, DSdyMODAS, DSdyMODSA, DSdyMODAA, 
DDdyMODSS, DDdyMODAS, DDdyMODSA, DDdyMODAA, 

};
static dyadic_fct THEARClist[] = {
BBdyTHEARCSS, BBdyTHEARCAS, BBdyTHEARCSA, BBdyTHEARCAA, 
BWdyTHEARCSS, BWdyTHEARCAS, BWdyTHEARCSA, BWdyTHEARCAA, 
BLdyTHEARCSS, BLdyTHEARCAS, BLdyTHEARCSA, BLdyTHEARCAA, 
BSdyTHEARCSS, BSdyTHEARCAS, BSdyTHEARCSA, BSdyTHEARCAA, 
BDdyTHEARCSS, BDdyTHEARCAS, BDdyTHEARCSA, BDdyTHEARCAA, 
WBdyTHEARCSS, WBdyTHEARCAS, WBdyTHEARCSA, WBdyTHEARCAA, 
WWdyTHEARCSS, WWdyTHEARCAS, WWdyTHEARCSA, WWdyTHEARCAA, 
WLdyTHEARCSS, WLdyTHEARCAS, WLdyTHEARCSA, WLdyTHEARCAA, 
WSdyTHEARCSS, WSdyTHEARCAS, WSdyTHEARCSA, WSdyTHEARCAA, 
WDdyTHEARCSS, WDdyTHEARCAS, WDdyTHEARCSA, WDdyTHEARCAA, 
LBdyTHEARCSS, LBdyTHEARCAS, LBdyTHEARCSA, LBdyTHEARCAA, 
LWdyTHEARCSS, LWdyTHEARCAS, LWdyTHEARCSA, LWdyTHEARCAA, 
LLdyTHEARCSS, LLdyTHEARCAS, LLdyTHEARCSA, LLdyTHEARCAA, 
LSdyTHEARCSS, LSdyTHEARCAS, LSdyTHEARCSA, LSdyTHEARCAA, 
LDdyTHEARCSS, LDdyTHEARCAS, LDdyTHEARCSA, LDdyTHEARCAA, 
SBdyTHEARCSS, SBdyTHEARCAS, SBdyTHEARCSA, SBdyTHEARCAA, 
SWdyTHEARCSS, SWdyTHEARCAS, SWdyTHEARCSA, SWdyTHEARCAA, 
SLdyTHEARCSS, SLdyTHEARCAS, SLdyTHEARCSA, SLdyTHEARCAA, 
SSdyTHEARCSS, SSdyTHEARCAS, SSdyTHEARCSA, SSdyTHEARCAA, 
SDdyTHEARCSS, SDdyTHEARCAS, SDdyTHEARCSA, SDdyTHEARCAA, 
DBdyTHEARCSS, DBdyTHEARCAS, DBdyTHEARCSA, DBdyTHEARCAA, 
DWdyTHEARCSS, DWdyTHEARCAS, DWdyTHEARCSA, DWdyTHEARCAA, 
DLdyTHEARCSS, DLdyTHEARCAS, DLdyTHEARCSA, DLdyTHEARCAA, 
DSdyTHEARCSS, DSdyTHEARCAS, DSdyTHEARCSA, DSdyTHEARCAA, 
DDdyTHEARCSS, DDdyTHEARCAS, DDdyTHEARCSA, DDdyTHEARCAA, 

};

static void BmoNEGS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = -t;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoNEGA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoABSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = fabs(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoABSA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoSQRTS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = sqrt(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoSQRTA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoEXPS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = exp(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoEXPA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoLNS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = log(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoLNA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoLGS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = log10(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoLGA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoFLOORS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = floor(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoFLOORA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoCEILS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = ceil(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoCEILA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoSINS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = sin(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoSINA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoCOSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = cos(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoCOSA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoTANS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = tan(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoTANA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoASINS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = asin(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoASINA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoACOSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = acos(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoACOSA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void BmoATANS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = atan(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void BmoATANA(B *df)
{
D t; B *d; L n;
d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
}

static void WmoNEGS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = -t;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoNEGA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoABSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = fabs(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoABSA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoSQRTS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = sqrt(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoSQRTA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoEXPS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = exp(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoEXPA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoLNS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = log(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoLNA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoLGS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = log10(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoLGA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoFLOORS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = floor(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoFLOORA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoCEILS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = ceil(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoCEILA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoSINS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = sin(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoSINA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoCOSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = cos(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoCOSA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoTANS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = tan(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoTANA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoASINS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = asin(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoASINA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoACOSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = acos(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoACOSA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void WmoATANS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = atan(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void WmoATANA(B *df)
{
D t; W *d; L n;
d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
}

static void LmoNEGS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = -t;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoNEGA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoABSS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = fabs(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoABSA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoSQRTS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = sqrt(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoSQRTA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoEXPS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = exp(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoEXPA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoLNS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = log(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoLNA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoLGS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = log10(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoLGA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoFLOORS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = floor(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoFLOORA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoCEILS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = ceil(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoCEILA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoSINS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = sin(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoSINA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoCOSS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = cos(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoCOSA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoTANS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = tan(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoTANA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoASINS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = asin(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoASINA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoACOSS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = acos(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoACOSA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void LmoATANS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = atan(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void LmoATANA(B *df)
{
D t; L *d; L n;
d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
}

static void SmoNEGS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = -t;
*((S *)NUM_VAL(df)) = t;
}

static void SmoNEGA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
}

static void SmoABSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = fabs(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoABSA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
}

static void SmoSQRTS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = sqrt(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoSQRTA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
}

static void SmoEXPS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = exp(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoEXPA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
}

static void SmoLNS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = log(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoLNA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
}

static void SmoLGS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = log10(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoLGA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
}

static void SmoFLOORS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = floor(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoFLOORA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
}

static void SmoCEILS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = ceil(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoCEILA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
}

static void SmoSINS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = sin(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoSINA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
}

static void SmoCOSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = cos(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoCOSA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
}

static void SmoTANS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = tan(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoTANA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
}

static void SmoASINS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = asin(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoASINA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
}

static void SmoACOSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = acos(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoACOSA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
}

static void SmoATANS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = atan(t);
*((S *)NUM_VAL(df)) = t;
}

static void SmoATANA(B *df)
{
D t; S *d; L n;
d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
}

static void DmoNEGS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = -t;
*((D *)NUM_VAL(df)) = t;
}

static void DmoNEGA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
}

static void DmoABSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = fabs(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoABSA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
}

static void DmoSQRTS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = sqrt(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoSQRTA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
}

static void DmoEXPS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = exp(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoEXPA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
}

static void DmoLNS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = log(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoLNA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
}

static void DmoLGS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = log10(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoLGA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
}

static void DmoFLOORS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = floor(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoFLOORA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
}

static void DmoCEILS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = ceil(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoCEILA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
}

static void DmoSINS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = sin(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoSINA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
}

static void DmoCOSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = cos(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoCOSA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
}

static void DmoTANS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = tan(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoTANA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
}

static void DmoASINS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = asin(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoASINA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
}

static void DmoACOSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = acos(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoACOSA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
}

static void DmoATANS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = atan(t);
*((D *)NUM_VAL(df)) = t;
}

static void DmoATANA(B *df)
{
D t; D *d; L n;
d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
}

typedef void (*monadic_fct)(B*);
static monadic_fct NEGlist[] = {
BmoNEGS, BmoNEGA, 
WmoNEGS, WmoNEGA, 
LmoNEGS, LmoNEGA, 
SmoNEGS, SmoNEGA, 
DmoNEGS, DmoNEGA, 

};
static monadic_fct ABSlist[] = {
BmoABSS, BmoABSA, 
WmoABSS, WmoABSA, 
LmoABSS, LmoABSA, 
SmoABSS, SmoABSA, 
DmoABSS, DmoABSA, 

};
static monadic_fct SQRTlist[] = {
BmoSQRTS, BmoSQRTA, 
WmoSQRTS, WmoSQRTA, 
LmoSQRTS, LmoSQRTA, 
SmoSQRTS, SmoSQRTA, 
DmoSQRTS, DmoSQRTA, 

};
static monadic_fct EXPlist[] = {
BmoEXPS, BmoEXPA, 
WmoEXPS, WmoEXPA, 
LmoEXPS, LmoEXPA, 
SmoEXPS, SmoEXPA, 
DmoEXPS, DmoEXPA, 

};
static monadic_fct LNlist[] = {
BmoLNS, BmoLNA, 
WmoLNS, WmoLNA, 
LmoLNS, LmoLNA, 
SmoLNS, SmoLNA, 
DmoLNS, DmoLNA, 

};
static monadic_fct LGlist[] = {
BmoLGS, BmoLGA, 
WmoLGS, WmoLGA, 
LmoLGS, LmoLGA, 
SmoLGS, SmoLGA, 
DmoLGS, DmoLGA, 

};
static monadic_fct FLOORlist[] = {
BmoFLOORS, BmoFLOORA, 
WmoFLOORS, WmoFLOORA, 
LmoFLOORS, LmoFLOORA, 
SmoFLOORS, SmoFLOORA, 
DmoFLOORS, DmoFLOORA, 

};
static monadic_fct CEILlist[] = {
BmoCEILS, BmoCEILA, 
WmoCEILS, WmoCEILA, 
LmoCEILS, LmoCEILA, 
SmoCEILS, SmoCEILA, 
DmoCEILS, DmoCEILA, 

};
static monadic_fct SINlist[] = {
BmoSINS, BmoSINA, 
WmoSINS, WmoSINA, 
LmoSINS, LmoSINA, 
SmoSINS, SmoSINA, 
DmoSINS, DmoSINA, 

};
static monadic_fct COSlist[] = {
BmoCOSS, BmoCOSA, 
WmoCOSS, WmoCOSA, 
LmoCOSS, LmoCOSA, 
SmoCOSS, SmoCOSA, 
DmoCOSS, DmoCOSA, 

};
static monadic_fct TANlist[] = {
BmoTANS, BmoTANA, 
WmoTANS, WmoTANA, 
LmoTANS, LmoTANA, 
SmoTANS, SmoTANA, 
DmoTANS, DmoTANA, 

};
static monadic_fct ASINlist[] = {
BmoASINS, BmoASINA, 
WmoASINS, WmoASINA, 
LmoASINS, LmoASINA, 
SmoASINS, SmoASINA, 
DmoASINS, DmoASINA, 

};
static monadic_fct ACOSlist[] = {
BmoACOSS, BmoACOSA, 
WmoACOSS, WmoACOSA, 
LmoACOSS, LmoACOSA, 
SmoACOSS, SmoACOSA, 
DmoACOSS, DmoACOSA, 

};
static monadic_fct ATANlist[] = {
BmoATANS, BmoATANA, 
WmoATANS, WmoATANA, 
LmoATANS, LmoATANA, 
SmoATANS, SmoATANA, 
DmoATANS, DmoATANA, 

};
static void Bdecr(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t -= 1.0;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void Wdecr(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t -= 1.0;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void Ldecr(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t -= 1.0;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void Sdecr(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t -= 1.0;
*((S *)NUM_VAL(df)) = t;
}

static void Ddecr(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t -= 1.0;
*((D *)NUM_VAL(df)) = t;
}

typedef void (*DECR_fct)(B*);
static DECR_fct DECRlist[] = {
Bdecr, Wdecr, Ldecr, Sdecr, Ddecr, 
};
