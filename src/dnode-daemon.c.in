#line 2 "@srcdir@/dnode-daemon.c.in"

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/wait.h>
#include <signal.h>
#include <syslog.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdarg.h>
#include <string.h>
#include <fcntl.h>

struct node {
  pid_t pid;
  pid_t oldpid;
  int port;
  int fd;
};

struct nodes {
  int n;
  struct node node[0];
} *nodes = NULL;

#define QUIT_TIME 20
#define READ_TIME 2

static long renice;

#define errorxn(...) errorx(0, 0, __VA_ARGS__)
#define errorxy(...) errorx(1, 0, __VA_ARGS__)
#define warnxn(...)  errorx(0, 1, __VA_ARGS__)
#define warnxy(...)  errorx(1, 1, __VA_ARGS__)
static void errorx(char doerrno, int warn, const char* format, ...);

static char int_ = 0;
void sigint(int sig __attribute__((__unused__))) {int_ = 1;}
static char term_ = 0;
void sigterm(int sig __attribute__((__unused__))) {term_ = 1;}
static char alarm_ = 0;
void sigalarm(int sig __attribute__((__unused__))) {alarm_ = 1;}

static void sethandler(void (*handler)(int), int sig, int flag) {
  struct sigaction sa;
  sigset_t mask;
  sigfillset(&mask);

  sa.sa_handler = handler;
  sa.sa_flags = flag;
  sa.sa_mask = mask;
  if (sigaction(sig, &sa, NULL) == -1)
    errorxy("Unable to setup signal handler for sig: %i", sig);
}

static char* splitstring(char** string) {
  char* next = *string;
  while (next = strchr(next, '\n')) {
    *(next++) = '\0';
    if (! **string) *string = next;
  };
  return next && *next ? next : NULL;
}

static void lognode(struct node* node) {
  static char buffer[1024];
  ssize_t s, s_;
  char* next;
  char* last;
  struct timeval t;
  fd_set readf;
  FD_ZERO(&readf);

  do {
    int sel;
    s = 0;
    FD_SET(node->fd, &readf);
    t.tv_sec = READ;
    t.tv_usec = 0;
    while ((sel = select(1, &readf, NULL, NULL, &t)) > 0) {
      if ((s_ = read(node->fd, buffer + s, sizeof(buffer-1) - s)) <= 0) break;
      s += s_;
      t = t_;
    }
    warnxn("Characters read=%i,sel=%i,sec=%i,s_=%i", 
	   s, sel, t.tv_sec, s_);

    if (sel < 0) {
      if (errno == EINTR) s_ = -1;
      else
	errorxy("Unable to select on child %i, fd %i", node->oldpid, node->fd);
    }

    if (! s) continue;
    else if (s_ < 0) {
      switch (errno) {
	case EINTR: case EAGAIN:
	  buffer[s] = '\0';
	  warnxn("Intr Message from %i: %s", node->oldpid, buffer);
	  return;
	default:
	  errorxy("Error reading from child %i", node->oldpid);
      }
    }

    buffer[s] = '\0';
    last = buffer;
    if (! (next = splitstring(&last))) {
      if (*last) warnxn("Message from %i: %s", node->oldpid, last);
      else continue;
    }
    else {
      warnxn("Begin message from %i: %s", node->oldpid, last);
      for (last = next; (next = splitstring(&last)); last = next)
	warnxn("Cont message from %i: %s", node->oldpid, last);
      warnxn("End message from %i: %s", node->oldpid, last);
    }
  } while (s == sizeof(buffer)-1);
}

static void lognodes(int active, fd_set* read) {
  int i = 0;
  for (; active && i < nodes->n; ++i) {
    if (nodes->node[i].fd != -1 && FD_ISSET(nodes->node[i].fd, read)) {
      lognode(&nodes->node[i]);
      --active;
    }
  }
}

static char killing = 0;
static void killall(void) {
  int status;
  pid_t pid;
  int i;
  int n;
  
  if (! nodes) return;

  killing = 1;
  alarm_ = 0;
  sethandler(SIG_IGN, SIGINT, 0);
  sethandler(sigalarm, SIGALRM, SA_RESETHAND);
  alarm(QUIT_TIME);

  if (kill(0, SIGINT)) {
    errorxy("Error calling kill SIGINT on children");
    exit(1);
  }
  
  n = nodes->n;
  while (n && ! alarm_) {
    if ((pid = wait(&status)) < 0) {
      errorxy("Error waiting for children");
      exit(1);
    }

    for (i = 0; i < nodes->n; ++i) 
      if (nodes->node[i].pid == pid || nodes->node[i].oldpid == pid) {
	--n;
	nodes->node[i].pid = 0;
	if (! WIFEXITED(status)) {
	  errorxn("Child %i exited with status %i", pid, WEXITSTATUS(status));
	  if (WIFSIGNALED(status))
	    errorxn("Child %i exited due to signal %i", pid, WTERMSIG(status));
	}
	break;
      }
  }

  sethandler(SIG_IGN, SIGALRM, 0);
  sethandler(SIG_IGN, SIGCHLD, SA_NOCLDWAIT);

  for (i = 0; i < nodes->n; ++i)
    if (nodes->node[i].fd != -1) {
      lognode(&nodes->node[i]);
      if (close(nodes->node[i].fd))
	warnxn("Unable to close child %i pipe", nodes->node[i].oldpid);
      nodes->node[i].fd = -1;
    }

  if (n) {
    for (i = 0; i < nodes->n; ++i) {
      if (! nodes->node[i].pid) continue;
      if (kill(nodes->node[i].pid, SIGKILL))
	warnxy("Unable to send SIGKILL to child %i", nodes->node[i].pid);
      nodes->node[i].pid = 0;
    }
  }
  killing = 0;
  sethandler(sigint, SIGINT, 0);
}

static char daemonized = 0 ;
static void startlog(void) {
  daemonized = 1;
  openlog("dnode-daemon", LOG_DAEMON, LOG_CONS);
  if (close(STDIN_FILENO) 
      || close(STDOUT_FILENO) 
      || close(STDERR_FILENO))
    errorxy("Unable to close std streams");

  if (getpgrp() != getpid() && setsid() == -1) 
    errorxy("Unable to setsid");
}

static void errorx(char doerrno, int warn, const char* format, ...) {
  int s;
  static char buffer[2048];
  va_list ap;
  va_start(ap, format);
  s = vsnprintf(buffer, sizeof(buffer), format, ap);
  va_end(ap);
  if (s < 0) {
    syslog(LOG_ERR, "Unable to init errorx buffer");
    if (!killing) exit(1);
  }
  if (s >= sizeof(buffer)) {
    errorxn("errorx buffer overflow");
    if (!killing) exit(1);
  }

  if (daemonized) {
    int pri = warn ? LOG_WARNING : LOG_ERR;
    if (doerrno) syslog(pri, "%s: %m", buffer);
    else syslog(pri, "%s", buffer);
  }
  else {
    char* pri = warn ? "Warning" : "Error";
    if (doerrno) {
      if (fprintf(stderr, "%s - %s: %s\n", pri, buffer, strerror(errno)) < 0) {
	perror("Unable to fprintf errorx");
	if (! killing) exit(1);
      }
    } else if (fprintf(stderr, "%s - %s\n", pri, buffer) < 0) {
      perror("Unable to fprintf errorx");
      if (! killing) exit(1);
    }
  }

  if (! warn && ! killing) {
    killall();
    exit(1);
  }
}

static void cleanupdead(fd_set* read) {
  pid_t pid;
  int i, status;

  while ((pid = waitpid(-1, &status, WNOHANG)) > 0);
  if (! pid) return;
  if (pid < 0) switch (errno) {
    case ECHILD: case EINTR: return;
    default:errorxy("Error calling waitpid");
  }

  for (i = 0; i < nodes->n; ++i)
    if (pid == nodes->node[i].pid || pid == nodes->node[i].oldpid) {
      if (! WIFEXITED(status)) {
	killing = 1;
	errorxn("Child %i exited with status %i", pid, WEXITSTATUS(status));
	if (WIFSIGNALED(status))
	  errorxn("Child %i exited due to signal %i", pid, WTERMSIG(status));
	killing = 0;
      }
      if (nodes->node[i].fd != -1) {
	lognode(&nodes->node[i]);
	if (close(nodes->node[i].fd))
	  warnxn("Unable to close read end of pipe for child %i", pid);
	FD_CLR(nodes->node[i].fd, read);
      }

      nodes->node[i].fd = -1;
      nodes->node[i].pid = 0;
    }
}

static uid_t uid;
static uid_t euid;
static gid_t gid;
static gid_t egid;

static void child(int pipefd[2], int port) {
  static char buffer[1024];
  int s;

  if (close(pipefd[0])) {
    syslog(LOG_ERR, "Unable to close read end of pipe: %m");
    exit(1);
  }
  if (dup2(pipefd[1], STDOUT_FILENO) < 0 
      || dup2(pipefd[1], STDERR_FILENO) < 0) {
    syslog(LOG_ERR, "Unable to dup stdout and stderr to pid: %m");
    exit(1);
  }
  
  
  if (pipefd[1] != STDOUT_FILENO 
      && pipefd[1] != STDERR_FILENO
      && close(pipefd[1])) {
    fprintf(stderr, "Unable to close write end of pipe after dup\n");
    exit(1);
  }

  errno = 0;
  if (uid != 0)
    fprintf(stderr, "Not running as root - not trying to renice\n");
  else if (nice(renice) == -1 && errno) perror("Unable to renice");

  if (gid == egid)
    fprintf(stderr, "Not running setgid, not dropping privileges\n");
  else if (setegid(egid) || setgid(egid)) {
    perror("Unable to drop privileges");
    exit(1);
  }

  if (uid == euid)
    fprintf(stderr, "Not running setuid, not dropping privileges\n");
  else if (seteuid(euid) || setuid(euid)) {
    perror("Unable to drop privileges");
    exit(1);
  }
      
  if ((s = snprintf(buffer, sizeof(buffer), "%i", port)) < 1) {
    perror("Unable to sprintf buffer");
    exit(1);
  }
  if (s >= sizeof(buffer)) {
    fprintf(stderr, "Holy shit - port doesn't fit in %i characters\n", s);
    exit(1);
  }
  
  fprintf(stderr, "Starting: `%s' `%s' `%s'\n", 
	  "@bindir@/dnode", buffer, "0");

  execl("@bindir@/dnode", "@bindir@/dnode", buffer, "0", NULL);
  perror("Unable to run `/usr/local/bin/dnode'");
  exit(1);
}

static void body(fd_set* read) {
  int i;
  int pipefd[2];

  for (i=0; i<nodes->n; i++) {
    if (nodes->node[i].pid) continue;
    
    if (pipe(pipefd)) errorxy("Error creating pipe");

    switch ((nodes->node[i].oldpid = nodes->node[i].pid = fork())) {
      case -1: errorxy("Unable to fork");
      case 0: child(pipefd, nodes->node[i].port);
      default:
	FD_SET(nodes->node[i].fd = pipefd[0], read);
	if (close(pipefd[1]))
	  errorxy("Unable to close write end of pipe in parent");
	//if (fcntl(pipefd[0], F_SETFL, O_NONBLOCK) == -1)
	//  errorxy("Unable to set read end of pipe nonblocking");
    }
  }
}

static void mainloop(void) {
  fd_set read, read_;
  int active = 0;
  FD_ZERO(&read);

  do {
    cleanupdead(&read);
    body(&read);
    read_ = read;
    if ((active = select(nodes->n, &read_, NULL, NULL, NULL)) < 0)
      if (errno != EINTR) errorxy("Select error");
    lognodes(active, &read_);
  } while (! term_ && ! int_);

  killall();
}

const char* args(const int argc, const char* argv[]) {
  const char** argvi = argv;
  char* endptr;
  int nnodes, i;
  const char* pidfilename;

  if (argc < 4)
    errorxn("Arguments: renice-number pid-file port... - Params: %d", 
	    argc-1);
  
  renice = strtol(*++argvi, &endptr, 0);
  if (! **argvi || *endptr)
    errorxn("Renice argument must be an integer: `%s'", argvi);

  pidfilename = *++argvi;

  nnodes = argc-3;
  nodes = (struct nodes*) malloc(sizeof(struct nodes)
				  +sizeof(struct node)*nnodes);
  nodes->n = nnodes;
  for (i=0; i<nnodes; i++) {
    nodes->node[i].port = strtol(*++argvi, &endptr, 0);
    if (! **argvi || *endptr)
      errorxn("Port argument must be an integer: `%s'", *argvi);
    nodes->node[i].pid = 0;
    nodes->node[i].oldpid = 0;
    nodes->node[i].fd = -1;
  }

  return pidfilename;
}

static void daemonize(const char* pidfilename) {
  FILE* pidfile;
  pid_t pid, pidr;
  int status;

  sethandler(sigint, SIGINT, 0);
  sethandler(sigterm, SIGTERM, 0);
  sethandler(sigterm, SIGQUIT, 0);
  
  if ((pid = fork())) {
    if (pid == -1) errorxy("Unable to fork");

    if (! (pidfile = fopen(pidfilename, "w"))) {
      kill(pid, SIGTERM);
      errorxy("Unable to open %s", pidfilename);
    }
    if (fprintf(pidfile, "%i\n", pid) < 0) {
      kill(pid, SIGTERM);
      errorxy("Unable to write to %s", pidfilename);
    }
    if (fclose(pidfile)) {
      kill(pid, SIGTERM);
      errorxy("Unable to close %s", pidfilename);
    }

    if (kill(pid, SIGINT)) errorxy("Unable to signal %i", pid);
    while ((pidr = waitpid(pid, NULL, 0)) != pid && ! int_)
      if (pidr == -1 && errno != EINTR) errorxy("Unable to wait for daemon");
      
    exit(int_ ? 0 : 1);
  }
  
  startlog();
  pause();
  if (term_) exit(0);
  if (int_) int_ = 0;
  if (kill(getppid(), SIGINT)) errorxy("Unable to signal parent");
}

static void setuids(void) {
  uid = getuid();
  euid = geteuid();
  gid = getgid();
  egid = getegid();

  if (uid == euid)
    warnxn("Not running setuid, uid = %i", uid);
  else if (seteuid(uid))
    errorxy("Not able to switch euid from %i to %i", euid, uid);

  if (gid == egid)
    warnxn("Not running setgid, gid = %i", gid);
  else if (setegid(gid))
    errorxy("Not able to switch egid from %i to %i", egid, gid);
}

int main(const int argc, const char* argv[]) {
  const char* pidfilename = args(argc, argv);
  setuids();
  daemonize(pidfilename);
  mainloop();
  
  return 0;
}
  
