#line 2 "@srcdir@/dnode-daemon.c.in"

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/wait.h>
#include <signal.h>
#include <syslog.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdarg.h>
#include <string.h>
#include <fcntl.h>

#include "config.h"

#if ! defined __GNUC__ && ! defined __attribute__
#define __attribute__(attr)
#endif // ! defined __GNUC__ && ! defined __attribute__

//#define SIGINT SIGHUP

struct node {
  pid_t pid;
  pid_t io;
  int port;
};

struct nodes {
  int n;
  struct node node[0];
} *nodes = NULL;

#define QUIT_TIME 20
#define DAEMON_TIME 10

static long renice;

#define fataln(...)  errorx(0, 0, 1, __VA_ARGS__)
#define fataly(...)  errorx(1, 0, 1, __VA_ARGS__)
#define errorxn(...) errorx(0, 0, 0, __VA_ARGS__)
#define errorxy(...) errorx(1, 0, 0, __VA_ARGS__)
#define warnxn(...)  errorx(0, 1, 0, __VA_ARGS__)
#define warnxy(...)  errorx(1, 1, 0, __VA_ARGS__)
static void errorx(char doerrno, char warn, char die, const char* format, ...)
  __attribute__ ((format (printf, 4, 5)));

#if HAVE_SYS_PRCTL_H && HAVE_PRCTL
#include <sys/prctl.h>
#ifdef PR_SET_NAME
static void setprocessname(const char* name) {
  if (prctl(PR_SET_NAME, name))
    warnxy("Unable to set process name to %s", name);
}
#define SETPROCESSNAME(name) setprocessname(name)
#endif // PR_SET_NAME
#endif // HAVE_PRCTL && HAVE_SYS_PRCTL_H

#ifndef SETPROCESSNAME
#define SETPROCESSNAME(name)
#endif

static char int_ = 0;
void sigint(int sig __attribute__((__unused__))) {int_ = 1;}
static char term_ = 0;
void sigterm(int sig __attribute__((__unused__))) {term_ = 1;}
static char alarm_ = 0;
void sigalarm(int sig __attribute__((__unused__))) {alarm_ = 1;}

static void sethandler(void (*handler)(int), int sig, int flag) {
  struct sigaction sa;
  sigset_t mask;
  sigfillset(&mask);

  sa.sa_handler = handler;
  sa.sa_flags = flag;
  sa.sa_mask = mask;
  if (sigaction(sig, &sa, NULL) == -1)
    fataly("Unable to setup signal handler for sig: %i", sig);
}

static char* splitstring(char** string) {
  char* next = *string;

  if (! *next) return NULL;
  while (*next ==  '\n') next++;
  if (**string == '\n') *string = next;

  while (*next && *next != '\n') next++;
  if (*next) *(next++) = '\0';

  while (*next && *next == '\n') next++;
  return *next ? next : NULL;
}

static void handlestatus(const char* type, int status, pid_t pid) {
  if (WIFEXITED(status))
    warnxn("Child %s %i exited normally", type, pid);
  else {
    errorxn("Child %s %i exited with status %i", 
	    type, pid, WEXITSTATUS(status));
    if (WIFSIGNALED(status))
      errorxn("Child %s %i exited due to signal %i", 
	      type, pid, WTERMSIG(status));
  }
}

static void killnode(pid_t* pid, int sig) {
  if (! *pid) return;

  if (kill(*pid, sig)) {
    if (errno == ESRCH) *pid = 0;
    else fataly("Daemon unable to kill %i to %i", sig, *pid);
  }
}

static void waitdead(void) {
  pid_t pid;
  int i;
  int status;

  if ((pid = wait(&status)) < 0) {
    if (errno == EINTR) return;
    fataly("Daemon unable to wait");
  }

  for (i = 0; i < nodes->n; i++) {
    if (nodes->node[i].pid == pid) {
      nodes->node[i].pid = 0;
      handlestatus("dnode", status, pid);
      return;
    }

    if (nodes->node[i].io == pid) {
      nodes->node[i].io = 0;
      handlestatus("io", status, pid);
      killnode(&nodes->node[i].pid, SIGINT);
      return;
    }
  }
}

static char killing = 0;
static void killall(void) {
  int i;
  if (! nodes) return;

  killing = 1;
  sethandler(SIG_IGN, SIGINT, 0);
  sethandler(SIG_IGN, SIGQUIT, 0);
  sethandler(SIG_IGN, SIGTERM, 0);

  for (int i = 0; i < nodes->n; i++) killnode(&nodes->node[i].pid, SIGINT);

  alarm_ = 0;
  sethandler(sigalarm, SIGALRM, SA_RESETHAND);
  alarm(QUIT_TIME);

 START:
  for (i = 0; 
       i < nodes->n && (nodes->node[i].pid || nodes->node[i].io);
       i++);
  if (i < nodes->n && ! alarm) {
    waitdead();
    goto START;
  }

  sethandler(SIG_IGN, SIGALRM, 0);
  alarm(0);
  sethandler(SIG_IGN, SIGCHLD, SA_NOCLDWAIT);

  if (i < nodes->n) {
    for (i = 0; i < nodes->n; i++)
      if (nodes->node[i].pid) killnode(&nodes->node[i].pid, SIGKILL);
    for (i = 0; i < nodes->n; i++)
      if (nodes->node[i].io) killnode(&nodes->node[i].io, SIGKILL);
    exit(1);
  }

  exit(0);
}

static char dokillall = 0;
static char daemonized = 0 ;
static void startlog(void) {
  daemonized = 1;
  dokillall = 1;
  openlog("dnode-daemon", LOG_DAEMON, LOG_CONS);
  if (close(STDIN_FILENO) 
      || close(STDOUT_FILENO) 
      || close(STDERR_FILENO))
    fataly("Unable to close std streams");

  if (getpgrp() != getpid() && setsid() == -1) 
    fataly("Unable to setsid");
}

static void errorx(char doerrno, char warn, char die, const char* format, ...) {
  int s;
  static char buffer[2048];
  char* type = warn ? "Warning" : "Error";
  va_list ap;
  va_start(ap, format);
  s = vsnprintf(buffer, sizeof(buffer), format, ap);
  va_end(ap);
  if (s < 0) {
    syslog(LOG_ERR, "Unable to init errorx buffer");
    if (!killing && die) exit(1);
  }
  if (s >= sizeof(buffer)) {
    errorxn("errorx buffer overflow");
    if (!killing && die) exit(1);
  }

  if (daemonized) {
    int pri = warn ? LOG_WARNING : LOG_ERR;
    if (doerrno) syslog(pri, "%s - %s: %m", type, buffer);
    else syslog(pri, "%s - %s", type, buffer);
  }
  else {
    if (doerrno) {
      if (fprintf(stderr, "%s - %s: %s\n", type, buffer, strerror(errno)) < 0) {
	perror("Unable to fprintf errorx");
	if (! killing && die) exit(1);
      }
    } else if (fprintf(stderr, "%s - %s\n", type, buffer) < 0) {
      perror("Unable to fprintf errorx");
      if (! killing && die) exit(1);
    }
  }

  if (! killing && die) {
    if (dokillall) killall();
    exit(1);
  }
}

static void io(int reader, int writer, struct node* node) {
  static char buffer[1024];
  ssize_t s;
  char* next;
  char* last;

  if (close(writer))
    fataly("io %i unable to close writer %i for child %i", 
	     node->io, writer, node->pid);

  while ((s = read(reader, buffer, sizeof(buffer) - 1)) > 0) {
    buffer[s] = '\0';
    last = buffer;
    if (! (next = splitstring(&last))) {
      if (*last) warnxn("Message from %i: %s", node->pid, last);
    }
    else {
      warnxn("Begin message from %i: %s", node->pid, last);
      for (last = next; (next = splitstring(&last)); last = next)
	warnxn("Cont message from %i: %s", node->pid, last);
      warnxn("End message from %i: %s", node->pid, last);
    }
  };

  if (s < 0 && ! term_)
    fataly("io %i reading error for child %i, fd %i", 
	     node->io, node->pid, reader);

  if (close(reader))
    fataly("io %i pipe dead for child %i, fd %i", 
	   node->io, node->pid, reader);
  
  exit(0);
}

static uid_t uid;
static uid_t euid;
static gid_t gid;
static gid_t egid;

static void dnode(int reader, int writer, struct node* node) {
  static char buffer[1024];
  int s;

  if (close(reader))
    fataly("Child %i unable to close read end of pipe %i: %m",
	     node->pid, reader);
  if (dup2(writer, STDOUT_FILENO) < 0 || dup2(writer, STDERR_FILENO) < 0)
    fataly("Child %i unable to dup from %i to stdout and stderr to: %m",
	     node->pid, writer);
  
  daemonized = 0;
  if (writer != STDOUT_FILENO 
      && writer != STDERR_FILENO
      && close(writer))
    fataly("Child %i unable to close write end of pipe %i after dup",
	     node->pid, writer);

  errno = 0;
  if (uid != 0) 
    warnxn("Child %i not running as root - not trying to renice", node->pid);
  else if (nice(renice) == -1 && errno) 
    warnxy("Child %i unable to renice", node->pid);

  if (gid == egid)
    warnxn("Child %i not running setgid, not dropping privileges", node->pid);
  else if (setegid(egid) || setgid(egid))
    fataly("Child %i unable to drop privileges", node->pid);

  if (uid == euid)
    warnxn("Child %i not running setuid, not dropping privileges", node->pid);
  else if (uid == 0) {
    if (setuid(euid))
      fataly("Child %i unable to drop privileges", node->pid);
  }
  else if (seteuid(euid) || setuid(euid))
    fataly("Child %i unable to drop privileges", node->pid);
      
  if ((s = snprintf(buffer, sizeof(buffer), "%i", node->port)) < 1)
    fataly("Child %i unable to sprintf buffer");
  if (s >= sizeof(buffer))
    fataln("Child %i holy shit - port doesn't fit in %i characters", 
	     node->pid, s);
  warnxn("Starting `%s' `%s' `%s'", 
	 "@bindir@/dnode", buffer, "0");

  execl("@bindir@/dnode", "@bindir@/dnode", buffer, "0", NULL);
  fataly("Child %i unable to run `@bindir@/dnode'", node->pid);
}

typedef void (*sibfunc)(int reader, int writer, struct node* node);

static void forksib(const char* pname, sibfunc sibf, 
		    int reader, int writer, 
		    struct node* node, pid_t* pid) {
  switch ((*pid = fork())) {
    case -1: fataly("Daemon unable to fork");
    case 0: 
      dokillall = 0; 
      *pid = getpid();
      SETPROCESSNAME(pname);
      sibf(reader, writer, node);
  }
}

static void createlive(void) {
  int i;
  int pipefd[2];

  for (i=0; i<nodes->n; i++) {
    if (nodes->node[i].pid || nodes->node[i].io) continue;
    
    if (pipe(pipefd)) fataly("Dameon unable to create pipe");
    forksib("dnode-init", dnode, pipefd[0], pipefd[1],
	    &nodes->node[i], &nodes->node[i].pid);
    forksib("dnode-io", io, pipefd[0], pipefd[1], 
	    &nodes->node[i], &nodes->node[i].io);
    if (close(pipefd[0])) fataly("Daemon unable to close reader in daemon");
    if (close(pipefd[1])) fataly("Daemon unable to close writer in daemon");
  }
}

static void mainloop(void) {
  do {
    createlive(); 
    waitdead();
  } while (! term_);

  killall();
}

const char* args(const int argc, const char* argv[]) {
  const char** argvi = argv;
  char* endptr;
  int nnodes, i;
  const char* pidfilename;

  if (argc < 4)
    fataln("Arguments: renice-number pid-file port... - Params: %d", 
	     argc-1);
  
  renice = strtol(*++argvi, &endptr, 0);
  if (! **argvi || *endptr)
    fataln("Renice argument must be an integer: `%s'", argvi);

  pidfilename = *++argvi;

  nnodes = argc-3;
  nodes = (struct nodes*) malloc(sizeof(struct nodes)
				  +sizeof(struct node)*nnodes);
  nodes->n = nnodes;
  for (i=0; i<nnodes; i++) {
    nodes->node[i].port = strtol(*++argvi, &endptr, 0);
    if (! **argvi || *endptr)
      fataln("Port argument must be an integer: `%s'", *argvi);
    nodes->node[i].pid = 0;
    nodes->node[i].io = 0;
  }

  return pidfilename;
}

static void killdaemon(pid_t pid, sigset_t* oldset, const char* format, ...) 
  __attribute__ ((format (printf, 3, 4)));

static void killdaemon(pid_t pid, sigset_t* oldset, const char* format, ...) {
  int s;
  static char buffer[1024];
  va_list ap;

  if (sigprocmask(SIG_SETMASK, oldset, NULL))
    errorxy("Master unable to revert sigprocmask");
  if (kill(pid, SIGTERM) && errno != ESRCH)
    errorxy("Master unable to send SIGTERM to daemon");

  sleep(DAEMON_TIME);
  kill(pid, SIGKILL);

  va_start(ap, format);
  s = vsnprintf(buffer, sizeof(buffer), format, ap);
  va_end(ap);
  if (s < 0) fataly("Master unable to format error");
  if (s >= sizeof(buffer)) fataln("Master had buffer overflow");

  fataly(buffer);
}

static void daemonize(const char* pidfilename) {
  FILE* pidfile;
  pid_t pid, pidr;
  int status;
  sigset_t set, oldset;

  if (sigemptyset(&set) 
      || sigaddset(&set, SIGINT) 
      || sigaddset(&set, SIGTERM)
      || sigaddset(&set, SIGQUIT))
    fataly("Master unable to set mask to SIGQUIT|SIGTERM|SIGINT");

  sethandler(sigint, SIGINT, 0);
  sethandler(sigterm, SIGTERM, 0);
  sethandler(sigterm, SIGQUIT, 0);

  if (sigprocmask(SIG_BLOCK, &set, &oldset))
    fataly("Master unable to set sigprocmask");
  
  if ((pid = fork())) {
    if (pid == -1) fataly("Master unable to fork");
    sethandler(SIG_IGN, SIGCHLD, SA_NOCLDWAIT);

    if (! (pidfile = fopen(pidfilename, "w")))
      killdaemon(pid, &oldset, "Master unable to open %s", pidfilename);

    if (fprintf(pidfile, "%i\n", pid) < 0)
      killdaemon(pid, &oldset, "Master unable to write to %s", pidfilename);

    if (fclose(pidfile))
      killdaemon(pid, &oldset, "Master unable to close %s", pidfilename);

    sigsuspend(&oldset);
    if (errno != EINTR) 
      killdaemon(pid, &oldset, "Master unable to sigsuspend");
    if (term_) killdaemon(pid, &oldset, "Master received terminate");
    if (! int_) 
      killdaemon(pid, &oldset, "Master did not receive SIGINT");
      
    if (kill(pid, SIGINT)) 
      killdaemon(pid, &oldset, "Master unable to signal %i", pid);
      
    exit(0);
  }
  
  startlog();
  if (kill(getppid(), SIGINT)) fataly("Daemon unable to signal master");
  sigsuspend(&oldset);
  if (errno != EINTR) fataly("Daemon unable to sigsuspend");
  sethandler(sigterm, SIGINT, 0);
  if (term_) exit(0);
  if (! int_) fataln("Daemon did not receive SIGINT");

  if (sigprocmask(SIG_SETMASK, &oldset, NULL))
    fataly("Daemon unable to revert sigprocmask");
}

static void setuids(void) {
  uid = getuid();
  euid = geteuid();
  gid = getgid();
  egid = getegid();

  if (uid == euid)
    warnxn("Not running setuid, uid = %i", uid);
  else if (seteuid(uid))
    fataly("Not able to switch euid from %i to %i", euid, uid);

  if (gid == egid)
    warnxn("Not running setgid, gid = %i", gid);
  else if (setegid(gid))
    fataly("Not able to switch egid from %i to %i", egid, gid);
}

int main(const int argc, const char* argv[]) {
  const char* pidfilename = args(argc, argv);
  setuids();
  daemonize(pidfilename);
  mainloop();
  
  return 0;
}
  
