#line 2 "@srcdir@/dqueen.c.in"

#include <signal.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <errno.h>
#include <unistd.h>

#include "dm.h"
#include "error-local.h"
#include "dm3.h"
#include "dm-nextevent.h"
#include "dqueen.h"

#define SOCKET_TIMEOUT (60)

static UL32 mpin = 0;
static P socketfd = -1;
static pid_t pid = -1;

P op_rthreads(void) {
  if (o1 <= CEILopds) return OPDS_OVF;
  TAG(o1) = (NUM | LONGBIGTYPE);
  ATTR(o1) = 0;
  LONGBIG_VAL(o1) = mpin;
  FREEopds = o2;

  return OK;
}

P op_checkrthreads(void) {
  BOOLEAN r;
  if (o1 >= CEILopds) return OPDS_OVF;
  if (! mpin) r = FALSE;
  else {
    pid_t pid_;
    while ((pid_ = waitpid(pid, NULL, WNOHANG)) != pid) {
      if (pid_ == -1 && errno != EINTR) return -errno;
      else if (pid_ == 0) break;
    }

    if (pid_) {
      pid = -1;
      mpin = 0;
      r = FALSE;
    }
    else r = TRUE;
  }

  TAG(o1) = BOOL;
  ATTR(o1) = 0;
  BOOL_VAL(o1) = r;
  FREEopds = o2;
  return OK;
}

P killrthreads(void) {
  P r = OK;

  if (socketfd != -1) {
    if (close(socketfd)) r = -errno;
    delsocket(socketfd);
    socketfd = -1;
  }

  if (pid != -1) {
    if (kill(pid, SIGTERM)) {
      if (! r) r = -errno;
      kill(pid, SIGKILL);
    }
    else {
      alarm(10);
      timeout = FALSE;
      while (! timeout) {
	if (waitpid(pid, NULL, 0) == -1) {
	  if (errno == EINTR) continue;
	  if (! r) r = -errno;
	  kill(pid, SIGKILL);
	  break;
	}
      }
      if (timeout) {
	kill(pid, SIGKILL);
	if (! r) r = TIMER;
      }
    }

    pid = -1;
  }

  mpin = 0;
  return r;
}

P op_makerthreads(void) {
  UL32 mpin_, ok;
  P _mpin_;
  int sockets[2];
  P r = OK;
  

  if (o_1 < FLOORopds) return OPDS_UNF;
  if (CLASS(o_1) != NUM) return OPD_CLA;
  if (! PVALUE(o_1, &_mpin_)) return UNDF_VAL;
  if ((_mpin_ > L32MAX) || (_mpin_ < -L32MAX)) return RNG_CHK;
  mpin_ = (UL32) _mpin_;

  if ((r = killrthreads())) return r;

  if (! mpin_) {
    mpin = 0;
    TAG(o_1) = NULLOBJ;
    ATTR(o_1) = 0;
    return OK;
  }

  if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets))
    return -errno;

  socketfd = sockets[0];
  if ((r = closeonexec(socketfd))
      || (r = nocloseonexec(sockets[1]))) {
    close(sockets[1]);
    killrthreads();
    return r;
  }

  if ((pid = fork()) == -1) {
    r = -errno;
    close(sockets[1]);
    killrthreads();
    return r;
  }

  if (! pid) {
    socketfd = sockets[1];

    if (dup2(socketfd, 3) == -1) 
      error(1, errno, "Error duping %i to %i", (int) socketfd, 3);
    if ((socketfd != 3) && close(socketfd))
      error(1, errno, "Error closing old socket fd %i", (int) socketfd);

    execl("@drook@", "@drook@", NULL);
    error(1, errno, "Error starting `%s'", "@drook@");
  }
   
  if (close(sockets[1])) {
    r = -errno;
    killrthreads();
    return r;
  }

  if ((r = writefd(socketfd, (B*) &mpin_, sizeof(mpin_), SOCKET_TIMEOUT))
      || (r = readfd(socketfd, (B*) &ok, sizeof(ok), SOCKET_TIMEOUT))) {
    killrthreads();
    return r;
  }
  
  mpin = mpin_;
  addsocket(socketfd);
  TAG(o_1) = (NULLOBJ | SOCKETTYPE);
  ATTR(o_1) = 0;
  LONGBIG_VAL(o_1) = socketfd;

  return OK;
}
