#line 2 "@srcdir@/drook.c.in"

/* #ifdef _XOPEN_SOURCE */
/* #if _XOPEN_SOURCE < 500 */
/* #undef _XOPEN_SOURCE */
/* #endif */
/* #ifndef _XOPEN_SOURCE */
/* #define _XOPEN_SOURCE 500 */
/* #endif */

#include "dm.h"
#include "error-local.h"

#include <stdio.h>
#include <mpi.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <stdlib.h>
#include <errno.h>

UL32 nodes;
P socketfd;
MPI_Comm children;
MPI_Request* requests;

DM_INLINE_STATIC void usage_error(const char* name) 
  __attribute__ ((__noreturn__));
void usage_error(const char* name) {
  error(1, 0, 
	"Usage: %s\n"
	"Unix socket is available on fd 3\n"
	"Number of jobs is 32 bit number available on socket", name);
  exit(1);
}

DM_INLINE_STATIC void read_socket_int(void* where, size_t n) {
  ssize_t r, off = 0;
  do {
    switch ((r = read(socketfd, where+off, n))) {
      case 0: 
	error(1, 0, "EOF from dnode");

      case -1:
	error(1, errno, "Error in socket read");

      default:
	n -= r;
	off += r;
    }
  } while (n > 0);
}

DM_INLINE_STATIC void write_socket_int(const void* where, size_t n) {
  ssize_t r, off = 0;
  do {
    if ((r = write(socketfd, where+off, n)) < 0)
      error(1, errno, "Error in socket write");

    n -= r;
    off += r;
  } while (n > 0);
}

DM_INLINE_STATIC void usage(int argc, char* argv[]) {
  if (argc != 1) usage_error(argv[0]); 
  socketfd = 3;
  read_socket_int(&nodes, sizeof(nodes));
}

DM_INLINE_STATIC void initmpi(void) {
  int argc = 0;
  char* argv[] = {NULL};
  int threadtype;

  MPI_Init_thread(&argc, (char***)&argv, MPI_THREAD_MULTIPLE, &threadtype);
  if (threadtype < MPI_THREAD_MULTIPLE)
    error(1, 0, "MPI_Init_thread: Requested %i, received %i\n", 
	  MPI_THREAD_MULTIPLE, threadtype);
}

DM_INLINE_STATIC void mpiabort(void) __attribute__ ((__noreturn__));
DM_INLINE_STATIC void mpiabort(void) {
  close(socketfd);
  MPI_Abort(children, 1);
  exit(1);
}

static void mpihandler(MPI_Comm* comm __attribute__ ((__unused__)), 
		       int* err, ...) {
  static char string[MPI_MAX_ERROR_STRING];
  int len;
  static BOOLEAN inhandler = FALSE;

  if (inhandler) return;
  inhandler = TRUE;

  if (MPI_Error_string(*err, string, &len))
    error(0, 0, "Unable to produce error string (%i)", *err);
  else
    error(0, 0, "Error mpi: %s", string);

  switch (*err) {
    case MPI_ERR_TRUNCATE:
    case MPI_ERR_NO_MEM:
      break;

    default:
      exit(1);
  };

  inhandler = FALSE;
}

DM_INLINE_STATIC void spawn(void) {
  int* errors;
  char* argv[] = {NULL};
  unsigned int i, any = 0;
  MPI_Errhandler mpierr;

  errors = (int*) malloc(sizeof(int)*nodes);
  MPI_Comm_spawn("@dpawn@", argv, nodes, MPI_INFO_NULL, 
		 0, MPI_COMM_WORLD, &children, errors);
  atexit(mpiabort);
  for (i = 0; i < nodes; i++) {
    if (errors[i]) {
      int len;
      static char string[MPI_MAX_ERROR_STRING];
      any = 1;
      MPI_Error_string(errors[i], string, &len);
      error(0, 0, "For node %i, error %i, %s", i, errors[i], string);
    }
  }
  if (any) exit(1);
  free(errors);

  MPI_Comm_create_errhandler(mpihandler, &mpierr);
  MPI_Comm_set_errhandler(children, mpierr);

  MPI_Barrier(children);
}

DM_INLINE_STATIC void writesocketerror(char* type, char* info) {
  static B errormsg[] = "rthread_";
  static B frames[FRAMEBYTES*2+sizeof(errormsg)+1024];
  static B *const boxf = frames;
  static B *const stringf = frames+FRAMEBYTES;
  static B *const string = frames+2*FRAMEBYTES;

  int n = snprintf(string, sizeof(errormsg)+1024, 
		   "(%s) %s%s", info, errormsg, type);
  if (n < 0) error(1, errno, "Unable to snprintf error message");
  if ((unsigned) n >= sizeof(errormsg)+1024) 
    error(1, 0, "snprintf overflow: %i", n);

  TAG(boxf) = BOX;
  BOX_NB(boxf) = FRAMEBYTES+n;
  SETNATIVE(boxf);
  
  TAG(stringf) = (ARRAY|BYTETYPE);
  ATTR(stringf) = 0;
  ARRAY_SIZE(stringf) = n;
  VALUE_PTR(stringf) = 0;

  write_socket_int(frames, FRAMEBYTES*2+n);
}

static B* from_dnode_data = NULL;
static P from_dnode_data_n = 0;

DM_INLINE_STATIC void dumpsocket(P n) {
  while (n) {
    static B throwaway[1024*10];
    P n_ = sizeof(throwaway) < (UP)n ? sizeof(throwaway) : (UP)n;
    read_socket_int(throwaway, n_);
    n -= n_;
  }
}

DM_INLINE_STATIC BOOLEAN readbody(void) {
  B* data_ = (B*) realloc(from_dnode_data, from_dnode_data_n);
  if (! data_) {
    dumpsocket(from_dnode_data_n - FRAMEBYTES);
    return FALSE;
  }
  
  from_dnode_data = data_;
  read_socket_int(from_dnode_data + FRAMEBYTES, 
		  from_dnode_data_n - FRAMEBYTES);

  return TRUE;
}

#define readsocketerr(doex, string) do {				\
    writesocketerror("readsocket", "Bad " string " from dnode");	\
    error((doex) ? 1 : 0, 0, "Bad " string " from dnode");		\
    retc = FALSE;							\
    goto RET;								\
  } while (0)

DM_INLINE_STATIC BOOLEAN readsocket(void) {
  BOOLEAN retc = TRUE;

  from_dnode_data_n = FRAMEBYTES;
  if (! (from_dnode_data = (B*) malloc(from_dnode_data_n)))
    readsocketerr(TRUE, "allocation of base frames");
  read_socket_int(from_dnode_data, from_dnode_data_n);

  if (! GETNATIVEFORMAT(from_dnode_data)
      || ! GETNATIVEUNDEF(from_dnode_data))
    readsocketerr(TRUE, "msg");
  if (GETNONNATIVE(from_dnode_data)) 
    readsocketerr(TRUE, "nativity");

  from_dnode_data_n += BOX_NB(from_dnode_data);
  if (! readbody()) readsocketerr(FALSE, "message body");

 RET:
  if (!retc && from_dnode_data) {
    free(from_dnode_data);
    from_dnode_data = NULL;
  }
  return retc;
}

DM_INLINE_STATIC void writempi(void) {
  P i;
  for (i = 0; i < nodes; i++) {
    MPI_Isend(from_dnode_data, FRAMEBYTES, MPI_UNSIGNED_CHAR,
	      i, 1, children, &requests[i]);
    MPI_Isend(from_dnode_data+FRAMEBYTES, from_dnode_data_n-FRAMEBYTES, 
	      MPI_UNSIGNED_CHAR,
	      i, 2, children, &requests[i*2]);
  }

  MPI_Waitall(nodes*2, requests, MPI_STATUSES_IGNORE);
  
  free(from_dnode_data);
  from_dnode_data = NULL;
}

DM_INLINE_STATIC void* from_dnode(void* arg) __attribute__ ((__noreturn__));
DM_INLINE_STATIC void* from_dnode(void* arg __attribute__ ((__unused__))) {
  UL32 ok;
  if (! (requests = (MPI_Request*) malloc(sizeof(MPI_Request)*nodes*2)))
    error(1, errno, "Unable to malloc requests");
  write_socket_int(&ok, sizeof(ok));

  while (1) if (readsocket()) writempi();
  exit(1);
}


DM_INLINE_STATIC BOOLEAN read_mpi_int(B* where, size_t n, int source, int tag) 
{
  return (BOOLEAN) MPI_Recv(where, n, MPI_UNSIGNED_CHAR,
			    source, tag, children, MPI_STATUS_IGNORE);
}

DM_INLINE_STATIC BOOLEAN probe_mpi_int(P* count, P* src, P tag) {
  MPI_Status status;
  if (MPI_Probe(*src, tag, children, &status))
    return FALSE;

  *count = status.count;
  *src = status.MPI_SOURCE;
  return TRUE;
}

DM_INLINE_STATIC void dumpmpi2(P source) {
  int r = MPI_Recv(NULL, 0, MPI_UNSIGNED_CHAR, 
		   source, 2, children, MPI_STATUS_IGNORE);
  switch (r) {
    case MPI_SUCCESS: case MPI_ERR_TRUNCATE: return;
  };

  writesocketerror("readmpi", "Unable to dump message from mpi");
  error(1, 0, "Unable to dump message from mpi");
}

DM_INLINE_STATIC void dumpmpi1(P source) {
  int r = MPI_Recv(NULL, 0, MPI_UNSIGNED_CHAR, 
		   source, 1, children, MPI_STATUS_IGNORE);
  switch (r) {
    case MPI_SUCCESS: case MPI_ERR_TRUNCATE: dumpmpi2(source); return;
  };

  writesocketerror("readmpi", "Unable to dump message from mpi");
  error(1, 0, "Unable to dump message from mpi");
}

static B* from_mpi_data = NULL;
static P from_mpi_data_n = 0;

#define readmpierr(doex, string) do {				\
    writesocketerror("readmpi", "Bad " string " from mpi");	\
    error((doex) ? 1 : 0, 0, "Bad " string " from mpi");	\
    ret = FALSE;						\
    goto RET;							\
  } while (0)

DM_INLINE_STATIC BOOLEAN readmpi(void) {
  BOOLEAN ret = TRUE;
  P source= MPI_ANY_SOURCE;
  P more_data_n;
  B* more_data;

  if (probe_mpi_int(&from_mpi_data_n, &source, 1)) 
    readmpierr(TRUE, "probing frames");

  if (! (from_mpi_data = (B*) malloc(from_mpi_data_n))) {
    dumpmpi1(source);
    readmpierr(FALSE, "total size");
  }

  if (read_mpi_int(from_mpi_data, from_mpi_data_n, source, 1)) {
    dumpmpi1(source);
    readmpierr(FALSE, "receiving frames");
  }

  if (probe_mpi_int(&more_data_n, &source, 2)) {
    dumpmpi2(source);
    readmpierr(FALSE, "probing latter frames");
  }
  
  if (! (more_data = (B*) realloc(from_mpi_data, 
				  from_mpi_data_n + more_data_n))) {
    dumpmpi2(source);
    readmpierr(FALSE, "total size - latter frames");
  }

  from_mpi_data = more_data;
  if (read_mpi_int(from_mpi_data + from_mpi_data_n, more_data_n, source, 2)) {
    dumpmpi2(source);
    readmpierr(FALSE, "receiving latter frames");
  }
  from_mpi_data_n += more_data_n;

 RET:
  if (! ret && from_mpi_data) {
    free(from_mpi_data);
    from_mpi_data = NULL;
  }

  return ret;
}

DM_INLINE_STATIC void writesocket(void) {
  write_socket_int(from_mpi_data, from_mpi_data_n);
  free(from_mpi_data);
  from_mpi_data = NULL;
}

DM_INLINE_STATIC void* from_mpi(void* arg) __attribute__ ((__noreturn__));
DM_INLINE_STATIC void* from_mpi(void* arg __attribute__ ((__unused__))) {
  while (1) if (readmpi()) writesocket();
  exit(1);
}

DM_INLINE_STATIC void makethread(char* name, void* (*func)(void*)) {
  pthread_t thread;
  if (pthread_create(&thread, NULL, func, NULL))
    error(1, errno, "Unable to create %s thread", name);
}

DM_INLINE_STATIC void mainthread(void) __attribute__ ((__noreturn__));
void mainthread(void) {
  int sig;
  sigset_t set;

  if (sigemptyset(&set) 
      || sigaddset(&set, SIGQUIT)
      || sigaddset(&set, SIGTERM)
      || sigaddset(&set, SIGPIPE))
    error(1, errno, "sigset failure");
      
  while (! sigwait(&set, &sig)) exit(0);
  error(1, errno, "Sigwait failure");
  exit(1);
}

DM_INLINE_STATIC void blocksigs(void) {
  sigset_t set;
  if (sigfillset(&set)) error(1, errno, "Unable to empty sigset");
  if (sigprocmask(SIG_BLOCK, &set, NULL)) 
    error(1, errno, "Unable to block sigs");
}

int main(int argc, char* argv[]) {
  usage(argc, argv);

  blocksigs();
  initmpi();
  spawn();
  
  makethread("mpi receive", from_mpi);
  makethread("dnode receive", from_dnode);
  mainthread();
}
