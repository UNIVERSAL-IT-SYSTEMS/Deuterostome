#line 2 "@srcdir@/drook.c.in"

/* #ifdef _XOPEN_SOURCE */
/* #if _XOPEN_SOURCE < 500 */
/* #undef _XOPEN_SOURCE */
/* #endif */
/* #ifndef _XOPEN_SOURCE */
/* #define _XOPEN_SOURCE 500 */
/* #endif */

#include "dm.h"
#include "error-local.h"
#include "dm2.h"

#include <stdio.h>
#include <mpi.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <stdlib.h>
#include <errno.h>

UL32 nodes;
P socketfd;
MPI_Comm children;
MPI_Request* requests;

DM_INLINE_STATIC void usage_error(const char* name) 
  __attribute__ ((__noreturn__));
void usage_error(const char* name) {
  error(1, 0, 
	"Usage: %s\n"
	"Unix socket is available on fd 3\n"
	"Number of jobs is 32 bit number available on socket", name);
  exit(1);
}

DM_INLINE_STATIC void read_socket_int(void* where, size_t n) {
  ssize_t r, off = 0;
  do {
    switch ((r = read(socketfd, where+off, n))) {
      case 0: 
	error(1, 0, "EOF from dnode");

      case -1:
	error(1, errno, "Error in socket read");

      default:
	n -= r;
	off += r;
    }
  } while (n > 0);
}

DM_INLINE_STATIC void write_socket_int(const void* where, size_t n) {
  ssize_t r, off = 0;
  do {
    if ((r = write(socketfd, where+off, n)) < 0)
      error(1, errno, "Error in socket write");

    n -= r;
    off += r;
  } while (n > 0);
}

DM_INLINE_STATIC void usage(int argc, char* argv[]) {
  if (argc != 1) usage_error(argv[0]); 
  socketfd = 3;
  read_socket_int(&nodes, sizeof(nodes));
}

DM_INLINE_STATIC void initmpi(void) {
  int argc = 0;
  char* argv[] = {NULL};
  int threadtype;

  MPI_Init_thread(&argc, (char***)&argv, MPI_THREAD_MULTIPLE, &threadtype);
  if (threadtype < MPI_THREAD_MULTIPLE)
    error(1, 0, "MPI_Init_thread: Requested %i, received %i\n", 
	  MPI_THREAD_MULTIPLE, threadtype);
}

static void exithandler(void) {
  static B boxf[2*FRAMEBYTES];
  P i;

  TAG(boxf) = BOX;
  VALUE_PTR(boxf) = 0;
  BOX_NB(boxf) = FRAMEBYTES;

  makename("quit", boxf+FRAMEBYTES);
  ATTR(boxf+FRAMEBYTES) = (ACTIVE|BIND);
  close(socketfd);

  for (i = 0; i < nodes; i++)
    MPI_Isend(boxf, 2*FRAMEBYTES, MPI_UNSIGNED_CHAR, 
	      i, 1, children, &requests[i]);

  MPI_Waitall(nodes, requests, MPI_STATUSES_IGNORE);
  MPI_Abort(children, 1);
}

static void mpihandler(MPI_Comm* comm __attribute__ ((__unused__)), 
		       int* err, ...) {
  static char string[MPI_MAX_ERROR_STRING];
  int len;
  static BOOLEAN inhandler = FALSE;

  if (inhandler) return;
  inhandler = TRUE;

  close(socketfd);
  if (MPI_Error_string(*err, string, &len))
    error(1, 0, "Unable to produce error string (%i)", *err);
  else
    error(1, 0, "Error mpi: %s", string);

  inhandler = FALSE;
}

DM_INLINE_STATIC void spawn(void) {
  int* errors;
  char* argv[] = {NULL};
  unsigned int i, any = 0;
  MPI_Errhandler mpierr;

  fprintf(stderr, "rook is spawning %i children\n", nodes);
  errors = (int*) malloc(sizeof(int)*nodes);
  MPI_Comm_spawn("@dpawn@", argv, nodes, MPI_INFO_NULL, 
		 0, MPI_COMM_WORLD, &children, errors);
  atexit(exithandler);
  for (i = 0; i < nodes; i++) {
    if (errors[i]) {
      int len;
      static char string[MPI_MAX_ERROR_STRING];
      any = 1;
      MPI_Error_string(errors[i], string, &len);
      error(0, 0, "For node %i, error %i, %s", i, errors[i], string);
    }
  }
  if (any) exit(1);
  free(errors);

  MPI_Comm_create_errhandler(mpihandler, &mpierr);
  MPI_Comm_set_errhandler(children, mpierr);

  fprintf(stderr, "Rook will wait for children\n");
  MPI_Barrier(children);
  fprintf(stderr, "Rook heard children\n");
}

DM_INLINE_STATIC void writesocketerror(char* type, char* info) {
  static B errormsg[] = "rthread_";
  static B frames[FRAMEBYTES*2+sizeof(errormsg)+1024];
  static B *const boxf = frames;
  static B *const stringf = frames+FRAMEBYTES;
  static B *const string = frames+2*FRAMEBYTES;

  int n = snprintf(string, sizeof(errormsg)+1024, 
		   "(%s) %s%s", info, errormsg, type);
  if (n < 0) error(1, errno, "Unable to snprintf error message");
  if ((unsigned) n >= sizeof(errormsg)+1024) 
    error(1, 0, "snprintf overflow: %i", n);

  TAG(boxf) = BOX;
  BOX_NB(boxf) = n;
  SETNATIVE(boxf);
  
  TAG(stringf) = (ARRAY|BYTETYPE);
  ATTR(stringf) = 0;
  ARRAY_SIZE(stringf) = n;
  VALUE_PTR(stringf) = 0;

  write_socket_int(frames, FRAMEBYTES*2+n);
}

static B* from_dnode_data = NULL;
static P from_dnode_data_n = 0;

DM_INLINE_STATIC void readbody(void) {
  B* data_ = (B*) realloc(from_dnode_data, from_dnode_data_n);
  if (! data_) 
    error(1, errno, "Unable to alloc %i", (int) from_dnode_data_n);
  
  from_dnode_data = data_;
  read_socket_int(from_dnode_data + FRAMEBYTES*2, 
		  from_dnode_data_n - FRAMEBYTES*2);
}

#define readsocketerr(string) do {					\
    writesocketerror("readsocket", "Bad " string " from dnode");	\
    error(1, 0, "Bad " string " from dnode");				\
  } while (0)

DM_INLINE_STATIC void readsocket(void) {
  from_dnode_data_n = FRAMEBYTES*2;
  if (! (from_dnode_data = (B*) malloc(from_dnode_data_n)))
    readsocketerr("allocation of base frames");
  read_socket_int(from_dnode_data, from_dnode_data_n);

  if (! GETNATIVEFORMAT(from_dnode_data)
      || ! GETNATIVEUNDEF(from_dnode_data))
    readsocketerr("msg");
  if (GETNONNATIVE(from_dnode_data)) 
    readsocketerr("nativity");

  from_dnode_data_n += BOX_NB(from_dnode_data);
  readbody();
}

DM_INLINE_STATIC void writempi(void) {
  P i, start, end, r;
  P dest = VALUE_BASE(from_dnode_data);
  VALUE_PTR(from_dnode_data) = NULL;
  
  if (nodes >= dest && dest > 0) {
    start = dest-1;
    end = dest;
  }
  else {
    start = 0;
    end = nodes;
  }

  r = 0;
  for (i = start; i < end; i++) {
    MPI_Isend(from_dnode_data, FRAMEBYTES*2, MPI_UNSIGNED_CHAR,
	      i, 1, children, &requests[r++]);
    if (from_dnode_data_n > FRAMEBYTES*2)
      MPI_Isend(from_dnode_data+FRAMEBYTES*2, from_dnode_data_n-FRAMEBYTES*2, 
		MPI_UNSIGNED_CHAR,
		i, 2, children, &requests[r++]);
  }

  MPI_Waitall(r, requests, MPI_STATUSES_IGNORE);
  
  free(from_dnode_data);
  from_dnode_data = NULL;
}

DM_INLINE_STATIC void* from_dnode(void* arg) __attribute__ ((__noreturn__));
DM_INLINE_STATIC void* from_dnode(void* arg __attribute__ ((__unused__))) {
  UL32 ok;
  if (! (requests = (MPI_Request*) malloc(sizeof(MPI_Request)*nodes*2)))
    error(1, errno, "Unable to malloc requests");
  write_socket_int(&ok, sizeof(ok));

  while (1) {readsocket(); writempi();};
  exit(1);
}


DM_INLINE_STATIC void read_mpi_int(B* where, size_t n, int source, int tag) 
{
  MPI_Recv(where, n, MPI_UNSIGNED_CHAR,
	   source, tag, children, MPI_STATUS_IGNORE);
}

DM_INLINE_STATIC void probe_mpi_int(P* count, P* src, P tag) {
  MPI_Status status;
  MPI_Probe(*src, tag, children, &status);
  *count = status.count;
  *src = status.MPI_SOURCE;
}

static B* from_mpi_data = NULL;
static P from_mpi_data_n = 0;

#define readmpierr(string) do {					\
    writesocketerror("readmpi", "Bad " string " from mpi");	\
    error(1, 0, "Bad " string " from mpi");	\
  } while (0)

DM_INLINE_STATIC void readmpi(void) {
  P source= MPI_ANY_SOURCE;
  P more_data_n;

  probe_mpi_int(&from_mpi_data_n, &source, 1);
  if (! (from_mpi_data = (B*) malloc(from_mpi_data_n)))
    readmpierr("total size");
  read_mpi_int(from_mpi_data, from_mpi_data_n, source, 1);

  probe_mpi_int(&more_data_n, &source, 2);
  if (! (from_mpi_data = (B*) realloc(from_mpi_data, 
				      from_mpi_data_n + more_data_n)))
    readmpierr("total size - latter frames");
  if (more_data_n > 0)
    read_mpi_int(from_mpi_data + from_mpi_data_n, more_data_n, source, 2);
  from_mpi_data_n += more_data_n;
}

DM_INLINE_STATIC void writesocket(void) {
  write_socket_int(from_mpi_data, from_mpi_data_n);
  free(from_mpi_data);
  from_mpi_data = NULL;
}

DM_INLINE_STATIC void* from_mpi(void* arg) __attribute__ ((__noreturn__));
DM_INLINE_STATIC void* from_mpi(void* arg __attribute__ ((__unused__))) {
  while (1) {readmpi(); writesocket();};
  exit(1);
}

DM_INLINE_STATIC void makethread(char* name, void* (*func)(void*)) {
  pthread_t thread;
  if (pthread_create(&thread, NULL, func, NULL))
    error(1, errno, "Unable to create %s thread", name);
}

DM_INLINE_STATIC void mainthread(void) __attribute__ ((__noreturn__));
void mainthread(void) {
  int sig;
  sigset_t set;

  if (sigemptyset(&set) 
      || sigaddset(&set, SIGQUIT)
      || sigaddset(&set, SIGTERM)
      || sigaddset(&set, SIGPIPE))
    error(1, errno, "sigset failure");
      
  while (! sigwait(&set, &sig)) exit(0);
  error(1, errno, "Sigwait failure");
  exit(1);
}

DM_INLINE_STATIC void blocksigs(void) {
  sigset_t set;
  if (sigfillset(&set)) error(1, errno, "Unable to empty sigset");
  if (sigprocmask(SIG_BLOCK, &set, NULL)) 
    error(1, errno, "Unable to block sigs");
}

int main(int argc, char* argv[]) {
  usage(argc, argv);

  blocksigs();
  initmpi();
  spawn();
  
  makethread("mpi receive", from_mpi);
  makethread("dnode receive", from_dnode);
  mainthread();
}
